{
  "version": "1.0.0",
  "lastUpdated": "2025-11-15",
  "category": "postgres",
  "questions": [
    {
      "id": 1,
      "question": "Какой тип данных рекомендуется для автоинкрементного целого PK до PostgreSQL 10?",
      "options": ["AUTO_INCREMENT", "SERIAL", "GENERATED ALWAYS AS IDENTITY", "SEQUENCE"],
      "correct": 1,
      "explanation": "До появления стандартного синтаксиса IDENTITY чаще применяли псевдотип SERIAL, создающий скрытую последовательность и DEFAULT.",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Какой уровень изоляции транзакций используется по умолчанию в PostgreSQL?",
      "options": ["READ UNCOMMITTED", "READ COMMITTED", "REPEATABLE READ", "SERIALIZABLE"],
      "correct": 1,
      "explanation": "По умолчанию PostgreSQL применяет READ COMMITTED: каждый оператор видит только уже зафиксированные изменения на момент его начала.",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "Какой оператор используется для проверки существования строк в подзапросе?",
      "options": ["COUNT(*)", "EXISTS", "IN", "ANY"],
      "correct": 1,
      "explanation": "EXISTS возвращает true при наличии хотя бы одной строки из подзапроса, оптимизатор может прекратить поиск рано.",
      "difficulty": "easy"
    },
    {
      "id": 4,
      "question": "Какой тип индекса создаётся по умолчанию командой CREATE INDEX без указания USING?",
      "options": ["GIN", "BTREE", "HASH", "SP-GiST"],
      "correct": 1,
      "explanation": "По умолчанию используется метод BTREE, оптимальный для большинства операций сравнения и сортировок.",
      "difficulty": "easy"
    },
    {
      "id": 5,
      "question": "Какой оператор используется для объединения результатов без удаления дубликатов?",
      "options": ["UNION", "UNION ALL", "INTERSECT", "MERGE"],
      "correct": 1,
      "explanation": "UNION ALL возвращает конкатенацию множеств без дополнительной сортировки и устранения дубликатов.",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "Какой тип данных подходит для хранения произвольной JSON структуры с возможностью индексации по путям?",
      "options": ["TEXT", "JSON", "JSONB", "XML"],
      "correct": 2,
      "explanation": "JSONB хранит бинарно разобранную структуру, поддерживает операторы и эффективные GIN индексы по ключам.",
      "difficulty": "easy"
    },
    {
      "id": 7,
      "question": "Команда для изменения структуры таблицы (добавить столбец)?",
      "options": ["UPDATE TABLE", "CHANGE TABLE", "ALTER TABLE", "MODIFY TABLE"],
      "correct": 2,
      "explanation": "ALTER TABLE используется для добавления, удаления столбцов и иных DDL изменений структуры.",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Какой метод аутентификации использует доверительную локальную авторизацию без пароля?",
      "options": ["md5", "scram-sha-256", "trust", "peer"],
      "correct": 2,
      "explanation": "trust разрешает подключение без проверки пароля — применять только в контролируемой среде.",
      "difficulty": "easy"
    },
    {
      "id": 9,
      "question": "Для чего используется команда ANALYZE?",
      "options": ["Резервное копирование", "Сбор статистики для оптимизатора", "Перестроение индексов", "Проверка целостности БД"],
      "correct": 1,
      "explanation": "ANALYZE обновляет статистику распределения данных, которой пользуется планировщик запросов.",
      "difficulty": "easy"
    },
    {
      "id": 10,
      "question": "Что делает оператор DISTINCT?",
      "options": ["Удаляет NULL", "Устраняет повторяющиеся строки", "Сортирует результат", "Группирует по всем столбцам"],
      "correct": 1,
      "explanation": "DISTINCT устраняет полные дубликаты строк результата, обычно через HashAggregate или Sort.",
      "difficulty": "easy"
    },
    {
      "id": 11,
      "question": "Что представляет собой MVCC в PostgreSQL?",
      "options": ["Алгоритм шифрования", "Модель многоверсионного контроля конкурентности", "Тип индекса", "Протокол репликации"],
      "correct": 1,
      "explanation": "MVCC хранит несколько версий строк, позволяя читателям не блокироваться на писателях и наоборот.",
      "difficulty": "medium"
    },
    {
      "id": 12,
      "question": "Какой системный каталог хранит определения таблиц и их столбцов?",
      "options": ["pg_class", "pg_tables", "pg_attribute", "pg_catalog"],
      "correct": 2,
      "explanation": "pg_attribute содержит строки для каждого столбца отношений, тогда как pg_class описывает сами отношения.",
      "difficulty": "medium"
    },
    {
      "id": 13,
      "question": "Назначение файла WAL?",
      "options": ["Хранение временных таблиц", "Журнал предзаписи для восстановления", "Содержит статистику запросов", "Хранение индексов"],
      "correct": 1,
      "explanation": "Write-Ahead Log фиксирует изменения до записи страниц в основное хранилище, обеспечивая crash-recovery и репликацию.",
      "difficulty": "medium"
    },
    {
      "id": 14,
      "question": "Что делает REINDEX?",
      "options": ["Анализирует статистику", "Перестраивает индекс заново", "Удаляет дубликаты строк", "Сливает таблицы"],
      "correct": 1,
      "explanation": "REINDEX пересоздаёт указанные индексы для устранения фрагментации или повреждений.",
      "difficulty": "medium"
    },
    {
      "id": 15,
      "question": "Какая директива в postgresql.conf управляет размером буфера shared_buffers?",
      "options": ["max_connections", "shared_buffers", "effective_cache_size", "work_mem"],
      "correct": 1,
      "explanation": "Параметр shared_buffers задаёт объём памяти для кэша страниц основных таблиц и индексов.",
      "difficulty": "medium"
    },
    {
      "id": 16,
      "question": "Какой тип индекса лучше для полнотекстового поиска по tsvector?",
      "options": ["BTREE", "GIN", "HASH", "BRIN"],
      "correct": 1,
      "explanation": "GIN индекс эффективно поддерживает поиск по множеству лексем внутри tsvector, храня отдельные списки позиций.",
      "difficulty": "medium"
    },
    {
      "id": 17,
      "question": "Назначение pg_stat_activity?",
      "options": ["Список активных транзакций", "Мониторинг текущих сеансов и запросов", "Детали структуры таблиц", "Содержит планы запросов"],
      "correct": 1,
      "explanation": "pg_stat_activity показывает активные backend процессы, их состояние, время и текст текущего запроса.",
      "difficulty": "medium"
    },
    {
      "id": 18,
      "question": "Что такое HOT-обновление (Heap-Only Tuple)?",
      "options": ["Обновление только индекса", "Обновление без касания индексов", "Обновление без создания новой строки", "Обновление в WAL, минуя таблицу"],
      "correct": 1,
      "explanation": "HOT позволяет не обновлять индексы, если изменённые столбцы не входят ни в один индекс, снижая нагрузку.",
      "difficulty": "medium"
    },
    {
      "id": 19,
      "question": "Что делает параметр work_mem?",
      "options": ["Лимит памяти для сортировок/хешей", "Размер WAL сегмента", "Буфер для копирования файлов", "Максимум подключений"],
      "correct": 0,
      "explanation": "work_mem определяет объем памяти на операцию (сортировка, хеш агрегация) до перехода на временные файлы.",
      "difficulty": "medium"
    },
    {
      "id": 20,
      "question": "Какой механизм предотвращает потерю данных при сбое сервера?",
      "options": ["АвтоVACUUM", "WAL", "CHECKPOINT", "Autonomous transactions"],
      "correct": 1,
      "explanation": "WAL обеспечивает журналирование всех изменений перед записью в основное хранилище, позволяя восстановиться.",
      "difficulty": "medium"
    },
    {
      "id": 21,
      "question": "Команда для просмотра плана выполнения запроса?",
      "options": ["SHOW PLAN", "EXPLAIN", "TRACE", "PLAN"],
      "correct": 1,
      "explanation": "EXPLAIN выводит план, а EXPLAIN ANALYZE дополнительно выполняет запрос и показывает время узлов.",
      "difficulty": "medium"
    },
    {
      "id": 22,
      "question": "Что означает состояние 'idle in transaction'?",
      "options": ["Запрос активно выполняется", "Сеанс ждёт блокировку таблицы", "Открыта транзакция без активного запроса", "Соединение закрыто"],
      "correct": 2,
      "explanation": "'idle in transaction' означает, что транзакция начата, но текущий оператор отсутствует, удерживаются ресурсы.",
      "difficulty": "medium"
    },
    {
      "id": 23,
      "question": "Какой тип индекса минимизирует диск для колоночно коррелированных данных?",
      "options": ["BRIN", "BTREE", "GIN", "SP-GiST"],
      "correct": 0,
      "explanation": "BRIN хранит сводные метаданные по блокам, эффективен для больших таблиц с упорядоченными значениями.",
      "difficulty": "medium"
    },
    {
      "id": 24,
      "question": "Что делает параметр autovacuum_vacuum_scale_factor?",
      "options": ["Процент обновленных строк для запуска VACUUM", "Размер WAL сегмента", "Лимит памяти VACUUM", "Интервал между CHECKPOINT"],
      "correct": 0,
      "explanation": "autovacuum_vacuum_scale_factor определяет долю мёртвых строк (от общей), при превышении которой запускается VACUUM.",
      "difficulty": "medium"
    },
    {
      "id": 25,
      "question": "Каков результат CREATE INDEX CONCURRENTLY?",
      "options": ["Блокирует таблицу целиком", "Создаёт индекс без долгих блокировок записи", "Удаляет старый индекс автоматически", "Сбрасывает статистику"],
      "correct": 1,
      "explanation": "CONCURRENTLY минимизирует блокировку: допускает DML операции, но требует две пассы и не внутри транзакции.",
      "difficulty": "medium"
    },
    {
      "id": 26,
      "question": "Что делает параметр synchronous_commit=off?",
      "options": ["Отключает запись WAL", "Снижает гарантию прочности, не дожидаясь flush WAL", "Отключает репликацию", "Включает синхронную репликацию"],
      "correct": 1,
      "explanation": "При off коммит завершается после локального записи в буфер WAL без гарантии физического flush — риск при сбое.",
      "difficulty": "medium"
    },
    {
      "id": 27,
      "question": "Какой оператор JSONB извлекает значение по ключу как текст?",
      "options": ["->", "#>", "->>", "@>", "?"],
      "correct": 2,
      "explanation": "Оператор ->> возвращает извлечённое значение как текст (простая строка), в отличие от -> (JSON).",
      "difficulty": "medium"
    },
    {
      "id": 28,
      "question": "Что делает параметр checkpoint_timeout?",
      "options": ["Макс время между контрольными точками", "Интервал автовакуума", "Таймаут блокировки", "Время ожидания репликации"],
      "correct": 0,
      "explanation": "checkpoint_timeout задаёт максимальный интервал между инициированием контрольных точек (checkpoint).",
      "difficulty": "medium"
    },
    {
      "id": 29,
      "question": "Что такое TOAST таблица?",
      "options": ["Таблица логов", "Автоматическая вспомогательная таблица для больших значений", "Таблица статистики", "Таблица настроек"],
      "correct": 1,
      "explanation": "TOAST хранит большие значения (например TEXT) вне основного набора страниц, позволяя сжимать и сегментировать.",
      "difficulty": "medium"
    },
    {
      "id": 30,
      "question": "Какой тип блокировки получается при SELECT ... FOR UPDATE?",
      "options": ["ACCESS SHARE", "ROW SHARE", "ROW EXCLUSIVE", "FOR KEY SHARE"],
      "correct": 2,
      "explanation": "SELECT FOR UPDATE накладывает RowExclusiveLock на отношения и метки блокировок (tuple-level) на выбранные строки.",
      "difficulty": "medium"
    },
    {
      "id": 31,
      "question": "Чем отличается TEMP таблица от UNLOGGED?",
      "options": ["TEMP шифруется, UNLOGGED нет", "UNLOGGED не журналируется в WAL, TEMP существует в сеансе", "TEMP реплицируется, UNLOGGED нет", "UNLOGGED создаётся в памяти"],
      "correct": 1,
      "explanation": "UNLOGGED таблицы пропускают WAL (быстрее, но не crash-safe), TEMP живёт внутри сессии и очищается при завершении.",
      "difficulty": "medium"
    },
    {
      "id": 32,
      "question": "Назначение параметра effective_cache_size?",
      "options": ["Фактический размер shared_buffers", "Оценка доступного кэша ОС для планировщика", "Лимит памяти для запросов", "Размер памяти для WAL"],
      "correct": 1,
      "explanation": "effective_cache_size даёт оптимизатору оценку размера файлового кэша, влияя на выбор индексных планов.",
      "difficulty": "medium"
    },
    {
      "id": 33,
      "question": "Какая команда включает расширение в текущей БД?",
      "options": ["LOAD EXTENSION", "CREATE EXTENSION", "INSTALL EXTENSION", "ALTER EXTENSION"],
      "correct": 1,
      "explanation": "CREATE EXTENSION регистрирует установленный компонент (например pg_trgm) в текущей базе данных.",
      "difficulty": "medium"
    },
    {
      "id": 34,
      "question": "Какой объект хранит последовательности?",
      "options": ["pg_sequence", "pg_seq", "pg_sequences", "pg_serial"],
      "correct": 0,
      "explanation": "С PostgreSQL 10 появилась системная таблица pg_sequence с атрибутами для последовательностей.",
      "difficulty": "medium"
    },
    {
      "id": 35,
      "question": "Что делает оператор || для массивов?",
      "options": ["Сравнивает массивы", "Конкатенирует массивы", "Удаляет элемент", "Сортирует массив"],
      "correct": 1,
      "explanation": "Оператор || объединяет содержимое двух массивов последовательно.",
      "difficulty": "medium"
    },
    {
      "id": 36,
      "question": "Какой режим записи в WAL снижает риск потери при сбое ОС?",
      "options": ["fsync=off", "full_page_writes=on", "synchronous_commit=off", "wal_compression=on"],
      "correct": 1,
      "explanation": "full_page_writes=on записывает полные страницы при первом изменении после checkpoint, предотвращая torn pages.",
      "difficulty": "medium"
    },
    {
      "id": 37,
      "question": "Какой индекс для операторов LIKE '%abc%' по тексту?",
      "options": ["BTREE", "GIN trigram (pg_trgm)", "HASH", "BRIN"],
      "correct": 1,
      "explanation": "pg_trgm с GIN или GiST ускоряет поиск подстроки внутри текста за счёт триграмм.",
      "difficulty": "medium"
    },
    {
      "id": 38,
      "question": "Что делает параметр wal_level=replica?",
      "options": ["Отключает WAL", "Пишет минимальный WAL для crash recovery", "Добавляет данные для потоковой репликации", "Включает только лог DDL"],
      "correct": 2,
      "explanation": "wal_level=replica добавляет достаточную информацию для репликации и Hot Standby, больше чем minimal.",
      "difficulty": "medium"
    },
    {
      "id": 39,
      "question": "Что такое HOT chain?",
      "options": ["Цепочка WAL файлов", "Последовательность только индексных обновлений", "Цепочка версий строк при HOT обновлениях", "Цепочка блокировок"],
      "correct": 2,
      "explanation": "HOT chain — серия версий одной строки в heap, доступная через TID без обновления индексов.",
      "difficulty": "medium"
    },
    {
      "id": 40,
      "question": "Что делает параметр maintenance_work_mem?",
      "options": ["Память для больших операций обслуживания (VACUUM, CREATE INDEX)", "Память для каждого запроса", "Размер кэша планов", "Память для фоновых процессов"],
      "correct": 0,
      "explanation": "maintenance_work_mem лимитирует память на операции обслуживания: VACUUM, CREATE INDEX, ALTER TABLE ADD FOREIGN KEY.",
      "difficulty": "medium"
    },
    {
      "id": 41,
      "question": "Какую блокировку накладывает TRUNCATE?",
      "options": ["ACCESS SHARE", "ACCESS EXCLUSIVE", "ROW EXCLUSIVE", "SHARE UPDATE EXCLUSIVE"],
      "correct": 1,
      "explanation": "TRUNCATE требует AccessExclusiveLock, блокируя другие операции на таблице.",
      "difficulty": "medium"
    },
    {
      "id": 42,
      "question": "Что делает параметр max_wal_size?",
      "options": ["Лимит общей длины WAL до принудительного checkpoint", "Размер сегмента WAL", "Размер буфера WAL в памяти", "Лимит числа реплик"],
      "correct": 0,
      "explanation": "max_wal_size ограничивает накопление WAL между контрольными точками, влияя на частоту checkpoint.",
      "difficulty": "medium"
    },
    {
      "id": 43,
      "question": "Что даёт PARTITION BY RANGE для больших таблиц?",
      "options": ["Ускоряет UPDATE всех строк", "Хранит данные в памяти", "Сегментирует по диапазону значений, ускоряя выборку и удаление", "Шифрует данные"],
      "correct": 2,
      "explanation": "Range partitioning распределяет строки по диапазонам, снижая объём сканирования и ускоряя архивацию секций.",
      "difficulty": "medium"
    },
    {
      "id": 44,
      "question": "Что делает параметр hot_standby=on на реплике?",
      "options": ["Разрешает запись на реплику", "Отключает репликацию", "Разрешает выполнение read-only запросов во время применения WAL", "Останавливает фоновые процессы"],
      "correct": 2,
      "explanation": "hot_standby=on позволяет выполнять запросы, пока реплика проигрывает WAL, обеспечивая доступность для чтения.",
      "difficulty": "medium"
    },
    {
      "id": 45,
      "question": "Что означает индекс partial?",
      "options": ["Индекс только по части таблицы (WHERE предикат)", "Индекс по части столбца", "Физически усечённый индекс", "Индекс без статистики"],
      "correct": 0,
      "explanation": "Partial индекс содержит только строки удовлетворяющие WHERE, уменьшает размер и ускоряет операции.",
      "difficulty": "medium"
    },
    {
      "id": 46,
      "question": "Зачем использовать GENERATED ALWAYS AS IDENTITY вместо SERIAL?",
      "options": ["Быстрее всех операций", "Стандарт SQL, лучше управляемость и зависимость без отдельного sequence", "Не требует WAL", "Делает колонку уникальной без индекса"],
      "correct": 1,
      "explanation": "IDENTITY соответствует стандарту, хранит метаданные в каталоге, управляется через ALTER TABLE и избегает скрытых особенностей SERIAL.",
      "difficulty": "medium"
    },
    {
      "id": 47,
      "question": "Что делает оператор @> для JSONB?",
      "options": ["Проверяет равенство", "Проверяет содержит ли левый документ правый", "Конкатенирует JSON", "Удаляет ключ"],
      "correct": 1,
      "explanation": "Оператор @> проверяет, что левый JSONB содержит структуру правого (superset).",
      "difficulty": "medium"
    },
    {
      "id": 48,
      "question": "Функция pg_cancel_backend(pid) делает что?",
      "options": ["Завершает сеанс полностью", "Посылает запросу сигнал отмены", "Удаляет пользователь", "Очищает статистику"],
      "correct": 1,
      "explanation": "pg_cancel_backend отправляет сигнал отмены текущего запроса, оставляя сеанс активным.",
      "difficulty": "medium"
    },
    {
      "id": 49,
      "question": "Что делает параметр wal_compression=on?",
      "options": ["Сжимает весь кластер", "Сжимает изменённые страницы (full page images)", "Сжимает каталоги", "Сжимает индексы"],
      "correct": 1,
      "explanation": "wal_compression сжимает полные образы страниц в WAL чтобы уменьшить объем журналов.",
      "difficulty": "medium"
    },
    {
      "id": 50,
      "question": "Что делает настройка temp_buffers?",
      "options": ["Буфер для системных каталогов", "Лимит памяти для временных таблиц каждой сессии", "Размер буфера WAL", "Размер кэша планов"],
      "correct": 1,
      "explanation": "temp_buffers задаёт максимальный объем буферов для временных таблиц внутри одной сессии.",
      "difficulty": "medium"
    },
    {
      "id": 51,
      "question": "Что означает HOT UPDATE недоступен?",
      "options": ["Изменены индексируемые столбцы", "Нет свободного места", "Таблица без TOAST", "Нет VACUUM"],
      "correct": 0,
      "explanation": "HOT невозможен если изменяемые столбцы участвуют в каких-либо индексах — требуется обновление индекса.",
      "difficulty": "hard"
    },
    {
      "id": 52,
      "question": "Почему REPEATABLE READ предотвращает phantom чтения иначе чем SERIALIZABLE?",
      "options": ["Использует блокировки таблиц", "Применяет MVCC снимок без SSI", "Полностью сериализует через глобальный мьютекс", "Отключает индексы"],
      "correct": 1,
      "explanation": "REPEATABLE READ фиксирует снимок видимости, но не обнаруживает конфликтующие write-skew; SERIALIZABLE (SSI) отслеживает зависимости.",
      "difficulty": "hard"
    },
    {
      "id": 53,
      "question": "Какой статистический вид информации хранится в pg_stat_all_tables?",
      "options": ["Текущие запросы", "Счетчики операций (seq scan, idx scan, tuples in/out) и вакуумов", "Планы запросов", "Размер буферов"],
      "correct": 1,
      "explanation": "pg_stat_all_tables содержит накопительные счетчики обращений: seq_scan, idx_scan, inserted, updated и т.п.",
      "difficulty": "hard"
    },
    {
      "id": 54,
      "question": "Где хранится информация о зависимостях объектов?",
      "options": ["pg_depend", "pg_class", "pg_constraint", "pg_index"],
      "correct": 0,
      "explanation": "pg_depend описывает зависимости между объектами каталога для корректного каскадного удаления и проверки.",
      "difficulty": "hard"
    },
    {
      "id": 55,
      "question": "Какова роль \"hint bits\" в MVCC?",
      "options": ["Сжатие индексов", "Оптимизация проверки видимости, отмечая коммит/аборт флаги", "Шифрование страниц", "Ускорение сортировки"],
      "correct": 1,
      "explanation": "Hint bits на страницах маркируют строки как коммитнутые/абортированные для ускорения последующих проверок видимости.",
      "difficulty": "hard"
    },
    {
      "id": 56,
      "question": "Что делает parameter vacuum_freeze_min_age?",
      "options": ["Минимальный возраст для freezing XID", "Макс число сессий", "Возраст TOAST значений", "Интервал между vacuum"],
      "correct": 0,
      "explanation": "vacuum_freeze_min_age определяет минимальное количество транзакций до попытки заморозки (freeze) строк.",
      "difficulty": "hard"
    },
    {
      "id": 57,
      "question": "Почему wraparound защиты требует регулярного VACUUM?",
      "options": ["Чтобы обновить статистику", "Чтобы заморозить старые XID и предотвратить переполнение 32-битного счетчика", "Чтобы уменьшить размер индексов", "Чтобы ускорить планировщик"],
      "correct": 1,
      "explanation": "Заморозка (freeze) предотвращает повторное использование идентификаторов транзакций для старых строк, иначе wraparound испортит видимость.",
      "difficulty": "hard"
    },
    {
      "id": 58,
      "question": "Чем BRIN отличается от GiST при пространственных данных?",
      "options": ["BRIN хранит упорядоченные интервалы блоков, GiST хранит деревья с обобщенными ключами", "GiST не поддерживает R-деревья", "BRIN быстрее для точных выборок", "BRIN требует уникальности"],
      "correct": 0,
      "explanation": "BRIN индексирует диапазоны блоков с агрегатами, GiST строит сбалансированное дерево с обобщенным интерфейсом (support methods).",
      "difficulty": "hard"
    },
    {
      "id": 59,
      "question": "Как PostgreSQL реализует SERIALIZABLE без глобальной блокировки?",
      "options": ["Полный мьютекс", "Мультиверсии и индексные блокировки", "SSI (Serializable Snapshot Isolation) отслеживающий опасные зависимости", "Перезапуск всех транзакций"],
      "correct": 2,
      "explanation": "SSI выявляет опасные цепочки rw-dependence и может отменить транзакцию для гарантии сериализуемости.",
      "difficulty": "hard"
    },
    {
      "id": 60,
      "question": "Что делает параметр track_io_timing?",
      "options": ["Отслеживает время ожидания I/O операций для статистики", "Уменьшает задержки", "Сжимает WAL", "Включает репликацию"],
      "correct": 0,
      "explanation": "track_io_timing=on собирает точные метрики времени чтения/записи блоков, увеличивая накладные расходы немного.",
      "difficulty": "hard"
    },
    {
      "id": 61,
      "question": "Назначение pg_locks?",
      "options": ["Хранит историю запросов", "Отображает текущие объекты и типы блокировок", "Содержит статистику индексов", "Сохраняет планы"],
      "correct": 1,
      "explanation": "pg_locks показывает активные блокировки: relation, transaction, page, tuple, advisory и их режимы.",
      "difficulty": "hard"
    },
    {
      "id": 62,
      "question": "Как работает logical decoding?",
      "options": ["Сериализует данные в CSV", "Читает WAL и преобразует изменения в логический поток (insert/update/delete) через плагины", "Сканирует таблицы целиком", "Требует REINDEX"],
      "correct": 1,
      "explanation": "Logical decoding разбирает WAL при wal_level=logical, плагины формируют логические изменения для публикаций/подписок.",
      "difficulty": "hard"
    },
    {
      "id": 63,
      "question": "Что делает pg_replication_slots?",
      "options": ["Настраивает память", "Хранит информацию о слотах предотвращающих удаление нужного WAL", "Содержит планы", "Удаляет старый WAL"],
      "correct": 1,
      "explanation": "Слоты репликации гарантируют сохранение требуемых WAL сегментов до их прочтения потребителем.",
      "difficulty": "hard"
    },
    {
      "id": 64,
      "question": "Зачем параметр wal_keep_size?",
      "options": ["Увеличивает shared_buffers", "Гарантирует минимальный объём WAL для реплик", "Ограничивает число подключений", "Удаляет старые индексы"],
      "correct": 1,
      "explanation": "wal_keep_size задаёт минимальный размер WAL файлов удерживаемых для быстрых реплик, снижая риск отставания.",
      "difficulty": "hard"
    },
    {
      "id": 65,
      "question": "Что такое visibility map?",
      "options": ["Карта индексов", "Битовая карта видимости и замороженности страниц для ускорения VACUUM", "Таблица статистики", "Карта буферов"],
      "correct": 1,
      "explanation": "Visibility map отмечает страницы где все tuples видимы и возможно заморожены, позволяя вакуум пропускать их.",
      "difficulty": "hard"
    },
    {
      "id": 66,
      "question": "Почему важен параметр random_page_cost?",
      "options": ["Определяет стоимость последовательного чтения", "Моделирует относительную стоимость случайного чтения блока к последовательному", "Включает кэш", "Оптимизирует парсинг"],
      "correct": 1,
      "explanation": "random_page_cost влияет на выбор индексных против последовательных сканирований, зависит от характеристик хранения.",
      "difficulty": "hard"
    },
    {
      "id": 67,
      "question": "Назначение parameter max_parallel_workers_per_gather?",
      "options": ["Максимум потоков приложения", "Максимум воркеров на узел Parallel Seq Scan/Gather", "Размер пула подключений", "Число реплик"],
      "correct": 1,
      "explanation": "Ограничивает параллельных воркеров в одном Gather узле плана запроса.",
      "difficulty": "hard"
    },
    {
      "id": 68,
      "question": "Чем отличается GIN от GiST по обновлениям?",
      "options": ["GIN быстрее вставок", "GiST требует полных перестроек", "GIN имеет более дорогие обновления из-за структуры постинга списков", "GiST не поддерживает поиск диапазона"],
      "correct": 2,
      "explanation": "GIN хранит обширные posting lists и может быть медленнее при интенсивных обновлениях, GiST обновляется инкрементально.",
      "difficulty": "hard"
    },
    {
      "id": 69,
      "question": "Что делает parameter vacuum_defer_cleanup_age?",
      "options": ["Откладывает удаление мёртвых строк для долгоживущих снапшотов", "Ускоряет vacuum", "Отключает freezing", "Удаляет индексы"],
      "correct": 0,
      "explanation": "vacuum_defer_cleanup_age позволяет задержать очистку dead tuples чтобы старые снимки не потеряли видимость.",
      "difficulty": "hard"
    },
    {
      "id": 70,
      "question": "Зачем нужен параметр shared_preload_libraries?",
      "options": ["Динамическая загрузка функций внутри транзакции", "Предзагрузка библиотек в postmaster для расширений требующих ранней инициализации", "Сжатие памяти", "Резервное копирование"],
      "correct": 1,
      "explanation": "shared_preload_libraries загружает расширения до форка рабочих процессов (например pg_stat_statements).",
      "difficulty": "hard"
    },
    {
      "id": 71,
      "question": "Как работает HOT pruning?",
      "options": ["Слияние WAL", "Удаление старых версий из HOT цепочки при отсутствии видимости для активных транзакций", "Сжатие индекса", "Шифрование строк"],
      "correct": 1,
      "explanation": "Pruning сокращает HOT цепочки удаляя устаревшие версии, освобождая место на странице до VACUUM.",
      "difficulty": "hard"
    },
    {
      "id": 72,
      "question": "Назначение parameter jit=on?",
      "options": ["Включает сжатие", "Активирует LLVM JIT компиляцию выражений, фильтров и агрегатов", "Удаляет индексы", "Включает репликацию"],
      "correct": 1,
      "explanation": "jit=on при наличии LLVM ускоряет интенсивные вычислительные запросы компиляцией в машинный код.",
      "difficulty": "hard"
    },
    {
      "id": 73,
      "question": "Почему важно корректно настроить wal_buffers?",
      "options": ["Для ускорения сортировок", "Для уменьшения частоты flush WAL при высоком потоке записей", "Для шифрования", "Для репликации логически"],
      "correct": 1,
      "explanation": "wal_buffers слишком малые вызывают частые записи, достаточный размер снижает contention и системные вызовы.",
      "difficulty": "hard"
    },
    {
      "id": 74,
      "question": "Что делает parameter max_standby_streaming_delay?",
      "options": ["Ограничивает задержку записи на primary", "Определяет максимальную задержку отмены запросов на реплике при конфликте WAL", "Уменьшает размер WAL", "Отключает потоковую репликацию"],
      "correct": 1,
      "explanation": "Если реплика отстаёт, конфликтующие запросы могут быть отменены по истечении этого лимита, сохраняя применимость WAL.",
      "difficulty": "hard"
    },
    {
      "id": 75,
      "question": "Назначение parameter statement_timeout?",
      "options": ["Лимит времени транзакции", "Макс время выполнения отдельного оператора до отмены", "Лимит времени подключения", "Время удержания блокировки"],
      "correct": 1,
      "explanation": "statement_timeout отменяет запрос превышающий порог, предотвращая долгие блокировки или ресурсоемкие операции.",
      "difficulty": "hard"
    },
    {
      "id": 76,
      "question": "Что такое xmin/xmax в заголовке tuple?",
      "options": ["Размер строки", "Идентификаторы транзакций создавшей и удалившей (либо замыкающей диапазон видимости) строку", "Идентификатор блокировки", "CRC контроль"],
      "correct": 1,
      "explanation": "xmin — транзакция вставки, xmax — транзакция удаления/обновления; они определяют видимость согласно MVCC.",
      "difficulty": "hard"
    },
    {
      "id": 77,
      "question": "Какая роль pg_subtrans?",
      "options": ["Хранит статистику", "Отслеживает связь субтранзакций с родительскими для MVCC", "Кэширует планы", "Шифрует данные"],
      "correct": 1,
      "explanation": "pg_subtrans журналирует родительские XID субтранзакций, позволяя правильно проверять видимость.",
      "difficulty": "hard"
    },
    {
      "id": 78,
      "question": "Что делает parameter parallel_tuple_cost?",
      "options": ["Уменьшает память", "Стоимость получения одной кортежи параллельным воркером для планировщика", "Сжимает страницы", "Шифрует индекс"],
      "correct": 1,
      "explanation": "parallel_tuple_cost влияет на оценку выгодности параллельного плана относительно последовательного.",
      "difficulty": "hard"
    },
    {
      "id": 79,
      "question": "Причина появления dead tuples?",
      "options": ["SELECT", "COMMIT", "UPDATE/DELETE создают устаревшие версии невидимые новым снапшотам", "VACUUM", "CHECKPOINT"],
      "correct": 2,
      "explanation": "UPDATE/DELETE оставляют старые версии строк до их очистки VACUUM для поддержки снимков MVCC.",
      "difficulty": "hard"
    },
    {
      "id": 80,
      "question": "Как работает xmin horizon на реплике?",
      "options": ["Удаляет все строки", "Определяет минимальный XID видимый активным снапшотам снижая возможность очистки", "Снимает бэкап", "Перестраивает индексы"],
      "correct": 1,
      "explanation": "xmin horizon предотвращает удаление данных преждевременно, учитывая активные запросы и репликацию.",
      "difficulty": "hard"
    },
    {
      "id": 81,
      "question": "Назначение parameter default_statistics_target?",
      "options": ["Размер буфера", "Глубина анализа распределения данных столбцов для планировщика", "Размер WAL", "Лимит параллельных воркеров"],
      "correct": 1,
      "explanation": "default_statistics_target влияет на количество выборок для оценки распределения значений, точность кардинальности.",
      "difficulty": "hard"
    },
    {
      "id": 82,
      "question": "Какой риск у слишком большого work_mem?",
      "options": ["Уменьшает производительность", "Потенциальное исчерпание памяти при множественных параллельных операциях", "Замедляет VACUUM", "Отменяет транзакции"],
      "correct": 1,
      "explanation": "work_mem применяется на каждую операцию (сортировка, хеш); множество таких операций может потреблять много памяти суммарно.",
      "difficulty": "hard"
    },
    {
      "id": 83,
      "question": "Что делает parameter max_parallel_maintenance_workers?",
      "options": ["Параллелит DML", "Ограничивает число воркеров для CREATE INDEX и подобных операций", "Отключает репликацию", "Сжимает таблицы"],
      "correct": 1,
      "explanation": "max_parallel_maintenance_workers задаёт воркеры для операций обслуживания (например параллельное построение индекса).",
      "difficulty": "hard"
    },
    {
      "id": 84,
      "question": "Как работает index-only scan?",
      "options": ["Требует full table scan", "Извлекает данные только из индекса при наличии видимости страницы в visibility map", "Использует TOAST", "Только для hash"],
      "correct": 1,
      "explanation": "Index-only scan читает индексы и проверяет visibility map чтобы избегать обращения к heap страницам.",
      "difficulty": "hard"
    },
    {
      "id": 85,
      "question": "Что делает parameter max_locks_per_transaction?",
      "options": ["Ограничивает число блокировок на уровне строк", "Ограничивает число объектов (relations) для которых транзакция может удерживать блокировки", "Ограничивает подключения", "Лимит индексов"],
      "correct": 1,
      "explanation": "max_locks_per_transaction умножается на max_connections чтобы определить shared memory для lock entries.",
      "difficulty": "hard"
    },
    {
      "id": 86,
      "question": "Почему SELECT COUNT(*) часто делает seq scan?",
      "options": ["COUNT требует сортировки", "Нет статистики", "Требуется прочитать все видимые строки для точного подсчёта (без вспомогательного хранения)", "Индекс медленнее"],
      "correct": 2,
      "explanation": "PostgreSQL не хранит точный счетчик строк из-за MVCC, поэтому COUNT(*) сканирует все страницы для точности.",
      "difficulty": "hard"
    },
    {
      "id": 87,
      "question": "Назначение parameter wal_receiver_status_interval?",
      "options": ["Сжимает WAL", "Интервал отправки статуса от реплики первичному", "Интервал VACUUM", "Интервал CHECKPOINT"],
      "correct": 1,
      "explanation": "wal_receiver_status_interval определяет как часто реплика сообщает позицию primary для слота и мониторинга.",
      "difficulty": "hard"
    },
    {
      "id": 88,
      "question": "Что делает parameter track_functions=pl?",
      "options": ["Отключает функции", "Собирает время выполнения только процедурных языков (PL) функций", "Сжимает функции", "Кэширует все функции"],
      "correct": 1,
      "explanation": "track_functions=pl включает сбор статистики времени и вызовов для PL функций (например plpgsql).",
      "difficulty": "hard"
    },
    {
      "id": 89,
      "question": "Чем отличается logical replication от physical?",
      "options": ["Physical передает SQL", "Logical передает файловые блоки", "Logical публикует изменения таблиц на уровне строк, physical передаёт WAL в бинарном виде", "Physical не поддерживает DDL"],
      "correct": 2,
      "explanation": "Logical replication декодирует WAL в логические изменения (INSERT/UPDATE/DELETE), physical применяет бинарные журналируемые страницы.",
      "difficulty": "hard"
    },
    {
      "id": 90,
      "question": "Назначение parameter deadlock_timeout?",
      "options": ["Время ожидания блокировки строки", "Интервал после которого проверяется возможный deadlock", "Интервал VACUUM", "Таймаут коммита"],
      "correct": 1,
      "explanation": "deadlock_timeout определяет задержку перед запуском детектора взаимных блокировок чтобы избежать лишних проверок.",
      "difficulty": "hard"
    },
    {
      "id": 91,
      "question": "Что делает parameter hot_standby_feedback=on?",
      "options": ["Отключает репликацию", "Отправляет реплике статистику", "Сообщает primary xmin реплики предотвращая преждевременную очистку", "Ускоряет VACUUM"],
      "correct": 2,
      "explanation": "hot_standby_feedback позволяет primary не удалять версии нужные длительным запросам на реплике, уменьшая конфликты.",
      "difficulty": "hard"
    },
    {
      "id": 92,
      "question": "Почему важен fillfactor для таблицы с частыми UPDATE?",
      "options": ["Увеличивает длину страниц", "Оставляет свободное место на странице для будущих обновлений минимизируя page splits и миграции", "Сжимает данные", "Шифрует записи"],
      "correct": 1,
      "explanation": "Fillfactor < 100 резервирует свободные слоты на страницах снижая необходимость размещения обновлённых версий на других страницах.",
      "difficulty": "hard"
    },
    {
      "id": 93,
      "question": "Что делает parameter log_min_duration_statement?",
      "options": ["Отключает лог", "Логирует запросы превышающие указанное время", "Логирует все запросы", "Сжимает логи"],
      "correct": 1,
      "explanation": "log_min_duration_statement записывает текст запросов дольше порога для анализа медленных операций.",
      "difficulty": "hard"
    },
    {
      "id": 94,
      "question": "Чем опасно долгоживущее idle in transaction?",
      "options": ["Ускоряет систему", "Блокирует VACUUM, удерживает ресурсы и повышает риск wraparound", "Отключает репликацию", "Удаляет индексы"],
      "correct": 1,
      "explanation": "Долгий idle in transaction удерживает xmin horizon, мешая очистке dead tuples и повышая риск исчерпания XID.",
      "difficulty": "hard"
    },
    {
      "id": 95,
      "question": "Что такое prepared statement в PostgreSQL?",
      "options": ["DDL команда", "Предварительно разобранный и сохранённый план запроса", "Кэш блоков", "Сжатый журнал"],
      "correct": 1,
      "explanation": "Prepared statement сохраняет разобранный (и возможно частично оптимизированный) план для повторного использования с разными параметрами.",
      "difficulty": "hard"
    },
    {
      "id": 96,
      "question": "Что делает parameter idle_in_transaction_session_timeout?",
      "options": ["Останавливает репликацию", "Автоматически завершает сессию в состоянии idle in transaction после таймаута", "Удаляет таблицы", "Отключает индексы"],
      "correct": 1,
      "explanation": "idle_in_transaction_session_timeout предотвращает долгоживущие висящие транзакции автоматически завершая сеанс.",
      "difficulty": "hard"
    },
    {
      "id": 97,
      "question": "Как работает constraint exclusion для партиций?",
      "options": ["Всегда сканирует все партиции", "Планировщик исключает партиции противоречащие WHERE по CHECK/partition constraint", "Отключает индексы", "Удаляет пустые партиции"],
      "correct": 1,
      "explanation": "Constraint exclusion пропускает партиции если условие WHERE несовместимо с их ограничением диапазона/значений.",
      "difficulty": "hard"
    },
    {
      "id": 98,
      "question": "Что делает parameter max_worker_processes?",
      "options": ["Число подключений", "Максимум фоновых процессов включая параллельные и расширения", "Размер памяти", "Число индексов"],
      "correct": 1,
      "explanation": "max_worker_processes ограничивает общее число background worker процессов для параллелизма и логической репликации.",
      "difficulty": "hard"
    },
    {
      "id": 99,
      "question": "Почему важна настройка seq_page_cost?",
      "options": ["Стоимость случайного чтения", "Стоимость последовательного чтения блока для планировщика", "Размер буфера", "Опция репликации"],
      "correct": 1,
      "explanation": "seq_page_cost вместе с random_page_cost определяет предпочтения планировщика между seq scan и индексными планами.",
      "difficulty": "hard"
    },
    {
      "id": 100,
      "question": "Что делает parameter effective_io_concurrency?",
      "options": ["Параллелит CPU", "Подсказывает планировщику допустимый параллелизм I/O для Bitmap Heap Scan", "Размер WAL", "Отключает JIT"],
      "correct": 1,
      "explanation": "effective_io_concurrency отражает возможности дисковой подсистемы (например количество outstanding requests) улучшая оценку bitmap scans.",
      "difficulty": "hard"
    }
  ]
}