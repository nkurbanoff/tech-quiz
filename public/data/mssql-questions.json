{
  "version": "2.0.0",
  "lastUpdated": "2025-11-18",
  "category": "mssql",
  "questions": [
    {
      "id": 1,
      "question": "Что такое кластерный индекс в SQL Server?",
      "options": [
        "Отдельная структура, не влияющая на порядок данных",
        "Индекс, определяющий физический порядок строк таблицы",
        "Индекс только для VIEW",
        "Только уникальный индекс"
      ],
      "correct": 1,
      "explanation": "Кластерный индекс определяет физический порядок строк в таблице, делая таблицу упорядоченной B-деревом по ключу кластерного индекса.",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Для чего используется переменная @@ROWCOUNT?",
      "options": [
        "Возвращает число таблиц в БД",
        "Возвращает число строк, затронутых последней инструкцией",
        "Возвращает количество индексов на таблице",
        "Возвращает размер базы данных"
      ],
      "correct": 1,
      "explanation": "@@ROWCOUNT возвращает количество строк, затронутых последней выполненной инструкцией DML или SELECT.",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "Что показывает план выполнения запроса (Execution Plan)?",
      "options": [
        "Историю выполнений запросов",
        "Шаги и операторы, используемые оптимизатором для выполнения запроса",
        "Только статистику ввода-вывода",
        "Содержимое кэша планов"
      ],
      "correct": 1,
      "explanation": "План выполнения отображает операторы (скан, поиск, соединение и т.д.) и их порядок, выбранные оптимизатором для выполнения запроса.",
      "difficulty": "easy"
    },
    {
      "id": 4,
      "question": "Что такое некластерный индекс?",
      "options": [
        "Индекс, идентичный кластерному",
        "Отдельная структура B-дерева, хранящая ключ и указатель на данные",
        "Только полнотекстовый индекс",
        "Индекс, доступный только в памяти"
      ],
      "correct": 1,
      "explanation": "Некластерный индекс — отдельная структура, содержащая ключи и указатели на строки данных (RID или ключ кластерного индекса).",
      "difficulty": "easy"
    },
    {
      "id": 5,
      "question": "Какой уровень изоляции по умолчанию в SQL Server?",
      "options": [
        "READ UNCOMMITTED",
        "READ COMMITTED",
        "REPEATABLE READ",
        "SNAPSHOT"
      ],
      "correct": 1,
      "explanation": "По умолчанию используется уровень изоляции READ COMMITTED.",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "Чем NVARCHAR отличается от VARCHAR?",
      "options": [
        "NVARCHAR хранит только ASCII",
        "NVARCHAR хранит Unicode, VARCHAR — кодовую страницу",
        "Разницы нет",
        "VARCHAR хранит Unicode, NVARCHAR — нет"
      ],
      "correct": 1,
      "explanation": "NVARCHAR — Unicode (UTF-16), VARCHAR — однобайтовые кодировки согласно колляции.",
      "difficulty": "easy"
    },
    {
      "id": 7,
      "question": "Что делает функция GETDATE()?",
      "options": [
        "Возвращает текущую дату без времени",
        "Возвращает текущие дату и время на сервере",
        "Возвращает только время",
        "Устанавливает системное время"
      ],
      "correct": 1,
      "explanation": "GETDATE() возвращает текущие дату и время (datetime) сервера SQL.",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Какой порядок по умолчанию у ORDER BY без указания ASC/DESC?",
      "options": [
        "DESC",
        "ASC",
        "Случайный",
        "Зависит от индекса"
      ],
      "correct": 1,
      "explanation": "ORDER BY без модификатора по умолчанию сортирует по возрастанию (ASC).",
      "difficulty": "easy"
    },
    {
      "id": 9,
      "question": "Чем COUNT(*) отличается от COUNT(столбец)?",
      "options": [
        "COUNT(*) игнорирует NULL, COUNT(столбец) — нет",
        "COUNT(*) считает все строки, COUNT(столбец) игнорирует NULL",
        "Обе функции всегда совпадают",
        "COUNT(столбец) считает быстрее"
      ],
      "correct": 1,
      "explanation": "COUNT(*) считает все строки, COUNT(столбец) — только строки с ненулевым значением в столбце.",
      "difficulty": "easy"
    },
    {
      "id": 10,
      "question": "Что возвращает LEFT JOIN при отсутствии совпадений в правой таблице?",
      "options": [
        "Строки не возвращаются",
        "Строки из левой таблицы с NULL-значениями справа",
        "Только совпадающие строки",
        "Дубликаты левых строк"
      ],
      "correct": 1,
      "explanation": "LEFT JOIN возвращает все строки левой таблицы; при отсутствии совпадений столбцы правой таблицы будут NULL.",
      "difficulty": "easy"
    },
    {
      "id": 11,
      "question": "Что такое индекс с включёнными столбцами (INCLUDE) в некластерном индексе?",
      "options": [
        "Кластерный индекс",
        "Дополнительные неключевые столбцы, хранимые на уровне листьев",
        "Полнотекстовый индекс",
        "Только уникальный индекс"
      ],
      "correct": 1,
      "explanation": "INCLUDE добавляет неключевые столбцы на уровень листьев некластерного индекса для покрытия запросов без обращения к таблице.",
      "difficulty": "medium"
    },
    {
      "id": 12,
      "question": "Что такое covering index?",
      "options": [
        "Любой кластерный индекс",
        "Индекс, содержащий все необходимые запросу столбцы",
        "Индекс для внешних ключей",
        "Индекс для полнотекстового поиска"
      ],
      "correct": 1,
      "explanation": "Covering index покрывает запрос: все используемые столбцы присутствуют в ключе и/или включённых столбцах индекса.",
      "difficulty": "medium"
    },
    {
      "id": 13,
      "question": "Что такое SARGability?",
      "options": [
        "Способность запроса использовать последовательные GUID",
        "Способность предикатов эффективно использовать индексы",
        "Функция для сортировки",
        "Опция параллелизма"
      ],
      "correct": 1,
      "explanation": "SARGable-предикаты позволяют оптимизатору применять индексный поиск вместо полного сканирования.",
      "difficulty": "medium"
    },
    {
      "id": 14,
      "question": "Что делает опция OPTION(RECOMPILE) для запроса?",
      "options": [
        "Запрещает выполнение запроса",
        "Компилирует план заново при каждом выполнении, не кэшируя",
        "Удаляет статистики",
        "Включает параллелизм"
      ],
      "correct": 1,
      "explanation": "RECOMPILE заставляет оптимизатор строить новый план и не сохранять его в кэш, часто помогает при параметрическом запахе.",
      "difficulty": "medium"
    },
    {
      "id": 15,
      "question": "Какая разница между TEMP TABLE (#t) и TABLE variable (@t)?",
      "options": [
        "Нет разницы",
        "@t имеет иные правила оценки кардинальности и статистик",
        "#t доступна только в CLR",
        "@t хранится в другой базе"
      ],
      "correct": 1,
      "explanation": "Табличные переменные имеют иные правила оценки кардинальности и статистик; временные таблицы поддерживают статистики и зачастую оптимизируются лучше.",
      "difficulty": "medium"
    },
    {
      "id": 16,
      "question": "Чем SEQUENCE отличается от IDENTITY?",
      "options": [
        "SEQUENCE работает только в памяти",
        "SEQUENCE — объект БД, независимый от таблицы; IDENTITY — свойство столбца",
        "IDENTITY всегда уникален, SEQUENCE — нет",
        "IDENTITY можно использовать в нескольких таблицах"
      ],
      "correct": 1,
      "explanation": "SEQUENCE — отдельный объект, который можно использовать в разных таблицах; IDENTITY — свойство конкретного столбца таблицы.",
      "difficulty": "medium"
    },
    {
      "id": 17,
      "question": "Что делает Query Store?",
      "options": [
        "Удаляет планы выполнения",
        "Собирает историю запросов, планов и метрик для анализа",
        "Выполняет бэкапы",
        "Отключает параллелизм"
      ],
      "correct": 1,
      "explanation": "Query Store сохраняет планы и статистику выполнения запросов, облегчая анализ регрессий и форсирование планов.",
      "difficulty": "medium"
    },
    {
      "id": 18,
      "question": "Назначение DBCC CHECKDB?",
      "options": [
        "Сжатие базы",
        "Проверка логической и физической целостности БД",
        "Создание индексов",
        "Смена колляции"
      ],
      "correct": 1,
      "explanation": "DBCC CHECKDB проверяет целостность всех объектов и страниц базы данных.",
      "difficulty": "medium"
    },
    {
      "id": 19,
      "question": "Какой режим восстановления позволяет точечное восстановление во времени при наличии лог-бэкапов?",
      "options": [
        "SIMPLE",
        "FULL",
        "SUSPECT",
        "READ_ONLY"
      ],
      "correct": 1,
      "explanation": "FULL позволяет точечное восстановление при наличии цепочки бэкапов: полный, дифференциальный и лог-бэкапы.",
      "difficulty": "medium"
    },
    {
      "id": 20,
      "question": "Для чего используют фильтрованные индексы (Filtered Index)?",
      "options": [
        "Для шифрования",
        "Для индексации подмножества строк с предикатом WHERE",
        "Для бэкапа",
        "Для репликации"
      ],
      "correct": 1,
      "explanation": "Фильтрованные индексы создаются на подмножество данных, снижая размер и ускоряя запросы по условию фильтра.",
      "difficulty": "medium"
    },
    {
      "id": 21,
      "question": "Что такое Columnstore индекс?",
      "options": [
        "Индекс по строкам",
        "Колонночный индекс, оптимизированный для аналитических нагрузок",
        "Только для временных таблиц",
        "Только уникальный индекс"
      ],
      "correct": 1,
      "explanation": "Columnstore хранит данные по столбцам, обеспечивает сильное сжатие и эффективен для сканирования больших наборов данных.",
      "difficulty": "medium"
    },
    {
      "id": 22,
      "question": "Что делает MAXDOP?",
      "options": [
        "Ограничивает максимальную глубину индексов",
        "Ограничивает максимальную степень параллелизма запроса",
        "Отключает планы",
        "Увеличивает размер буферного пула"
      ],
      "correct": 1,
      "explanation": "MAXDOP ограничивает максимальное число параллельных потоков, используемых для выполнения одного запроса.",
      "difficulty": "medium"
    },
    {
      "id": 23,
      "question": "Чем SNAPSHOT Isolation отличается от READ COMMITTED SNAPSHOT (RCSI)?",
      "options": [
        "Никак",
        "SNAPSHOT требует явного SET TRANSACTION ISOLATION LEVEL; RCSI прозрачно заменяет блокировки чтением версий",
        "RCSI — выше по уровню, чем SERIALIZABLE",
        "SNAPSHOT блокирует меньше, чем RCSI"
      ],
      "correct": 1,
      "explanation": "SNAPSHOT — явный уровень транзакции; RCSI — режим базы, делающий READ COMMITTED версионным.",
      "difficulty": "medium"
    },
    {
      "id": 24,
      "question": "Что такое параметрический запах (Parameter Sniffing)?",
      "options": [
        "Повреждение параметров",
        "Использование плана, оптимизированного под конкретные значения параметров, что может вредить другим значениям",
        "Ошибка компиляции",
        "Сбой репликации"
      ],
      "correct": 1,
      "explanation": "Оптимизатор при компиляции учитывает текущие значения параметров; полученный план может быть неэффективным для других значений.",
      "difficulty": "medium"
    },
    {
      "id": 25,
      "question": "Какой оператор T-SQL удобно использовать для нумерации строк в рамках раздела?",
      "options": [
        "GROUPING SETS",
        "ROW_NUMBER() OVER(PARTITION BY ... ORDER BY ...)",
        "HASHBYTES",
        "FOR XML PATH"
      ],
      "correct": 1,
      "explanation": "Функция ROW_NUMBER() с оконным определением нумерует строки в каждом разделе согласно сортировке.",
      "difficulty": "medium"
    },
    {
      "id": 26,
      "question": "Для чего используется CROSS APPLY?",
      "options": [
        "Полнотекстовый поиск",
        "Применение табличной функции к каждой строке внешнего набора",
        "Сжатие страниц",
        "Репликация"
      ],
      "correct": 1,
      "explanation": "CROSS APPLY соединяет внешнюю таблицу с результатом табличной функции, вызываемой для каждой строки.",
      "difficulty": "medium"
    },
    {
      "id": 27,
      "question": "Чем отличается OUTER APPLY от CROSS APPLY?",
      "options": [
        "Ничем",
        "OUTER APPLY сохраняет строки внешней таблицы при пустом результате функции",
        "CROSS APPLY делает LEFT JOIN",
        "OUTER APPLY быстрее"
      ],
      "correct": 1,
      "explanation": "OUTER APPLY аналогичен LEFT JOIN для APPLY: строки внешней стороны сохраняются даже при отсутствии результата функции (NULL-ы).",
      "difficulty": "medium"
    },
    {
      "id": 28,
      "question": "В чём преимущество Filtered Statistics?",
      "options": [
        "Создают бэкапы",
        "Даёт более точные оценки для подмножеств данных",
        "Включают CDC",
        "Отключают параллелизм"
      ],
      "correct": 1,
      "explanation": "Фильтрованные статистики улучшают оценку кардинальности для специфичных предикатов по подмножеству данных.",
      "difficulty": "medium"
    },
    {
      "id": 29,
      "question": "Чем отличается FULL от DIFFERENTIAL backup?",
      "options": [
        "DIFF содержит только лог",
        "DIFF содержит изменения с момента последнего полного бэкапа",
        "FULL включает только данные за день",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "DIFFERENTIAL хранит изменения относительно базового полного бэкапа, ускоряя восстановление.",
      "difficulty": "medium"
    },
    {
      "id": 30,
      "question": "Для чего используют партиционирование таблиц?",
      "options": [
        "Для шифрования",
        "Для масштабируемого управления крупными таблицами (управление сечениями, переключение, локальные индексы)",
        "Для генерации GUID",
        "Для снятия дампа памяти"
      ],
      "correct": 1,
      "explanation": "Партиционирование помогает управлять и обслуживать большие таблицы (переключение секций, локальные операции индексации).",
      "difficulty": "medium"
    },
    {
      "id": 31,
      "question": "Какое преимущество у параметра OPTION(OPTIMIZE FOR ...) ?",
      "options": [
        "Отключает статистики",
        "Позволяет указать оптимизатору, под какие значения строить план",
        "Включает инMemory",
        "Делает запрос атомарным"
      ],
      "correct": 1,
      "explanation": "OPTIMIZE FOR позволяет явно указать значения параметров для компиляции плана, обходя влияние текущих значений.",
      "difficulty": "medium"
    },
    {
      "id": 32,
      "question": "Как определить и исследовать взаимоблокировку (deadlock)?",
      "options": [
        "Через DBCC LOG", 
        "Через Extended Events/Trace флаги/SQL Server Error Log",
        "Никак",
        "Только через репликацию"
      ],
      "correct": 1,
      "explanation": "Взаимоблокировки фиксируются через Extended Events (system_health) и могут попадать в журнал ошибок; доступны графы deadlock.",
      "difficulty": "medium"
    },
    {
      "id": 33,
      "question": "Что такое Read-Ahead в SQL Server?",
      "options": [
        "Механизм резервного копирования",
        "Предварительное чтение страниц данными движком ввода-вывода",
        "Метод шифрования",
        "Механизм журналирования"
      ],
      "correct": 1,
      "explanation": "Read-Ahead — механизм предварительного чтения страниц из диска в буферный пул для ускорения сканов.",
      "difficulty": "medium"
    },
    {
      "id": 34,
      "question": "Назначение DMV sys.dm_exec_query_stats?",
      "options": [
        "Показывает структуру страниц",
        "Возвращает агрегированные статистики по выполненным планам",
        "Управляет правами",
        "Создаёт индексы"
      ],
      "correct": 1,
      "explanation": "sys.dm_exec_query_stats содержит статистику по кэшированным планам: время, логические чтения, выполнение и т.д.",
      "difficulty": "medium"
    },
    {
      "id": 35,
      "question": "Какова роль статистик в оптимизаторе запросов?",
      "options": [
        "Не используются",
        "Помогают оценить кардинальность и выбрать план",
        "Только для бэкапов",
        "Только для шифрования"
      ],
      "correct": 1,
      "explanation": "Статистики информируют оптимизатор о распределении значений, что влияет на выбор операторов и соединений.",
      "difficulty": "medium"
    },
    {
      "id": 36,
      "question": "Где хранятся объекты TempDB и как она используется?",
      "options": [
        "В пользовательской БД",
        "В системной базе TempDB для временных объектов, версионности, хеш-операций и т.д.",
        "В master",
        "Только в памяти"
      ],
      "correct": 1,
      "explanation": "TempDB — системная БД для временных таблиц, версий строк, операций сортировки/хеширования, промежуточных результатов и т.д.",
      "difficulty": "medium"
    },
    {
      "id": 37,
      "question": "Как быстро обновить статистики во всей базе?",
      "options": [
        "DBCC CHECKDB",
        "EXEC sp_updatestats",
        "ALTER DATABASE SET RECOVERY",
        "DBCC FREEPROCCACHE"
      ],
      "correct": 1,
      "explanation": "sp_updatestats обновляет устаревшие статистики во всей базе данных.",
      "difficulty": "medium"
    },
    {
      "id": 38,
      "question": "Чем отличается логическая и физическая фрагментация индекса?",
      "options": [
        "Нет отличий",
        "Логическая — порядок ключей; физическая — расположение страниц на диске/расхождение последовательностей",
        "Логическая — только для кластерных",
        "Физическая — только в памяти"
      ],
      "correct": 1,
      "explanation": "Логическая фрагментация — нарушение последовательности ключей; физическая — разреженное/несмежное размещение страниц, ухудшающее последовательное чтение.",
      "difficulty": "medium"
    },
    {
      "id": 39,
      "question": "Что делает WITH (NOLOCK)?",
      "options": [
        "Гарантирует читаемую консистентность",
        "Позволяет чтение без блокировок с риском грязного чтения",
        "Ускоряет только записи",
        "Включает снапшот"
      ],
      "correct": 1,
      "explanation": "NOLOCK (READ UNCOMMITTED) читает без ожидания, но возможны грязные, неповторяемые чтения и фантомы.",
      "difficulty": "medium"
    },
    {
      "id": 40,
      "question": "Какой тип соединения обычно эффективен при неравенствах и больших объёмах?",
      "options": [
        "Nested Loops",
        "Hash Match",
        "Merge Join",
        "Cartesian Join"
      ],
      "correct": 1,
      "explanation": "Hash Match эффективно обрабатывает большие наборы и неравенства, жертвуя памятью и возможными проливами в TempDB.",
      "difficulty": "medium"
    },
    {
      "id": 41,
      "question": "Где задаётся Cost Threshold for Parallelism?",
      "options": [
        "На уровне запроса",
        "На уровне сервера (sp_configure)",
        "Только на уровне базы",
        "В плане бэкапа"
      ],
      "correct": 1,
      "explanation": "Cost Threshold for Parallelism — настройка сервера, определяющая порог стоимости для запуска параллелизма.",
      "difficulty": "medium"
    },
    {
      "id": 42,
      "question": "Какая особенность у MERGE?",
      "options": [
        "Никогда не вызывает блокировок",
        "Комплексный оператор UPSERT, требующий аккуратности из-за известных нюансов",
        "Только для in-memory",
        "Требует CLR"
      ],
      "correct": 1,
      "explanation": "MERGE объединяет INSERT/UPDATE/DELETE; необходимо тщательно тестировать из-за чувствительности к дубликатам и триггерам.",
      "difficulty": "medium"
    },
    {
      "id": 43,
      "question": "Что такое системно-версионируемые (temporal) таблицы?",
      "options": [
        "Только для временных данных",
        "Таблицы, автоматически сохраняющие историю изменений в связанной истории",
        "Таблицы только для чтения",
        "Таблицы без индексов"
      ],
      "correct": 1,
      "explanation": "Temporal таблицы поддерживают версионность строк с исторической таблицей для запросов на момент времени (AS OF).",
      "difficulty": "medium"
    },
    {
      "id": 44,
      "question": "Какое преимущество у Resumable Index Rebuild?",
      "options": [
        "Ускоряет бэкапы",
        "Позволяет приостанавливать и возобновлять перестроение индекса",
        "Отменяет фрагментацию",
        "Меняет колляцию"
      ],
      "correct": 1,
      "explanation": "Resumable Rebuild позволяет прервать и затем возобновить перестроение индекса, удобно для крупных объектов.",
      "difficulty": "medium"
    },
    {
      "id": 45,
      "question": "Чем Columnstore Batch Mode полезен?",
      "options": [
        "Для OLTP вставок",
        "Обрабатывает данные пакетами, снижая накладные расходы операторов",
        "Для шифрования",
        "Для CDC"
      ],
      "correct": 1,
      "explanation": "Batch Mode обрабатывает строки в пакетах, что уменьшает CPU и ускоряет аналитические запросы.",
      "difficulty": "medium"
    },
    {
      "id": 46,
      "question": "Что делает DBCC FREEPROCCACHE?",
      "options": [
        "Удаляет данные",
        "Очищает кэш планов выполнения",
        "Останавливает сервер",
        "Чинит индексы"
      ],
      "correct": 1,
      "explanation": "DBCC FREEPROCCACHE очищает кэш планов; используйте осторожно, возможны просадки производительности.",
      "difficulty": "medium"
    },
    {
      "id": 47,
      "question": "Как создать покрывающий индекс для запроса со SELECT ... WHERE A = ? AND возвращающий B, C?",
      "options": [
        "CREATE INDEX IX ON T(B, C) INCLUDE (A)",
        "CREATE INDEX IX ON T(A) INCLUDE (B, C)",
        "CREATE INDEX IX ON T(C, B)",
        "CREATE INDEX IX ON T(A, B, C) UNIQUE"
      ],
      "correct": 1,
      "explanation": "Ключ: A для фильтрации, включённые B, C для покрытия результата без обращения к таблице.",
      "difficulty": "medium"
    },
    {
      "id": 48,
      "question": "Что такое RLS (Row-Level Security)?",
      "options": [
        "Шифрование данных",
        "Ограничение доступа к строкам с помощью предикатных функций",
        "Резервное копирование строк",
        "Сжатие строк"
      ],
      "correct": 1,
      "explanation": "Row-Level Security позволяет ограничивать видимость строк, применяя предикатную функцию безопасности к запросам.",
      "difficulty": "medium"
    },
    {
      "id": 49,
      "question": "Чем Dynamic Data Masking отличается от шифрования?",
      "options": [
        "Это то же самое",
        "Маскирование — презентационный слой, не защищает данные в хранилище",
        "Маскирование — аппаратное шифрование",
        "Шифрование — презентационный слой"
      ],
      "correct": 1,
      "explanation": "DDM скрывает значения при чтении для определённых ролей, но не шифрует данные на диске или в бэкапах.",
      "difficulty": "medium"
    },
    {
      "id": 50,
      "question": "Что делает TDE (Transparent Data Encryption)?",
      "options": [
        "Шифрует только лог",
        "Шифрует файлы данных и лога на уровне файлов (в покое)",
        "Шифрует трафик",
        "Маскирует данные"
      ],
      "correct": 1,
      "explanation": "TDE шифрует файлы данных/журнала и бэкапы; данные в памяти и трафик не шифруются TDE.",
      "difficulty": "medium"
    },
    {
      "id": 51,
      "question": "Чем Always Encrypted отличается от TDE?",
      "options": [
        "Нет отличий",
        "Always Encrypted шифрует данные на стороне клиента, не раскрывая их серверу",
        "TDE шифрует трафик",
        "Always Encrypted — только для логов"
      ],
      "correct": 1,
      "explanation": "Always Encrypted обеспечивает шифрование чувствительных данных на клиенте; сервер хранит и обрабатывает зашифрованные значения.",
      "difficulty": "medium"
    },
    {
      "id": 52,
      "question": "Что такое Page/Row Compression?",
      "options": [
        "Сжатие только колонок",
        "Механизмы сжатия строк/страниц для экономии места и иногда ускорения IO",
        "Сжатие только логов",
        "Только для tempdb"
      ],
      "correct": 1,
      "explanation": "Row/Page compression уменьшают размер данных, снижая IO; CPU нагрузка может вырасти.",
      "difficulty": "medium"
    },
    {
      "id": 53,
      "question": "Что делает REBUILD индекса по сравнению с REORGANIZE?",
      "options": [
        "Ничего",
        "REBUILD перестраивает индекс полностью; REORGANIZE дефрагментирует постранично",
        "Оба одинаковы",
        "REORGANIZE удаляет индекс"
      ],
      "correct": 1,
      "explanation": "REBUILD создаёт индекс заново, может обновлять статистики; REORGANIZE выполняет онлайн-дефрагментацию листьев.",
      "difficulty": "medium"
    },
    {
      "id": 54,
      "question": "Как быстро определить наиболее нагруженные запросы по чтениям?",
      "options": [
        "sys.objects",
        "sys.dm_exec_query_stats c CROSS APPLY sys.dm_exec_sql_text",
        "sp_help",
        "sys.all_columns"
      ],
      "correct": 1,
      "explanation": "Используйте DMV sys.dm_exec_query_stats совместно с sys.dm_exec_sql_text для анализа логических чтений/времени.",
      "difficulty": "medium"
    },
    {
      "id": 55,
      "question": "Чем OUTER JOIN отличается от INNER JOIN?",
      "options": [
        "Ничем",
        "OUTER JOIN сохраняет строки одной стороны при отсутствии совпадений",
        "INNER JOIN сохраняет все строки",
        "OUTER JOIN удаляет дубликаты"
      ],
      "correct": 1,
      "explanation": "LEFT/RIGHT OUTER JOIN сохраняет строки левой/правой таблицы даже без совпадений, заполняя NULL.",
      "difficulty": "medium"
    },
    {
      "id": 56,
      "question": "Какой объект использовать для трассировки событий вместо Profiler?",
      "options": [
        "DBCC TRACEON",
        "Extended Events",
        "SQLMail",
        "Replication Monitor"
      ],
      "correct": 1,
      "explanation": "Extended Events — современный, малозатратный механизм трассировки событий, заменяющий SQL Trace/Profiler.",
      "difficulty": "medium"
    },
    {
      "id": 57,
      "question": "Что делает READ_COMMITTED_SNAPSHOT (RCSI) на уровне базы?",
      "options": [
        "Отключает блокировки",
        "Переводит READ COMMITTED на версионное чтение из tempdb",
        "Включает снапшот на сервере",
        "Увеличивает MAXDOP"
      ],
      "correct": 1,
      "explanation": "RCSI меняет поведение READ COMMITTED на чтение версий из tempdb, снижая блокировки читателей/писателей.",
      "difficulty": "medium"
    },
    {
      "id": 58,
      "question": "Что такое FORCESEEK?",
      "options": [
        "Хинт для сортировки",
        "Хинт, заставляющий использовать поиск по индексу вместо скана",
        "Хинт для партиций",
        "Хинт для сжатия"
      ],
      "correct": 1,
      "explanation": "FORCESEEK заставляет использовать оператор Index Seek при наличии подходящего индекса.",
      "difficulty": "medium"
    },
    {
      "id": 59,
      "question": "Как ограничить ресурсы для группы сессий?",
      "options": [
        "Database Mail",
        "Resource Governor",
        "Service Broker",
        "Log Shipping"
      ],
      "correct": 1,
      "explanation": "Resource Governor позволяет ограничивать CPU/IO/Memory для групп рабочих нагрузок.",
      "difficulty": "medium"
    },
    {
      "id": 60,
      "question": "Где хранятся планы выполнения?",
      "options": [
        "В tempdb таблицах",
        "В кэше планов в памяти (процедурный кэш)",
        "В журнале транзакций",
        "В системных индексах диска"
      ],
      "correct": 1,
      "explanation": "Кэш планов в памяти содержит скомпилированные планы до их вытеснения по давлению на память.",
      "difficulty": "medium"
    },
    {
      "id": 61,
      "question": "Что такое параметр FORCE_LAST_GOOD_PLAN в Query Store?",
      "options": [
        "Удаляет все планы",
        "Автоматически форсирует стабильный план при обнаружении регрессии",
        "Запрещает параллелизм",
        "Отключает Query Store"
      ],
      "correct": 1,
      "explanation": "Автотюнинг Query Store может форсировать предыдущий успешный план при регрессии производительности.",
      "difficulty": "hard"
    },
    {
      "id": 62,
      "question": "Чем latch отличается от lock?",
      "options": [
        "Это одно и то же",
        "Latch — внутренняя защита структур памяти/страниц; lock — логическая синхронизация транзакций",
        "Lock — быстрее",
        "Latch используется в журнале транзакций"
      ],
      "correct": 1,
      "explanation": "Латчи защищают внутренние структуры и не участвуют в изоляции транзакций; блокировки обеспечивают изоляцию уровней транзакций.",
      "difficulty": "hard"
    },
    {
      "id": 63,
      "question": "Что такое ghost records?",
      "options": [
        "Записи в журнале",
        "Помеченные к удалению строки, очищаемые фоновым процессом",
        "Сжатые строки",
        "Шифрованные строки"
      ],
      "correct": 1,
      "explanation": "Ghost records — логически удалённые строки, физически очищаемые позднее процессом ghost cleanup.",
      "difficulty": "hard"
    },
    {
      "id": 64,
      "question": "Сколько шагов в гистограмме статистики может хранить SQL Server?",
      "options": [
        "64",
        "200",
        "1024",
        "4096"
      ],
      "correct": 1,
      "explanation": "Гистограмма статистики содержит до 200 шагов, отражающих распределение значений.",
      "difficulty": "hard"
    },
    {
      "id": 65,
      "question": "Что даёт параметр 'Optimize for Ad hoc Workloads'?",
      "options": [
        "Увеличивает MAXDOP",
        "Сохраняет скомпилированные планы ad-hoc сначала в сжатом виде (stub)",
        "Отключает сжатие",
        "Ускоряет журналирование"
      ],
      "correct": 1,
      "explanation": "Опция уменьшает давление на кэш планов, сохраняя stub для одноразовых запросов до повторного использования.",
      "difficulty": "hard"
    },
    {
      "id": 66,
      "question": "Где настраивается Forced Parameterization и что она делает?",
      "options": [
        "На уровне сервера; отключает кэш",
        "На уровне базы; заставляет параметризовать запросы для повторного использования планов",
        "На уровне запроса; включает параллелизм",
        "В tempdb; ускоряет сортировки"
      ],
      "correct": 1,
      "explanation": "Forced Parameterization — настройка базы: оптимизатор выполняет параметризацию, повышая повторное использование планов.",
      "difficulty": "hard"
    },
    {
      "id": 67,
      "question": "Что такое 'spill to TempDB' в операторах Hash/SORT?",
      "options": [
        "Сжатие данных",
        "Выгрузка промежуточных данных на диск при нехватке памяти",
        "Шифрование tempdb",
        "Удаление статистик"
      ],
      "correct": 1,
      "explanation": "При недостатке grant памяти операторы разливаются в tempdb, что ухудшает производительность.",
      "difficulty": "hard"
    },
    {
      "id": 68,
      "question": "Как снизить контеншен в tempdb при высокой конкуренции?",
      "options": [
        "Добавить больше журналов",
        "Добавить несколько файлов tempdb одинакового размера и включить trace flags/параметры при необходимости",
        "Отключить tempdb",
        "Переключить в READ_ONLY"
      ],
      "correct": 1,
      "explanation": "Рекомендуется несколько равных по размеру файлов tempdb, что уменьшает горячие точки распределения страниц.",
      "difficulty": "hard"
    },
    {
      "id": 69,
      "question": "Что такое Write-Ahead Logging (WAL) в SQL Server?",
      "options": [
        "Сжатие логов",
        "Принцип записи в журнал до записи данных на диск",
        "Шифрование логов",
        "Очистка логов"
      ],
      "correct": 1,
      "explanation": "Сначала запись фиксируется в журнале транзакций, затем соответствующие страницы могут быть записаны в данные.",
      "difficulty": "hard"
    },
    {
      "id": 70,
      "question": "Что такое VLF (Virtual Log File) и почему их количество важно?",
      "options": [
        "Сегменты данных в tempdb",
        "Внутренние сегменты журнала; слишком много VLF замедляет операции восстановления и бэкапа",
        "Индексы журнала",
        "Статистики журнала"
      ],
      "correct": 1,
      "explanation": "VLF — части файла журнала; чрезмерное количество приводит к деградации некоторых операций.",
      "difficulty": "hard"
    },
    {
      "id": 71,
      "question": "Instant File Initialization влияет на что?",
      "options": [
        "На файлы журнала",
        "На файлы данных, ускоряя рост/создание за счёт пропуска нулевания",
        "На буферный пул",
        "На кэш планов"
      ],
      "correct": 1,
      "explanation": "IFI ускоряет операции с файлами данных; на файлы журнала не распространяется.",
      "difficulty": "hard"
    },
    {
      "id": 72,
      "question": "Какие ограничения у Always Encrypted при поиске?",
      "options": [
        "Нет ограничений",
        "Невозможность эффективного LIKE и неиндексируемость детерминированно зашифрованных выражений по шаблонам",
        "Нельзя читать",
        "Только для GUID"
      ],
      "correct": 1,
      "explanation": "Шифрование препятствует операциям по шаблонам и диапазонам; детерминированное шифрование поддерживает равенство, но не LIKE/диапазоны.",
      "difficulty": "hard"
    },
    {
      "id": 73,
      "question": "Как работает Row Versioning в SNAPSHOT/RCSI?",
      "options": [
        "Записывает версии в master",
        "Хранит старые версии строк в tempdb для изоляции читателей",
        "Сжимает индексы",
        "Меняет MAXDOP"
      ],
      "correct": 1,
      "explanation": "Версии строк сохраняются в tempdb и используются для чтения согласованного снимка без блокировок.",
      "difficulty": "hard"
    },
    {
      "id": 74,
      "question": "Что такое план-гайды (Plan Guides)?",
      "options": [
        "Бэкапы планов",
        "Механизм принудительного применения хинтов к запросам без изменения кода",
        "Шифрование планов",
        "Удаление планов"
      ],
      "correct": 1,
      "explanation": "Plan Guides позволяют навязывать хинты/параметры компиляции конкретным запросам.",
      "difficulty": "hard"
    },
    {
      "id": 75,
      "question": "Какой параметр влияет на версию кардинального оценщика (CE) для запроса?",
      "options": [
        "DBCC DROPCLEANBUFFERS",
        "USE HINT('QUERY_OPTIMIZER_COMPATIBILITY_LEVEL_150')",
        "SET NOCOUNT ON",
        "DBCC CHECKIDENT"
      ],
      "correct": 1,
      "explanation": "Хинт QUERY_OPTIMIZER_COMPATIBILITY_LEVEL_X позволяет задать CE независимо от уровня совместимости базы.",
      "difficulty": "hard"
    },
    {
      "id": 76,
      "question": "Чем отличается CDC от Change Tracking?",
      "options": [
        "CDC быстрее",
        "CDC пишет детали изменений и данные в системные таблицы; CT отслеживает факты изменений без хранения старых значений",
        "CT хранит все версии",
        "Нет отличий"
      ],
      "correct": 1,
      "explanation": "CDC фиксирует вставки/удаления/старые/новые значения; CT — лёгкий механизм, показывающий что и когда изменилось.",
      "difficulty": "hard"
    },
    {
      "id": 77,
      "question": "Какой тип репликации лучше для почти реального времени и низкой задержки?",
      "options": [
        "Снимковая (Snapshot)",
        "Транзакционная (Transactional)",
        "Слияния (Merge)",
        "Лог шиппинг"
      ],
      "correct": 1,
      "explanation": "Транзакционная репликация обеспечивает низкую задержку доставки изменений подписчикам.",
      "difficulty": "hard"
    },
    {
      "id": 78,
      "question": "Что обеспечивает синхронная реплика в Always On AG?",
      "options": [
        "Минимальные задержки",
        "Подтверждение записи на вторичной реплике перед фиксацией на первичной",
        "Шифрование трафика",
        "Автоиндексацию"
      ],
      "correct": 1,
      "explanation": "В синхронном режиме коммит на первичной ожидает подтверждения записи на вторичной для консистентности.",
      "difficulty": "hard"
    },
    {
      "id": 79,
      "question": "Что такое переключение партиции (Partition Switch)?",
      "options": [
        "Репликация",
        "Метаданные операция перемещения секции между таблицами/индексами",
        "Сжатие секций",
        "Шифрование секций"
      ],
      "correct": 1,
      "explanation": "ALTER TABLE ... SWITCH PARTITION выполняет быструю метаданную операцию перемещения секции.",
      "difficulty": "hard"
    },
    {
      "id": 80,
      "question": "Как восстановить только повреждённую страницу данных?",
      "options": [
        "DBCC REPAIR_ALLOW_DATA_LOSS",
        "Page Restore из бэкапа при наличии полного/лог-бэкапов",
        "TRUNCATE TABLE",
        "ALTER DATABASE SET SINGLE_USER"
      ],
      "correct": 1,
      "explanation": "Page Restore позволяет восстановить отдельные страницы при полной цепочке бэкапов.",
      "difficulty": "hard"
    },
    {
      "id": 81,
      "question": "В чём особенность ONLINE INDEX REBUILD?",
      "options": [
        "Не блокирует вообще",
        "Минимизирует блокировки DML чтения/записи, но возможны короткие блокировки метаданных",
        "Только для heap",
        "Отключает триггеры"
      ],
      "correct": 1,
      "explanation": "ONLINE rebuild допускает конкурентный доступ, за исключением кратких блокировок схемы/метаданных.",
      "difficulty": "hard"
    },
    {
      "id": 82,
      "question": "Как включить инкрементальные статистики на партиционированной таблице?",
      "options": [
        "ALTER INDEX",
        "CREATE/UPDATE STATISTICS ... WITH INCREMENTAL = ON",
        "DBCC CHECKDB",
        "ALTER DATABASE SET INCREMENTAL"
      ],
      "correct": 1,
      "explanation": "Инкрементальные статистики создаются/обновляются с опцией INCREMENTAL = ON для партиционированных объектов.",
      "difficulty": "hard"
    },
    {
      "id": 83,
      "question": "Какие преимущества у Sparse Columns?",
      "options": [
        "Ускоряют сортировки",
        "Экономят место при большом количестве NULL",
        "Ускоряют Always On",
        "Ускоряют CDC"
      ],
      "correct": 1,
      "explanation": "Sparse Columns эффективны при высоком проценте NULL-значений, снижая потребление хранения.",
      "difficulty": "hard"
    },
    {
      "id": 84,
      "question": "Что такое Delta Store в Columnstore?",
      "options": [
        "Хранилище логов",
        "Строковое хранилище вставок, позже уплотняемое в сжатые столбцовые сегменты",
        "Сжатие строк",
        "Буферный пул"
      ],
      "correct": 1,
      "explanation": "Delta Store — промежуточное строковое хранилище для недавно вставленных строк до сжатия в сегменты.",
      "difficulty": "hard"
    },
    {
      "id": 85,
      "question": "Что обеспечивает сегмент-элиминация (Segment Elimination) в Columnstore?",
      "options": [
        "Сжатие логов",
        "Пропуск чтения сегментов по статистике минимума/максимума значений",
        "Удаление NULL",
        "Автопараллелизм"
      ],
      "correct": 1,
      "explanation": "Сегменты содержат min/max; несоответствующие сегменты пропускаются, уменьшая IO.",
      "difficulty": "hard"
    },
    {
      "id": 86,
      "question": "Чем Heap отличается от таблицы с кластерным индексом?",
      "options": [
        "Наличием кластерного ключа",
        "Heap не имеет кластерного индекса; строки не упорядочены",
        "Heap всегда быстрее",
        "Heap хранится только в tempdb"
      ],
      "correct": 1,
      "explanation": "Heap — таблица без кластерного индекса; возможны forwarding-указатели при обновлениях переменной длины.",
      "difficulty": "hard"
    },
    {
      "id": 87,
      "question": "Что такое Forwarded Records и где встречаются?",
      "options": [
        "В журнале",
        "В heap при обновлении строк переменной длины с перемещением на другую страницу",
        "В кластерных индексах",
        "В tempdb только"
      ],
      "correct": 1,
      "explanation": "В heap возможны пересылки (forwarding) — указатели с прежнего места на новое размещение строки, ухудшая чтение.",
      "difficulty": "hard"
    },
    {
      "id": 88,
      "question": "Что такое Memory Grant и где его видно?",
      "options": [
        "Выделение памяти для серверных ролей",
        "Память, выделяемая запросу для операторов (Hash/Sort), видна в плане и DMV",
        "Память буферного пула",
        "Память CLR"
      ],
      "correct": 1,
      "explanation": "Memory Grant — объём памяти на запрос для операторов; недооценка ведёт к spill, переоценка — к простаиванию.",
      "difficulty": "hard"
    },
    {
      "id": 89,
      "question": "Что такое Query Hash/Plan Hash?",
      "options": [
        "Контрольная сумма данных",
        "Хэши нормализованного текста запроса/плана для агрегации статистики",
        "Хэши имени индекса",
        "Хэши файла"
      ],
      "correct": 1,
      "explanation": "Query/Plan Hash используются в DMV для группировки запросов/планов независимо от параметров.",
      "difficulty": "hard"
    },
    {
      "id": 90,
      "question": "Как минимизировать эскалацию блокировок?",
      "options": [
        "Включить NOLOCK",
        "Дробить операции батчами, использовать хинты/трейсы осторожно",
        "Увеличить PAGE_SIZE",
        "Сжать данные"
      ],
      "correct": 1,
      "explanation": "Разбиение больших модификаций на партии и корректная стратегия индексации снижают вероятность эскалации до таблицы.",
      "difficulty": "hard"
    },
    {
      "id": 91,
      "question": "Как работает Ownership Chaining?",
      "options": [
        "Передаёт права между серверами",
        "Если объекты имеют одного владельца, проверка прав может не требоваться на каждом шаге",
        "Шифрует процедуры",
        "Блокирует транзакции"
      ],
      "correct": 1,
      "explanation": "Цепочка владения позволяет вызывать объекты без явной проверки прав на каждый объект при совпадении владельца.",
      "difficulty": "hard"
    },
    {
      "id": 92,
      "question": "Чем Service Broker полезен?",
      "options": [
        "Для бэкапов",
        "Асинхронные надёжные очереди сообщений внутри SQL Server",
        "Для репликации",
        "Для индексации"
      ],
      "correct": 1,
      "explanation": "Service Broker реализует очереди/диалоги для асинхронной обработки внутри СУБД с гарантией доставки.",
      "difficulty": "hard"
    },
    {
      "id": 93,
      "question": "Что даёт Contained Database?",
      "options": [
        "Больше файлов",
        "Упрощает перенос, позволяя логинам/пользователям быть локальными для базы",
        "Сжатие логов",
        "Ускоряет сортировки"
      ],
      "correct": 1,
      "explanation": "Contained Database минимизирует зависимость от серверных логинов и настроек, упрощая миграцию.",
      "difficulty": "hard"
    },
    {
      "id": 94,
      "question": "Чем отличается Transparent Data Encryption от шифрования на уровне столбцов (Cell-level)?",
      "options": [
        "Ничем",
        "TDE — шифрование на уровне файлов; шифрование столбцов — на уровне значений",
        "Оба на уровне значений",
        "Оба шифруют трафик"
      ],
      "correct": 1,
      "explanation": "TDE шифрует файлы/бэкапы; шифрование столбцов (старый подход) шифрует данные в конкретных столбцах.",
      "difficulty": "hard"
    },
    {
      "id": 95,
      "question": "Какая роль у Database Master Key и Certificate при TDE?",
      "options": [
        "Не используются",
        "DMK защищает сертификат, который защищает Database Encryption Key",
        "Сертификат шифрует буферный пул",
        "DMK хранит данные"
      ],
      "correct": 1,
      "explanation": "Иерархия: Service Master Key -> Database Master Key -> Certificate -> Database Encryption Key (TDE).",
      "difficulty": "hard"
    },
    {
      "id": 96,
      "question": "Что такое resumable online index create и когда полезен?",
      "options": [
        "Создание индекса для tempdb",
        "Создание индекса с возможностью паузы/возобновления — полезно для больших объектов",
        "Создание индекса без логирования",
        "Создание индекса без блокировок вообще"
      ],
      "correct": 1,
      "explanation": "Resumable create/rebuild позволяет прерывать долгие операции индексации и возобновлять позже.",
      "difficulty": "hard"
    },
    {
      "id": 97,
      "question": "Чем JSON поддержка в SQL Server ограничена?",
      "options": [
        "Нет ограничений",
        "Нет отдельного JSON-типа; JSON хранится в NVARCHAR и обрабатывается функциями OPENJSON/JSON_VALUE",
        "JSON хранится как бинарный тип",
        "JSON требует CLR"
      ],
      "correct": 1,
      "explanation": "SQL Server не имеет нативного JSON-типа; используется NVARCHAR и набор функций JSON_*.",
      "difficulty": "hard"
    },
    {
      "id": 98,
      "question": "Для чего нужны графовые таблицы (Graph Tables)?",
      "options": [
        "Для колонночного хранения",
        "Для моделирования вершин/рёбер и графовых запросов MATCH",
        "Для CDC",
        "Для репликации"
      ],
      "correct": 1,
      "explanation": "Graph Tables добавляют сущности узлов/рёбер и синтаксис MATCH для графовых сценариев.",
      "difficulty": "hard"
    },
    {
      "id": 99,
      "question": "Что такое natively compiled procedures в In-Memory OLTP?",
      "options": [
        "Обычные процедуры",
        "Процедуры, компилируемые в машинный код для работы с memory-optimized таблицами",
        "CLR-процедуры",
        "Процедуры для JSON"
      ],
      "correct": 1,
      "explanation": "Natively compiled процедуры оптимизированы для In-Memory таблиц, компилируются в машинный код, обеспечивая низкую задержку.",
      "difficulty": "hard"
    },
    {
      "id": 100,
      "question": "Какой тип индекса в In-Memory OLTP выбрать для точных равенств на уникальном ключе?",
      "options": [
        "Range индекс",
        "Hash индекс с подходящим bucket count",
        "Columnstore индекс",
        "XML индекс"
      ],
      "correct": 1,
      "explanation": "Hash-индексы эффективны для операций равенства, важно правильно подобрать количество корзин.",
      "difficulty": "hard"
    },
    {
      "id": 101,
      "question": "Для чего используется конструкция TRY...CATCH в T-SQL?",
      "options": [
        "Для логирования всех запросов",
        "Для обработки ошибок на уровне пакета/батча",
        "Для управления транзакциями READ ONLY",
        "Для профилирования запросов"
      ],
      "correct": 1,
      "explanation": "TRY...CATCH позволяет перехватывать ошибки в блоке TRY и обрабатывать их в блоке CATCH, включая откат транзакций и логирование.",
      "difficulty": "easy"
    },
    {
      "id": 102,
      "question": "Чем RAISERROR отличается от THROW в современных версиях SQL Server?",
      "options": [
        "Ничем, это синонимы",
        "THROW сохраняет стек ошибок и рекомендован вместо RAISERROR",
        "RAISERROR работает только внутри триггеров",
        "THROW нельзя использовать в блоке CATCH"
      ],
      "correct": 1,
      "explanation": "THROW в отличие от RAISERROR всегда возвращает ошибку с сохранением стека, не требует предварительного определения сообщений и рекомендован в новых разработках.",
      "difficulty": "medium"
    },
    {
      "id": 103,
      "question": "Что делает оператор OUTPUT в инструкциях INSERT/UPDATE/DELETE?",
      "options": [
        "Экспортирует данные в файл",
        "Возвращает затронутые строки или их части во внешний набор или таблицу",
        "Выводит текстовый план выполнения",
        "Обновляет статистики для таблицы"
      ],
      "correct": 1,
      "explanation": "Оператор OUTPUT позволяет вернуть значения вставленных, изменённых или удалённых строк во внешний результирующий набор или вставить их в таблицу/табличную переменную.",
      "difficulty": "medium"
    },
    {
      "id": 104,
      "question": "Какой тип триггера срабатывает один раз на оператор, а не на каждую строку?",
      "options": [
        "AFTER/INSTEAD OF триггеры в SQL Server",
        "ROW-level триггеры",
        "LOGON триггеры",
        "DDL триггеры"
      ],
      "correct": 0,
      "explanation": "В SQL Server DML-триггеры (AFTER и INSTEAD OF) выполняются один раз на оператор и работают с псевдотаблицами inserted/deleted, а не по одной записи.",
      "difficulty": "easy"
    },
    {
      "id": 105,
      "question": "Какой тип объекта лучше использовать для возвращения табличного результата из функции с оптимизацией по строчному исполнению?",
      "options": [
        "Многооператорная табличная функция (MSTVF)",
        "Функция, возвращающая TABLE через RETURN (inline TVF)",
        "Скалярная функция",
        "CLR-функция"
      ],
      "correct": 1,
      "explanation": "Inline TVF разворачивается в план как подзапрос/VIEW и обычно оптимизируется лучше, чем многооператорные табличные функции.",
      "difficulty": "medium"
    },
    {
      "id": 106,
      "question": "Что возвращает функция SCOPE_IDENTITY()?",
      "options": [
        "Последнее значение IDENTITY в пределах всей базы",
        "Последнее значение IDENTITY в текущем скоупе и сессии",
        "Максимальное значение IDENTITY в таблице",
        "ID последней вставленной строки независимо от таблицы"
      ],
      "correct": 1,
      "explanation": "SCOPE_IDENTITY() возвращает последнее значение IDENTITY, сгенерированное в текущем скоупе (процедуре/триггере) и сессии, избегая влияния триггеров и других таблиц.",
      "difficulty": "easy"
    },
    {
      "id": 107,
      "question": "Какой тип JOIN лучше всего подходит для поиска строк, отсутствующих в другой таблице (антиполуобъединение)?",
      "options": [
        "INNER JOIN",
        "LEFT JOIN ... WHERE правая_сторона IS NULL",
        "FULL JOIN",
        "CROSS JOIN"
      ],
      "correct": 1,
      "explanation": "Паттерн LEFT JOIN с фильтром WHERE правая_колонка IS NULL – классический способ анти-join'а, часто альтернативен NOT EXISTS.",
      "difficulty": "easy"
    },
    {
      "id": 108,
      "question": "Чем NOT EXISTS обычно предпочтительнее LEFT JOIN ... IS NULL при анти-join?",
      "options": [
        "NOT EXISTS всегда использует индекс",
        "NOT EXISTS корректно обрабатывает NULL и зачастую даёт более очевидный план",
        "LEFT JOIN не поддерживается оптимизатором",
        "NOT EXISTS автоматически параллелен"
      ],
      "correct": 1,
      "explanation": "NOT EXISTS не подвержен ловушкам с NULL и часто приводит к более читаемому и предсказуемому плану, хотя оптимизатор может тождественно преобразовать варианты.",
      "difficulty": "medium"
    },
    {
      "id": 109,
      "question": "Какой оператор использовать для условного выбора первого ненулевого значения из списка выражений?",
      "options": [
        "ISNULL",
        "COALESCE",
        "CASE WHEN",
        "IIF"
      ],
      "correct": 1,
      "explanation": "COALESCE возвращает первый ненулевой аргумент из списка, при этом обрабатывает более двух аргументов и следует стандарту SQL.",
      "difficulty": "easy"
    },
    {
      "id": 110,
      "question": "Какой тип ограничения стоит использовать для обеспечения ссылочной целостности между таблицами?",
      "options": [
        "CHECK",
        "FOREIGN KEY",
        "DEFAULT",
        "UNIQUE"
      ],
      "correct": 1,
      "explanation": "FOREIGN KEY гарантирует, что значение во внешнем ключе существует в родительской таблице или равно NULL (при разрешённом NULL).",
      "difficulty": "easy"
    },
    {
      "id": 111,
      "question": "Чем UNIQUE CONSTRAINT отличается от UNIQUE INDEX?",
      "options": [
        "UNIQUE CONSTRAINT не создаёт индекса",
        "UNIQUE CONSTRAINT логически обеспечивает уникальность, физически реализуется уникальным индексом",
        "UNIQUE INDEX запрещает NULL",
        "UNIQUE INDEX доступен только для кластерных индексов"
      ],
      "correct": 1,
      "explanation": "UNIQUE CONSTRAINT – декларативное ограничение схемы, реализуемое под капотом уникальным индексом; UNIQUE INDEX можно создать без ограничения.",
      "difficulty": "medium"
    },
    {
      "id": 112,
      "question": "В чём особенность индексированных VIEW (Indexed Views) в SQL Server?",
      "options": [
        "Всегда материализуются в tempdb",
        "Требуют WITH SCHEMABINDING и имеют физическое хранилище",
        "Не могут содержать агрегаты",
        "Всегда обновляются только по расписанию"
      ],
      "correct": 1,
      "explanation": "Индексированное представление требует WITH SCHEMABINDING, первый индекс – кластерный, данные материализуются и автоматически поддерживаются при DML.",
      "difficulty": "hard"
    },
    {
      "id": 113,
      "question": "Что делает опция WITH SCHEMABINDING для VIEW или функции?",
      "options": [
        "Запрещает использование индексов",
        "Запрещает изменять базовые объекты, ломая схему представления/функции",
        "Отключает план-кэш",
        "Обязательно включает параллелизм"
      ],
      "correct": 1,
      "explanation": "SCHEMABINDING связывает объект со схемой базовых таблиц, не позволяя их изменять так, чтобы нарушить определение представления или функции.",
      "difficulty": "medium"
    },
    {
      "id": 114,
      "question": "Какой DMV использовать, чтобы увидеть активные запросы и их текущие операторы?",
      "options": [
        "sys.dm_exec_sessions",
        "sys.dm_exec_requests",
        "sys.dm_tran_locks",
        "sys.dm_os_wait_stats"
      ],
      "correct": 1,
      "explanation": "sys.dm_exec_requests показывает активные запросы, их статус, ресурсы и текущий выполняемый оператор.",
      "difficulty": "medium"
    },
    {
      "id": 115,
      "question": "Какой DMV позволяет посмотреть накопленную статистику ожиданий (waits) на уровне сервера?",
      "options": [
        "sys.dm_os_wait_stats",
        "sys.dm_os_performance_counters",
        "sys.dm_os_waiting_tasks",
        "sys.dm_exec_requests"
      ],
      "correct": 0,
      "explanation": "sys.dm_os_wait_stats агрегирует статистику ожиданий по типам, помогая определить узкие места (IO, CPU, блокировки и т.п.).",
      "difficulty": "medium"
    },
    {
      "id": 116,
      "question": "Что характеризует показатель Page Life Expectancy (PLE)?",
      "options": [
        "Время жизни строки в журнале транзакций",
        "Среднее время (в секундах), которое страница данных проводит в буферном пуле",
        "Время блокировки страницы",
        "Время построения плана запроса"
      ],
      "correct": 1,
      "explanation": "PLE – приблизительное время, в течение которого страница данных остаётся в буферном пуле, низкие значения могут указывать на давление по памяти.",
      "difficulty": "medium"
    },
    {
      "id": 117,
      "question": "Какой тип индекса предпочтителен для столбца, по которому часто выполняются range-запросы (>, <, BETWEEN)?",
      "options": [
        "Hash индекс",
        "B-Tree (обычный кластерный/некластерный)",
        "Columnstore индекс",
        "XML индекс"
      ],
      "correct": 1,
      "explanation": "Классические B-деревья (кластерные/некластерные индексы) хорошо поддерживают диапазонные запросы, используя индексный поиск и скан по диапазону.",
      "difficulty": "easy"
    },
    {
      "id": 118,
      "question": "Что будет, если создать несколько индексов с одинаковым набором ключевых столбцов, но разными INCLUDE?",
      "options": [
        "SQL Server их сольёт автоматически",
        "Получится дублирование индексов и лишняя нагрузка на DML",
        "Будет ошибка создания индекса",
        "Все INCLUDE будут объединены в один индекс"
      ],
      "correct": 1,
      "explanation": "Дублирующиеся по ключу индексы с разными INCLUDE приводят к лишним обновлениям при DML и занимают место; желательно консолидировать их.",
      "difficulty": "medium"
    },
    {
      "id": 119,
      "question": "Какая проблема часто возникает при использовании GUID (uniqueidentifier) в качестве кластерного ключа без NEWSEQUENTIALID()?",
      "options": [
        "Невозможность создать некластерные индексы",
        "Сильная фрагментация и перегрузка страниц из-за случайного распределения вставок",
        "GUID нельзя использовать во внешних ключах",
        "GUID не поддерживается в индексах вообще"
      ],
      "correct": 1,
      "explanation": "Случайные GUID вызывают вставки в произвольные места B-дерева, увеличивая фрагментацию и накладные расходы на IO и блокировки.",
      "difficulty": "medium"
    },
    {
      "id": 120,
      "question": "Какой параметр базы отвечает за автоматическое обновление статистик при изменении данных?",
      "options": [
        "AUTO_CREATE_STATISTICS",
        "AUTO_UPDATE_STATISTICS",
        "AUTO_SHRINK",
        "AUTO_CLOSE"
      ],
      "correct": 1,
      "explanation": "AUTO_UPDATE_STATISTICS включает автоматическое обновление статистик при достижении определённого порога изменения данных.",
      "difficulty": "easy"
    },
    {
      "id": 121,
      "question": "Какой эффект может дать опция AUTO_UPDATE_STATISTICS_ASYNC?",
      "options": [
        "Синхронно обновляет статистики до выполнения запроса",
        "Переносит обновление статистик в асинхронный поток, позволяя запросу выполняться со старыми статистиками",
        "Отключает автообновление статистик",
        "Включает параллельное обновление индексов"
      ],
      "correct": 1,
      "explanation": "AUTO_UPDATE_STATISTICS_ASYNC позволяет не блокировать компиляцию запросов на обновление статистик, но запрос может выполняться на устаревших данных до завершения обновления.",
      "difficulty": "medium"
    },
    {
      "id": 122,
      "question": "Что делает параметр READ_ONLY у базы данных?",
      "options": [
        "Запрещает SELECT",
        "Запрещает любые операции записи (DML, DDL), разрешая только чтение",
        "Переводит базу в режим SIMPLE",
        "Отключает индексы"
      ],
      "correct": 1,
      "explanation": "READ_ONLY переводит базу в режим только для чтения: любые изменения данных или схемы становятся невозможны.",
      "difficulty": "easy"
    },
    {
      "id": 123,
      "question": "Какая команда выводит список активных транзакций и их состояние?",
      "options": [
        "DBCC CHECKDB",
        "DBCC OPENTRAN",
        "DBCC LOGINFO",
        "DBCC TRACESTATUS"
      ],
      "correct": 1,
      "explanation": "DBCC OPENTRAN показывает самую старую активную транзакцию и связанную информацию, полезно при расследовании роста журнала и блокировок.",
      "difficulty": "medium"
    },
    {
      "id": 124,
      "question": "Какой режим восстановления чаще всего используется для development/тестовых баз, где точечное восстановление не требуется?",
      "options": [
        "FULL",
        "SIMPLE",
        "BULK_LOGGED",
        "SUSPECT"
      ],
      "correct": 1,
      "explanation": "Режим SIMPLE автоматически усечает журнал транзакций и подходит для окружений, где не нужны лог-бэкапы и point-in-time recovery.",
      "difficulty": "easy"
    },
    {
      "id": 125,
      "question": "Чем режим BULK_LOGGED отличается от FULL при выполнении bulk-операций?",
      "options": [
        "Полностью отключает журналирование",
        "Минимизирует журналирование для некоторых bulk-операций, сохраняя возможность восстановления до точки сбоя",
        "Включает только SIMPLE поведение",
        "Разрешает только операции SELECT"
      ],
      "correct": 1,
      "explanation": "BULK_LOGGED сокращает объём журнала при bulk-операциях (bulk insert, index rebuild и др.), но для восстановления на конкретный момент требуется точное планирование бэкапов.",
      "difficulty": "medium"
    },
    {
      "id": 126,
      "question": "Какой тип бэкапа минимально необходим в режиме FULL для возможности восстановления до определённого момента времени?",
      "options": [
        "Только полный",
        "Полный + цепочка лог-бэкапов",
        "Только дифференциальный",
        "Полный + дифференциальный без логов"
      ],
      "correct": 1,
      "explanation": "Point-in-time recovery в режиме FULL требует полного бэкапа и непрерывной цепочки лог-бэкапов до нужного момента.",
      "difficulty": "easy"
    },
    {
      "id": 127,
      "question": "Как снизить размер журнала транзакций, не потеряв возможность восстановления?",
      "options": [
        "Выполнить TRUNCATE TABLE",
        "Регулярно выполнять лог-бэкапы и при необходимости SHRINKFILE аккуратно",
        "Переустановить SQL Server",
        "Изменить колляцию"
      ],
      "correct": 1,
      "explanation": "Основной способ управления размером журнала – регулярные лог-бэкапы; SHRINKFILE допустим эпизодически, но не как постоянная практика.",
      "difficulty": "medium"
    },
    {
      "id": 128,
      "question": "Что произойдёт, если выполнить BACKUP LOG при режиме восстановления SIMPLE?",
      "options": [
        "Создастся лог-бэкап",
        "Команда завершится ошибкой, так как лог-бэкапы недоступны в SIMPLE",
        "Лог будет автоматически усечён без файла",
        "База перейдёт в FULL"
      ],
      "correct": 1,
      "explanation": "В режиме SIMPLE команда BACKUP LOG не поддерживается и завершится ошибкой, так как лог регулярно усечается автоматически.",
      "difficulty": "easy"
    },
    {
      "id": 129,
      "question": "Какой механизм обеспечения высокой доступности в SQL Server позволяет читать с реплики без задержки восстановления?",
      "options": [
        "Log Shipping",
        "Always On Availability Groups с readable secondary",
        "Mirroring в режиме High Safety",
        "Database Snapshot"
      ],
      "correct": 1,
      "explanation": "AG с разрешённым readable secondary позволяет выполнять read-only нагрузки на вторичных репликах, разгружая основную.",
      "difficulty": "medium"
    },
    {
      "id": 130,
      "question": "Какой основной недостаток Log Shipping по сравнению с Always On AG?",
      "options": [
        "Отсутствие бэкапов",
        "Отсутствие автоматического переключения ролей и возможная задержка применения логов",
        "Отсутствие журнала транзакций",
        "Нельзя использовать вторичную базу для чтения"
      ],
      "correct": 1,
      "explanation": "Log Shipping основан на периодическом копировании и восстановлении логов, не обеспечивает автоматический failover и может иметь значительные задержки.",
      "difficulty": "medium"
    },
    {
      "id": 131,
      "question": "Какая функция возвращает имя текущей базы данных?",
      "options": [
        "DB_NAME()",
        "DB_ID()",
        "SERVERPROPERTY()",
        "CURRENT_DB()"
      ],
      "correct": 0,
      "explanation": "DB_NAME() без аргументов возвращает имя текущей базы; с аргументом – имя по идентификатору базы.",
      "difficulty": "easy"
    },
    {
      "id": 132,
      "question": "Какой системный каталог содержит список всех таблиц пользовательской базы?",
      "options": [
        "sys.columns",
        "sys.tables",
        "sys.indexes",
        "sys.objects только для системных таблиц"
      ],
      "correct": 1,
      "explanation": "sys.tables содержит информацию о пользовательских таблицах; sys.objects – обширнее и включает объекты разных типов.",
      "difficulty": "easy"
    },
    {
      "id": 133,
      "question": "Какой тип блокировок чаще всего возникает при выполнении SELECT в уровне изоляции READ COMMITTED без версионности?",
      "options": [
        "X (Exclusive)",
        "S (Shared)",
        "U (Update)",
        "Sch-M (Schema Modification)"
      ],
      "correct": 1,
      "explanation": "В READ COMMITTED без RCSI SELECT использует разделяемые блокировки S, которые отпускаются по завершении оператора.",
      "difficulty": "medium"
    },
    {
      "id": 134,
      "question": "Чем уровень изоляции REPEATABLE READ отличается от READ COMMITTED?",
      "options": [
        "Разрешает грязные чтения",
        "Гарантирует повторяемость чтения: удерживает S-блокировки до конца транзакции",
        "Отключает блокировки на чтение",
        "Всегда включает версионность"
      ],
      "correct": 1,
      "explanation": "REPEATABLE READ не допускает изменения уже прочитанных строк до конца транзакции, удерживая S-блокировки дольше, чем READ COMMITTED.",
      "difficulty": "medium"
    },
    {
      "id": 135,
      "question": "Какой уровень изоляции предотвращает фантомные чтения без использования версионности?",
      "options": [
        "READ UNCOMMITTED",
        "READ COMMITTED",
        "REPEATABLE READ",
        "SERIALIZABLE"
      ],
      "correct": 3,
      "explanation": "SERIALIZABLE реализует эффект, близкий к сериализации, и предотвращает фантомы за счёт диапазонных блокировок.",
      "difficulty": "hard"
    },
    {
      "id": 136,
      "question": "Какой DMV использовать для анализа текущих блокировок в системе?",
      "options": [
        "sys.dm_tran_locks",
        "sys.dm_exec_sessions",
        "sys.dm_os_wait_stats",
        "sys.dm_io_virtual_file_stats"
      ],
      "correct": 0,
      "explanation": "sys.dm_tran_locks показывает активные блокировки, их владельцев и ресурсы, что полезно при диагностике взаимоблокировок и конкуренции.",
      "difficulty": "medium"
    },
    {
      "id": 137,
      "question": "Какой тип JOIN реализуется при использовании конструкции SELECT ... FROM A, B без условия соединения?",
      "options": [
        "INNER JOIN",
        "FULL JOIN",
        "CROSS JOIN (декартово произведение)",
        "LEFT JOIN"
      ],
      "correct": 2,
      "explanation": "Отсутствие условия соединения приводит к декартову произведению (CROSS JOIN), что обычно ошибка в продакшене.",
      "difficulty": "easy"
    },
    {
      "id": 138,
      "question": "Какой оператор лучше использовать для частичного обновления JSON-документа в NVARCHAR-столбце?",
      "options": [
        "UPDATE с простым присваиванием",
        "JSON_MODIFY",
        "JSON_QUERY",
        "JSON_VALUE"
      ],
      "correct": 1,
      "explanation": "JSON_MODIFY позволяет изменить часть JSON-документа (путь/значение), не переписывая весь текст.",
      "difficulty": "medium"
    },
    {
      "id": 139,
      "question": "Какой тип индекса рекомендуется для колонок, по которым часто выполняется полнотекстовый поиск?",
      "options": [
        "Columnstore индекс",
        "Full-Text индекс",
        "Hash индекс",
        "XML индекс"
      ],
      "correct": 1,
      "explanation": "Полнотекстовый индекс оптимизирован для поисковых выражений CONTAINS/FREETEXT и поддерживает лингвистические особенности.",
      "difficulty": "medium"
    },
    {
      "id": 140,
      "question": "Какой системной функцией можно проверить, включён ли полнотекстовый поиск на сервере?",
      "options": [
        "FULLTEXTSERVICEPROPERTY()",
        "SERVERPROPERTY()",
        "DATABASEPROPERTYEX()",
        "FILEPROPERTY()"
      ],
      "correct": 0,
      "explanation": "FULLTEXTSERVICEPROPERTY позволяет получить сведения о состоянии Full-Text Search (например, 'IsFullTextInstalled').",
      "difficulty": "hard"
    },
    {
      "id": 141,
      "question": "Чем Clustered Columnstore Index (CCI) отличается от некластерного Columnstore индекса?",
      "options": [
        "CCI доступен только в tempdb",
        "CCI делает таблицу хранением по столбцам, некластерный Columnstore – дополнительный индекс поверх строкового хранения",
        "Некластерный Columnstore всегда уникальный",
        "Отличий нет"
      ],
      "correct": 1,
      "explanation": "Кластерный Columnstore определяет формат хранения всей таблицы по столбцам; некластерный – дополнительный индекс для гибридных сценариев OLTP+OLAP.",
      "difficulty": "hard"
    },
    {
      "id": 142,
      "question": "Какой DMV покажет сегменты Columnstore и их статистику (включая min/max значений)?",
      "options": [
        "sys.dm_db_column_store_row_group_physical_stats",
        "sys.dm_db_index_physical_stats",
        "sys.dm_db_partition_stats",
        "sys.dm_db_file_space_usage"
      ],
      "correct": 0,
      "explanation": "sys.dm_db_column_store_row_group_physical_stats даёт информацию о row groups, состоянии сжатия и статистике сегментов Columnstore.",
      "difficulty": "hard"
    },
    {
      "id": 143,
      "question": "Что даёт опция DELAYED_DURABILITY для транзакций?",
      "options": [
        "Гарантирует мгновенную фиксацию в журнале",
        "Позволяет откладывать запись журнала для повышения производительности записью ценой риска потери последних транзакций при сбое",
        "Отключает журнал транзакций",
        "Переводит базу в SIMPLE"
      ],
      "correct": 1,
      "explanation": "Отложенная устойчивость (delayed durability) снижает нагрузку на журнал, но при сбое возможна потеря последних зафиксированных транзакций.",
      "difficulty": "hard"
    },
    {
      "id": 144,
      "question": "Какой DMV помогает исследовать конфликт блокировок по ожидающим задачам?",
      "options": [
        "sys.dm_os_wait_stats",
        "sys.dm_os_waiting_tasks",
        "sys.dm_exec_connections",
        "sys.dm_exec_requests только"
      ],
      "correct": 1,
      "explanation": "sys.dm_os_waiting_tasks показывает, какие задачи ждут, на каких ресурсах и с какими владельцами – полезно для анализа блокировок и ожиданий.",
      "difficulty": "hard"
    },
    {
      "id": 145,
      "question": "Какой тип индекса рекомендуется для поля с высокой кардинальностью, используемого в предикатах равенства и диапазона?",
      "options": [
        "Filtered индекс",
        "Обычный некластерный B-Tree индекс",
        "Hash индекс на диске",
        "Full-Text индекс"
      ],
      "correct": 1,
      "explanation": "Некластерный B-деревянный индекс по столбцу с высокой кардинальностью обеспечивает эффективный поиск по равенству и диапазону.",
      "difficulty": "easy"
    },
    {
      "id": 146,
      "question": "Какое влияние на план может оказать использование функции в предикате WHERE (например, WHERE YEAR(Col) = 2024)?",
      "options": [
        "Ускорит поиск по индексу",
        "Может сделать предикат не-SARGable, приводя к скану вместо seek",
        "Отключит параллелизм",
        "Запретит использование статистик"
      ],
      "correct": 1,
      "explanation": "Функции над индексируемыми столбцами часто делают предикат не-SARGable, лишая оптимизатор возможности использовать эффективный индексный поиск.",
      "difficulty": "medium"
    },
    {
      "id": 147,
      "question": "Какой паттерн предпочтительнее для диапазонных запросов по дате, чтобы сохранить SARGability?",
      "options": [
        "WHERE YEAR(Col) = 2024",
        "WHERE Col >= '2024-01-01' AND Col < '2025-01-01'",
        "WHERE CONVERT(date, Col) = '2024-01-01'",
        "WHERE FORMAT(Col, 'yyyy') = '2024'"
      ],
      "correct": 1,
      "explanation": "Диапазон по исходному столбцу (>= и <) позволяет использовать индексный seek и сохраняет SARGability, в отличие от функций над колонкой.",
      "difficulty": "easy"
    },
    {
      "id": 148,
      "question": "Какой тип индексной статистики используется оптимизатором для оценки кардинальности по одному столбцу?",
      "options": [
        "Гистограмма",
        "Bloom-фильтр",
        "Bitmap индекс",
        "Только среднее значение"
      ],
      "correct": 0,
      "explanation": "Для одномерных статистик оптимизатор использует гистограмму распределения значений, содержащую до 200 шагов.",
      "difficulty": "medium"
    },
    {
      "id": 149,
      "question": "Как можно явно пересобрать статистику по столбцу или индексу?",
      "options": [
        "DBCC CHECKDB",
        "UPDATE STATISTICS имя_таблицы (имя_индекса_или_статистики)",
        "DBCC DROPCLEANBUFFERS",
        "ALTER INDEX ... DISABLE"
      ],
      "correct": 1,
      "explanation": "UPDATE STATISTICS позволяет обновить конкретные статистики по таблице или индексу с нужными опциями выборки.",
      "difficulty": "easy"
    },
    {
      "id": 150,
      "question": "Какой DMV использовать для анализа IO по каждому файлу базы?",
      "options": [
        "sys.dm_io_virtual_file_stats",
        "sys.dm_os_buffer_descriptors",
        "sys.dm_os_wait_stats",
        "sys.dm_db_file_space_usage"
      ],
      "correct": 0,
      "explanation": "sys.dm_io_virtual_file_stats возвращает счётчики чтения/записи по каждому файлу данных/журнала и помогает выявлять узкие места IO.",
      "difficulty": "hard"
    },
    {
      "id": 151,
      "question": "Какой командой можно посмотреть историю последних бэкапов базы данных?",
      "options": [
        "SELECT * FROM msdb.dbo.backupset",
        "SELECT * FROM sys.databases",
        "DBCC CHECKDB",
        "DBCC LOGINFO"
      ],
      "correct": 0,
      "explanation": "Таблица msdb.dbo.backupset хранит информацию обо всех выполненных бэкапах баз данных, включая тип, дату и размер.",
      "difficulty": "medium"
    },
    {
      "id": 152,
      "question": "Какой тип объекта использовать для асинхронной фоновой обработки задач внутри SQL Server без внешнего брокера сообщений?",
      "options": [
        "SQL Agent Job",
        "Service Broker Queue",
        "Database Mail",
        "Extended Events"
      ],
      "correct": 1,
      "explanation": "Service Broker предоставляет надёжные очереди и диалоги внутри SQL Server, позволяя строить асинхронные процессы.",
      "difficulty": "hard"
    },
    {
      "id": 153,
      "question": "Какой механизм SQL Server позволяет ограничить максимальное время выполнения запроса?",
      "options": [
        "SET QUERY_TIMEOUT",
        "REMOTE QUERY TIMEOUT только",
        "Параметр timeout на уровне клиента или команды (например, CommandTimeout)",
        "DBCC TIMEOUT"
      ],
      "correct": 2,
      "explanation": "Ограничение времени выполнения запроса задаётся, как правило, на клиенте (CommandTimeout, QueryTimeout), а не внутри самого SQL Server для T-SQL.",
      "difficulty": "medium"
    },
    {
      "id": 154,
      "question": "Какой DMV использовать для анализа использования буферного пула страницами данных?",
      "options": [
        "sys.dm_os_buffer_descriptors",
        "sys.dm_os_wait_stats",
        "sys.dm_exec_sessions",
        "sys.dm_io_virtual_file_stats"
      ],
      "correct": 0,
      "explanation": "sys.dm_os_buffer_descriptors показывает, какие страницы каких баз и объектов находятся в буферном пуле.",
      "difficulty": "hard"
    },
    {
      "id": 155,
      "question": "Какой механизм аутентификации позволяет использовать AD-учётные записи и группы в SQL Server?",
      "options": [
        "SQL Server Authentication",
        "Windows Authentication",
        "Mixed Mode без Windows",
        "Contained Users"
      ],
      "correct": 1,
      "explanation": "Windows Authentication позволяет использовать доменные и локальные учётные записи/группы для доступа к SQL Server.",
      "difficulty": "easy"
    },
    {
      "id": 156,
      "question": "Что такое login и user в контексте безопасности SQL Server?",
      "options": [
        "Синонимы",
        "Login – объект сервера, user – объект базы данных",
        "Login – всегда sysadmin, user – гость",
        "User существует только в master"
      ],
      "correct": 1,
      "explanation": "Login – сущность уровня сервера, дающая доступ к инстансу; user – сущность уровня базы, сопоставленная логину.",
      "difficulty": "easy"
    },
    {
      "id": 157,
      "question": "Какой минимальный набор прав нужен, чтобы пользователь мог выполнять только SELECT в конкретной базе?",
      "options": [
        "Роль db_owner",
        "Роль db_datareader",
        "Роль db_ddladmin",
        "Роль securityadmin"
      ],
      "correct": 1,
      "explanation": "Роль db_datareader предоставляет права на SELECT для всех таблиц и представлений базы, не давая прав на изменение схемы.",
      "difficulty": "easy"
    },
    {
      "id": 158,
      "question": "Какой встроенный механизм позволяет зашифровать соединение между клиентом и SQL Server?",
      "options": [
        "TDE",
        "SSL/TLS с использованием сертификата сервера",
        "Always Encrypted",
        "RLS"
      ],
      "correct": 1,
      "explanation": "Шифрование трафика достигается настройкой SSL/TLS на уровне протокола, используя сертификат сервера и параметры клиента (Encrypt, TrustServerCertificate и т.п.).",
      "difficulty": "medium"
    },
    {
      "id": 159,
      "question": "Как получить план выполнения без фактического запуска запроса?",
      "options": [
        "SET SHOWPLAN_TEXT/SET SHOWPLAN_XML ON",
        "SET STATISTICS IO ON",
        "SET NOCOUNT ON",
        "SET TRANSACTION ISOLATION LEVEL SNAPSHOT"
      ],
      "correct": 0,
      "explanation": "Режимы SHOWPLAN_* возвращают план выполнения вместо реального выполнения запроса.",
      "difficulty": "medium"
    },
    {
      "id": 160,
      "question": "Что делает SET STATISTICS IO ON?",
      "options": [
        "Показывает логические и физические чтения по объектам",
        "Показывает только CPU время",
        "Включает план выполнения",
        "Сохраняет план в Query Store"
      ],
      "correct": 0,
      "explanation": "STATISTICS IO выводит в сообщения количество логических/физических чтений и сканов для каждой операции.",
      "difficulty": "easy"
    },
    {
      "id": 161,
      "question": "Какой оператор использовать для выборки TOP N строк с детерминированным порядком?",
      "options": [
        "SELECT TOP N * FROM T",
        "SELECT TOP N * FROM T ORDER BY ...",
        "SELECT * FROM T OFFSET 0 ROWS",
        "SELECT DISTINCT TOP N * FROM T"
      ],
      "correct": 1,
      "explanation": "TOP без ORDER BY не гарантирует порядок; детерминизм достигается указанием ORDER BY вместе с TOP.",
      "difficulty": "easy"
    },
    {
      "id": 162,
      "question": "Какой оператор лучше использовать для постраничной выборки (paging) в современных версиях SQL Server?",
      "options": [
        "TOP + NOT IN",
        "ROW_NUMBER() OVER(...) с внешним фильтром",
        "ORDER BY ... OFFSET ... FETCH NEXT ...",
        "CROSS APPLY"
      ],
      "correct": 2,
      "explanation": "OFFSET/FETCH – стандартный способ постраничной выборки в T-SQL, поддерживаемый оптимизатором и читаемый в коде.",
      "difficulty": "medium"
    },
    {
      "id": 163,
      "question": "Чем оконная функция SUM() OVER(PARTITION BY ...) отличается от агрегатной SUM()?",
      "options": [
        "Не поддерживает PARTITION",
        "Оконная не сворачивает строки, а добавляет значение поверх каждой строки раздела",
        "Агрегатная быстрее",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "Оконные функции вычисляют агрегаты по окну/разделу, сохраняя детализацию строк, в отличие от агрегатных функций в GROUP BY.",
      "difficulty": "medium"
    },
    {
      "id": 164,
      "question": "Какая оконная функция удобна для поиска предыдущего значения в рамках отсортированного набора?",
      "options": [
        "ROW_NUMBER()",
        "LAG()",
        "LEAD()",
        "FIRST_VALUE()"
      ],
      "correct": 1,
      "explanation": "LAG возвращает значение из предыдущей строки в рамках заданного порядка, LEAD – из следующей.",
      "difficulty": "medium"
    },
    {
      "id": 165,
      "question": "Какую проблему может вызвать скалярная пользовательская функция в SELECT списке или WHERE?",
      "options": [
        "Всегда приводит к ошибке компиляции",
        "Выполняется построчно и может сильно замедлить запрос, пряча план от оптимизатора",
        "Отключает индексы",
        "Запрещает параллелизм на уровне сервера"
      ],
      "correct": 1,
      "explanation": "Скалярные UDF долгое время выполнялись построчно и не встраивались в план, из-за чего производительность могла резко падать.",
      "difficulty": "hard"
    },
    {
      "id": 166,
      "question": "Какой объект использовать для хранения многострочных бизнес-правил, которые должны выполняться транзакционно на сервере?",
      "options": [
        "VIEW",
        "Хранимая процедура",
        "Скалярная функция",
        "Extended Event"
      ],
      "correct": 1,
      "explanation": "Хранимые процедуры хорошо подходят для инкапсуляции бизнес-логики, управления транзакциями и правами.",
      "difficulty": "easy"
    },
    {
      "id": 167,
      "question": "Какой системный каталог содержит определения хранимых процедур и функций?",
      "options": [
        "sys.procedures и sys.objects",
        "sys.tables",
        "sys.columns",
        "sys.dm_exec_procedure_stats"
      ],
      "correct": 0,
      "explanation": "sys.procedures и sys.objects хранят метаданные о процедурах и других объектах, включая имя, схему и тип.",
      "difficulty": "easy"
    },
    {
      "id": 168,
      "question": "Какой DMV использовать, чтобы увидеть статистику по выполнению хранимых процедур (CPU, чтения, количество запусков)?",
      "options": [
        "sys.dm_exec_query_stats",
        "sys.dm_exec_procedure_stats",
        "sys.dm_exec_requests",
        "sys.dm_os_tasks"
      ],
      "correct": 1,
      "explanation": "sys.dm_exec_procedure_stats агрегирует статистику выполнения по хранимым процедурам.",
      "difficulty": "medium"
    },
    {
      "id": 169,
      "question": "Для чего используется параметр MAXRECURSION в рекурсивных CTE?",
      "options": [
        "Для ограничения глубины рекурсии и предотвращения бесконечных циклов",
        "Для включения параллелизма",
        "Для включения версионности",
        "Для обновления статистик"
      ],
      "correct": 0,
      "explanation": "OPTION (MAXRECURSION N) ограничивает количество итераций рекурсивного CTE, защищая от бесконечных рекурсий.",
      "difficulty": "medium"
    },
    {
      "id": 170,
      "question": "Что такое deadlock priority и как её можно установить?",
      "options": [
        "Глобальный приоритет сервера, изменяемый только через sp_configure",
        "Приоритет сессии при взаимоблокировке, задаётся командой SET DEADLOCK_PRIORITY",
        "Приоритет транзакций в журнале",
        "Приоритет плана выполнения"
      ],
      "correct": 1,
      "explanation": "SET DEADLOCK_PRIORITY LOW/NORMAL/HIGH или числом позволяет указать, какую сессию жертвовать при взаимоблокировке.",
      "difficulty": "hard"
    },
    {
      "id": 171,
      "question": "Какой тип индекса используется для ускорения поиска по XML-столбцам?",
      "options": [
        "Primary XML index",
        "Columnstore index",
        "Full-Text index",
        "Hash index"
      ],
      "correct": 0,
      "explanation": "Primary XML index шредит XML-документ во внутренние таблицы, ускоряя запросы XQuery по XML-столбцу.",
      "difficulty": "hard"
    },
    {
      "id": 172,
      "question": "Какой тип хинта соединения может быть полезен при чётком понимании, что Nested Loops неэффективен на больших наборах?",
      "options": [
        "OPTION (LOOP JOIN)",
        "OPTION (HASH JOIN)",
        "OPTION (MERGE JOIN)",
        "OPTION (FORCE ORDER)"
      ],
      "correct": 1,
      "explanation": "HASH JOIN может быть предпочтителен для больших неотсортированных наборов, хотя хинты нужно использовать осторожно и точечно.",
      "difficulty": "hard"
    },
    {
      "id": 173,
      "question": "Что делает хинт OPTION (FORCE ORDER)?",
      "options": [
        "Запрещает параллелизм",
        "Заставляет оптимизатор использовать порядок соединений, указанный в запросе",
        "Отключает индексы",
        "Включает FULL SCAN всех таблиц"
      ],
      "correct": 1,
      "explanation": "FORCE ORDER фиксирует порядок join'ов, указанный в FROM, ограничивая свободу оптимизатора по перестановке таблиц.",
      "difficulty": "hard"
    },
    {
      "id": 174,
      "question": "Какой тип объекта использовать для централизованного хранения конфигурационных параметров (ключ-значение) внутри базы?",
      "options": [
        "Service Broker",
        "Таблица настроек (Config table)",
        "Extended Events",
        "Full-Text индекс"
      ],
      "correct": 1,
      "explanation": "Чаще всего для конфигурации используется простая таблица настроек, доступная из процедур и запросов.",
      "difficulty": "easy"
    },
    {
      "id": 175,
      "question": "Какой DMV поможет увидеть текущие значения параметров сервера (sp_configure)?",
      "options": [
        "sys.configurations",
        "sys.dm_os_sys_info",
        "sys.dm_server_services",
        "sys.dm_exec_sessions"
      ],
      "correct": 0,
      "explanation": "sys.configurations показывает параметры, доступные через sp_configure, их значения и статус (вступили ли в силу).",
      "difficulty": "easy"
    },
    {
      "id": 176,
      "question": "Что делает опция ARITHABORT ON?",
      "options": [
        "Игнорирует деление на ноль",
        "Прерывает запрос при арифметических ошибках (деление на ноль, переполнение)",
        "Отключает проверки CHECK",
        "Включает параллелизм"
      ],
      "correct": 1,
      "explanation": "ARITHABORT ON заставляет SQL Server прерывать запрос при арифметических ошибках, что также влияет на кэширование планов.",
      "difficulty": "hard"
    },
    {
      "id": 177,
      "question": "Какой системной функцией можно узнать версию SQL Server?",
      "options": [
        "@@VERSION",
        "SERVERPROPERTY('Edition')",
        "DB_NAME()",
        "@@LANGUAGE"
      ],
      "correct": 0,
      "explanation": "@@VERSION возвращает строку с номером версии, редакцией и информацией о сборке SQL Server.",
      "difficulty": "easy"
    },
    {
      "id": 178,
      "question": "Какой параметр базы данных отвечает за автоматическое создание статистик по отдельным столбцам в предикатах?",
      "options": [
        "AUTO_UPDATE_STATISTICS",
        "AUTO_CREATE_STATISTICS",
        "AUTO_SHRINK",
        "AUTO_CLOSE"
      ],
      "correct": 1,
      "explanation": "AUTO_CREATE_STATISTICS создаёт статистики по столбцам, используемым в предикатах, если явные статистики отсутствуют.",
      "difficulty": "easy"
    },
    {
      "id": 179,
      "question": "Какой DMV использовать для анализа использования индексов (сколько раз использовались, сколько сканов/seek)?",
      "options": [
        "sys.dm_db_index_usage_stats",
        "sys.dm_db_index_physical_stats",
        "sys.dm_exec_query_stats",
        "sys.dm_db_partition_stats"
      ],
      "correct": 0,
      "explanation": "sys.dm_db_index_usage_stats показывает статистику использования индексов: seeks, scans, lookups, updates.",
      "difficulty": "medium"
    },
    {
      "id": 180,
      "question": "Какой DMV использовать для анализа физического состояния индексов (фрагментация, плотность страниц)?",
      "options": [
        "sys.dm_db_index_usage_stats",
        "sys.dm_db_index_physical_stats",
        "sys.dm_db_partition_stats",
        "sys.dm_io_virtual_file_stats"
      ],
      "correct": 1,
      "explanation": "sys.dm_db_index_physical_stats возвращает фрагментацию и другие физические характеристики индексов, что помогает планировать REBUILD/REORGANIZE.",
      "difficulty": "medium"
    },
    {
      "id": 181,
      "question": "Какой механизм SQL Server позволяет подписчикам самостоятельно инициировать синхронизацию изменений?",
      "options": [
        "Снимковая репликация",
        "Транзакционная репликация",
        "Репликация слиянием (Merge)",
        "Log Shipping"
      ],
      "correct": 2,
      "explanation": "Репликация слиянием позволяет подписчикам вносить изменения и синхронизировать их с издателем, разрешая конфликты.",
      "difficulty": "hard"
    },
    {
      "id": 182,
      "question": "Какой режим базы данных необходим, чтобы включить CDC?",
      "options": [
        "READ_ONLY",
        "FULL или BULK_LOGGED",
        "SIMPLE обязательно",
        "Любой, режим восстановления не важен"
      ],
      "correct": 1,
      "explanation": "CDC официально поддерживается для баз в режимах FULL и BULK_LOGGED, так как использует журнал транзакций.",
      "difficulty": "hard"
    },
    {
      "id": 183,
      "question": "Какой механизм позволяет ограничить доступ к данным на уровне колонки?",
      "options": [
        "RLS",
        "Column-Level Permissions (GRANT SELECT(col) ...)",
        "Always Encrypted",
        "TDE"
      ],
      "correct": 1,
      "explanation": "SQL Server поддерживает права на уровне столбцов (GRANT SELECT(col1, col2)), что позволяет ограничивать проекцию данных для пользователей.",
      "difficulty": "medium"
    },
    {
      "id": 184,
      "question": "Какой механизм позволяет хранить секреты шифрования Always Encrypted вне SQL Server?",
      "options": [
        "Database Master Key",
        "Column Master Key в внешнем хранилище (например, Azure Key Vault, Windows Certificate Store)",
        "TDE Key",
        "Service Master Key"
      ],
      "correct": 1,
      "explanation": "Always Encrypted использует Column Master Key, который может храниться во внешнем доверенном хранилище (сертификаты, HSM, Azure Key Vault).",
      "difficulty": "hard"
    },
    {
      "id": 185,
      "question": "Какой механизм хранения позволяет таблицам In-Memory OLTP обеспечивать устойчивость к сбоям?",
      "options": [
        "SCHEMA_ONLY таблицы",
        "SCHEMA_AND_DATA таблицы с журналированием в обычный лог",
        "tempdb",
        "Встроенный Redis"
      ],
      "correct": 1,
      "explanation": "SCHEMA_AND_DATA memory-optimized таблицы журналируются и восстанавливаются при рестарте сервера, обеспечивая durability.",
      "difficulty": "hard"
    },
    {
      "id": 186,
      "question": "Какой лимит по количеству файлов данных в группе файлов рекомендуется для tempdb в большинстве сценариев?",
      "options": [
        "1 файл всегда",
        "Столько, сколько логических ядер (до определённого предела)",
        "Файлов быть не должно",
        "Только 2 файла"
      ],
      "correct": 1,
      "explanation": "Рекомендация – начинать с количества файлов tempdb, равного числу логических ядер до 8, далее увеличивать по необходимости из-за contention.",
      "difficulty": "hard"
    },
    {
      "id": 187,
      "question": "Какой параметр базы может предотвратить автоматическое закрытие соединения и освобождение ресурсов после последнего пользователя?",
      "options": [
        "AUTO_CLOSE = OFF",
        "AUTO_SHRINK = OFF",
        "AUTO_CREATE_STATISTICS = OFF",
        "PAGE_VERIFY = CHECKSUM"
      ],
      "correct": 0,
      "explanation": "AUTO_CLOSE должен быть OFF для производственных баз; при ON база закрывается после последнего соединения, что вызывает накладные расходы.",
      "difficulty": "medium"
    },
    {
      "id": 188,
      "question": "Какой режим проверки страниц данных рекомендуется для обнаружения повреждений?",
      "options": [
        "PAGE_VERIFY = NONE",
        "PAGE_VERIFY = TORN_PAGE_DETECTION",
        "PAGE_VERIFY = CHECKSUM",
        "PAGE_VERIFY = HASH"
      ],
      "correct": 2,
      "explanation": "PAGE_VERIFY = CHECKSUM обеспечивает наилучшее обнаружение повреждений страниц за счёт хранения контрольной суммы.",
      "difficulty": "medium"
    },
    {
      "id": 189,
      "question": "Какой DMV использовать, чтобы увидеть активные Extended Events сессии?",
      "options": [
        "sys.dm_xe_sessions",
        "sys.dm_xe_objects",
        "sys.dm_exec_sessions",
        "sys.dm_os_wait_stats"
      ],
      "correct": 0,
      "explanation": "sys.dm_xe_sessions отображает активные сессии Extended Events и их параметры.",
      "difficulty": "hard"
    },
    {
      "id": 190,
      "question": "Какой механизм позволит собрать короткие блокировки и deadlock'и без использования Profiler?",
      "options": [
        "Extended Events",
        "Database Mail",
        "Service Broker",
        "SQL Trace"
      ],
      "correct": 0,
      "explanation": "Extended Events – рекомендуемый механизм для сбора событий, включая deadlock_graph и lock_* события.",
      "difficulty": "medium"
    },
    {
      "id": 191,
      "question": "Какой тип временных таблиц виден только внутри одной сессии и удаляется при её завершении?",
      "options": [
        "Локальная временная таблица (#temp)",
        "Глобальная временная таблица (##temp)",
        "Табличная переменная (@t)",
        "Таблица в tempdb"
      ],
      "correct": 0,
      "explanation": "Локальные временные таблицы с префиксом # видны только в текущей сессии и удаляются при её завершении.",
      "difficulty": "easy"
    },
    {
      "id": 192,
      "question": "Какой тип временных таблиц доступен из нескольких сессий одновременно до её явного удаления?",
      "options": [
        "Локальная временная таблица (#temp)",
        "Глобальная временная таблица (##temp)",
        "Табличная переменная (@t)",
        "Обычная таблица в tempdb"
      ],
      "correct": 1,
      "explanation": "Глобальные временные таблицы ##temp видимы для всех сессий, пока существует хотя бы одно соединение, их использующее.",
      "difficulty": "medium"
    },
    {
      "id": 193,
      "question": "Чем табличная переменная (@t) отличается от временной таблицы (#t) с точки зрения транзакций?",
      "options": [
        "@t не участвует в транзакциях и откате",
        "@t также подчиняется транзакциям, но имеет особенности статистик и оценки кардинальности",
        "#t не участвует в транзакциях",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "Табличные переменные логически участвуют в транзакциях, однако оптимизатор их оценивает иначе (часто фиксированное низкое количество строк).",
      "difficulty": "hard"
    },
    {
      "id": 194,
      "question": "Что такое implicit transaction (SET IMPLICIT_TRANSACTIONS ON)?",
      "options": [
        "Каждый оператор выполняется вне транзакции",
        "Каждый DML/DDL оператор автоматически открывает транзакцию, требующую явного COMMIT/ROLLBACK",
        "Транзакции отключаются",
        "Только SELECT выполняются в транзакции"
      ],
      "correct": 1,
      "explanation": "При IMPLICIT_TRANSACTIONS ON SQL Server автоматически начинает транзакцию для ряда операторов; разработчик обязан явно её завершить.",
      "difficulty": "hard"
    },
    {
      "id": 195,
      "question": "Какой тип индекса может быть полезен для ускорения запросов с условием WHERE IsDeleted = 0?",
      "options": [
        "Полнотекстовый индекс",
        "Фильтрованный индекс по IsDeleted = 0",
        "Hash индекс",
        "XML индекс"
      ],
      "correct": 1,
      "explanation": "Фильтрованный индекс по активным строкам уменьшает размер и ускоряет запросы, регулярно использующие одно и то же условие фильтра.",
      "difficulty": "medium"
    },
    {
      "id": 196,
      "question": "Какой тип блокировок захватывается при выполнении операции UPDATE без индексов по условию?",
      "options": [
        "Только X на таблицу",
        "Часто требуется скан таблицы с S/U/X блокировками на страницы/строки и возможной эскалацией до таблицы",
        "Только S-блокировки",
        "Блокировки не используются"
      ],
      "correct": 1,
      "explanation": "Отсутствие подходящего индекса вынуждает двигатель сканировать много строк/страниц, захватывая блокировки и повышая риск эскалации.",
      "difficulty": "hard"
    },
    {
      "id": 197,
      "question": "Какой параметр Query Store отвечает за режим работы (READ_WRITE/READ_ONLY/OFF)?",
      "options": [
        "OPERATION_MODE",
        "DATA_FLUSH_INTERVAL_SECONDS",
        "MAX_STORAGE_SIZE_MB",
        "INTERVAL_LENGTH_MINUTES"
      ],
      "correct": 0,
      "explanation": "OPERATION_MODE определяет, собирает ли Query Store новые данные (READ_WRITE), доступен только для чтения или отключён.",
      "difficulty": "hard"
    },
    {
      "id": 198,
      "question": "Какой DMV использовать для просмотра содержимого Query Store (агрегированной статистики запросов)?",
      "options": [
        "sys.query_store_query_stats",
        "sys.dm_exec_query_stats",
        "sys.dm_exec_requests",
        "sys.dm_os_wait_stats"
      ],
      "correct": 0,
      "explanation": "Семейство представлений sys.query_store_* (query, plan, runtime_stats) содержит данные Query Store; query_stats даёт агрегированные показатели.",
      "difficulty": "hard"
    },
    {
      "id": 199,
      "question": "Какой тип объекта использовать для создания серверного триггера на вход пользователя (логон)?",
      "options": [
        "DDL триггер на уровне базы",
        "LOGON триггер на уровне сервера",
        "DML триггер",
        "Extended Event"
      ],
      "correct": 1,
      "explanation": "LOGON триггеры создаются на уровне сервера и срабатывают при установке соединения, позволяя реализовать дополнительные проверки.",
      "difficulty": "hard"
    },
    {
      "id": 200,
      "question": "Какой механизм позволяет изолировать базу данных от серверных настроек колляции и логинов?",
      "options": [
        "Contained Database",
        "TempDB",
        "Always On AG",
        "Log Shipping"
      ],
      "correct": 0,
      "explanation": "Contained database позволяет хранить пользователей и некоторые настройки внутри самой базы, упрощая перенос между серверами.",
      "difficulty": "hard"
    },
    {
      "id": 201,
      "question": "Какой системный каталог содержит информацию о колляции базы данных?",
      "options": [
        "sys.databases",
        "sys.database_files",
        "sys.collations",
        "sys.objects"
      ],
      "correct": 0,
      "explanation": "sys.databases содержит столбец collation_name для каждой базы, задающий колляцию по умолчанию.",
      "difficulty": "easy"
    },
    {
      "id": 202,
      "question": "Какой тип индекса лучше использовать для столбца с низкой кардинальностью (например, Status), который часто используется в фильтрах совместно с другими столбцами?",
      "options": [
        "Отдельный некластерный индекс только по Status",
        "Составной индекс, в котором Status не первый в ключе, либо фильтрованный индекс",
        "Всегда кластерный индекс на Status",
        "Только Columnstore"
      ],
      "correct": 1,
      "explanation": "При низкой кардинальности лучше включать такой столбец в составной индекс или использовать фильтрованный индекс, избегая отдельного индекса только по нему.",
      "difficulty": "medium"
    },
    {
      "id": 203,
      "question": "Что такое bookmark lookup (key lookup) в плане выполнения?",
      "options": [
        "Поиск по GUID",
        "Обращение от некластерного индекса к кластерному индексу/heap за недостающими столбцами",
        "Скан по журналу",
        "Поиск по tempdb"
      ],
      "correct": 1,
      "explanation": "Key lookup – операция, при которой по ключу некластерного индекса ищутся дополнительные столбцы в кластерном индексе или heap.",
      "difficulty": "medium"
    },
    {
      "id": 204,
      "question": "Как можно уменьшить количество key lookup операций в часто выполняемом запросе?",
      "options": [
        "Отключить кластерный индекс",
        "Добавить недостающие столбцы в INCLUDE некластерного индекса или изменить покрытие индекса",
        "Перевести базу в SIMPLE",
        "Отключить параллелизм"
      ],
      "correct": 1,
      "explanation": "Покрывающий индекс с INCLUDE столбцами позволяет получить все нужные данные из индекса без дополнительных обращений к таблице.",
      "difficulty": "medium"
    },
    {
      "id": 205,
      "question": "Какой DMV использовать, чтобы увидеть, когда последний раз очищался план-кэш?",
      "options": [
        "sys.dm_os_sys_info",
        "sys.dm_os_memory_clerks",
        "sys.dm_os_performance_counters",
        "sys.dm_os_process_memory"
      ],
      "correct": 0,
      "explanation": "sys.dm_os_sys_info содержит поле sqlserver_start_time и косвенно помогает понять время старта инстанса и сброса кэшей.",
      "difficulty": "hard"
    },
    {
      "id": 206,
      "question": "Какой параметр sp_configure влияет на размер буферного пула?",
      "options": [
        "max server memory",
        "min server memory",
        "cost threshold for parallelism",
        "max degree of parallelism"
      ],
      "correct": 0,
      "explanation": "max server memory ограничивает общий объём памяти, который SQL Server может использовать, основную часть которого занимает буферный пул.",
      "difficulty": "medium"
    },
    {
      "id": 207,
      "question": "Какой механизм сжатия можно включить на уровне индекса или таблицы для экономии места?",
      "options": [
        "BACKUP COMPRESSION",
        "ROW/PAGE COMPRESSION",
        "TDE",
        "JSON COMPRESSION"
      ],
      "correct": 1,
      "explanation": "ROW и PAGE compression включаются через ALTER INDEX/ALTER TABLE и уменьшают объём данных на страницах.",
      "difficulty": "medium"
    },
    {
      "id": 208,
      "question": "Какой тип backup используется для уменьшения размера бэкапов, выполняя сжатие данных?",
      "options": [
        "DIFFERENTIAL",
        "BACKUP ... WITH COMPRESSION",
        "COPY_ONLY",
        "FILEGROUP backup"
      ],
      "correct": 1,
      "explanation": "WITH COMPRESSION можно добавить к любому типу бэкапа, чтобы уменьшить его размер за счёт сжатия.",
      "difficulty": "easy"
    },
    {
      "id": 209,
      "question": "Что такое COPY_ONLY backup?",
      "options": [
        "Бэкап, который не влияет на цепочку обычных бэкапов",
        "Бэкап только журнала",
        "Бэкап только файловой группы",
        "Бэкап только master"
      ],
      "correct": 0,
      "explanation": "COPY_ONLY выполняет независимый бэкап, не меняя базовую линию для дифференциальных и лог-бэкапов.",
      "difficulty": "medium"
    },
    {
      "id": 210,
      "question": "Какой тип backup нужен, чтобы можно было восстановить отдельную файловую группу?",
      "options": [
        "FILEGROUP backup",
        "DIFFERENTIAL",
        "ONLY LOG",
        "COPY_ONLY"
      ],
      "correct": 0,
      "explanation": "Резервное копирование файловых групп позволяет восстанавливать отдельные части базы, особенно в больших партиционированных базах.",
      "difficulty": "hard"
    },
    {
      "id": 211,
      "question": "Какой оператор T-SQL используется для создания новой схемы (schema) в базе?",
      "options": [
        "CREATE ROLE",
        "CREATE SCHEMA",
        "CREATE LOGIN",
        "CREATE USER"
      ],
      "correct": 1,
      "explanation": "CREATE SCHEMA создаёт новую схему, логически группирующую объекты (таблицы, представления и т.п.) внутри базы.",
      "difficulty": "easy"
    },
    {
      "id": 212,
      "question": "Как перенести таблицу из схемы dbo в схему sales?",
      "options": [
        "ALTER TABLE dbo.T SWITCH TO sales.T",
        "ALTER SCHEMA sales TRANSFER dbo.T",
        "CREATE TABLE sales.T AS SELECT * FROM dbo.T",
        "ALTER DATABASE TRANSFER dbo.T TO sales"
      ],
      "correct": 1,
      "explanation": "ALTER SCHEMA ... TRANSFER позволяет сменить схему объекта без его физического копирования.",
      "difficulty": "medium"
    },
    {
      "id": 213,
      "question": "Какой тип constraint использовать для ограничения значения столбца по условию (например, Amount >= 0)?",
      "options": [
        "DEFAULT",
        "CHECK",
        "FOREIGN KEY",
        "PRIMARY KEY"
      ],
      "correct": 1,
      "explanation": "CHECK constraint позволяет задать логическое условие, которому должны соответствовать значения столбца или выражения.",
      "difficulty": "easy"
    },
    {
      "id": 214,
      "question": "Какой параметр транзакции нужен для обеспечения атомарности нескольких операций вставки/обновления?",
      "options": [
        "SET NOCOUNT ON",
        "BEGIN TRAN ... COMMIT/ROLLBACK",
        "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED",
        "SET IMPLICIT_TRANSACTIONS OFF"
      ],
      "correct": 1,
      "explanation": "Использование явных транзакций BEGIN TRAN ... COMMIT/ROLLBACK гарантирует атомарность группы изменений.",
      "difficulty": "easy"
    },
    {
      "id": 215,
      "question": "Какой системный объект использовать для планирования периодического задания в SQL Server?",
      "options": [
        "SQL Server Agent Job",
        "Service Broker",
        "Extended Events",
        "Database Mail"
      ],
      "correct": 0,
      "explanation": "SQL Server Agent Jobs позволяют запускать T-SQL, SSIS, PowerShell и другие действия по расписанию.",
      "difficulty": "easy"
    },
    {
      "id": 216,
      "question": "Какой тип курсора наиболее эффективен, если всё-таки приходится использовать курсор?",
      "options": [
        "STATIC",
        "FAST_FORWARD",
        "SCROLL",
        "KEYSET"
      ],
      "correct": 1,
      "explanation": "FAST_FORWARD сочетает FORWARD_ONLY и READ_ONLY, обычно даёт наименьшие накладные расходы при использовании курсоров.",
      "difficulty": "hard"
    },
    {
      "id": 217,
      "question": "Какой оператор использовать для объединения результатов двух запросов без удаления дубликатов?",
      "options": [
        "UNION",
        "UNION ALL",
        "INTERSECT",
        "EXCEPT"
      ],
      "correct": 1,
      "explanation": "UNION ALL не выполняет удаление дубликатов и работает быстрее, если дубликаты допустимы.",
      "difficulty": "easy"
    },
    {
      "id": 218,
      "question": "Какой оператор вернуть пересечение множества строк двух запросов?",
      "options": [
        "UNION",
        "UNION ALL",
        "INTERSECT",
        "EXCEPT"
      ],
      "correct": 2,
      "explanation": "INTERSECT возвращает только те строки, которые присутствуют в обоих наборах.",
      "difficulty": "medium"
    },
    {
      "id": 219,
      "question": "Какой оператор вернуть строки из первого набора, отсутствующие во втором?",
      "options": [
        "UNION",
        "UNION ALL",
        "INTERSECT",
        "EXCEPT"
      ],
      "correct": 3,
      "explanation": "EXCEPT возвращает разность множеств: строки, которые есть в первом запросе и отсутствуют во втором.",
      "difficulty": "medium"
    },
    {
      "id": 220,
      "question": "Что такое cardinality estimator (CE) в SQL Server?",
      "options": [
        "Алгоритм компрессии данных",
        "Компонент оптимизатора, оценивающий количество строк для операторов плана",
        "Модуль бэкапа",
        "Механизм журналирования"
      ],
      "correct": 1,
      "explanation": "CE отвечает за оценку кардинальности промежуточных результатов, влияя на выбор операторов и их порядок.",
      "difficulty": "hard"
    },
    {
      "id": 221,
      "question": "Какой уровень совместимости базы данных влияет на версию кардинального оценщика по умолчанию?",
      "options": [
        "Compatibility Level (ALTER DATABASE ... SET COMPATIBILITY_LEVEL)",
        "Recovery Model",
        "Containment",
        "Collation"
      ],
      "correct": 0,
      "explanation": "Уровень совместимости базы определяет, какая версия CE используется по умолчанию, если не переопределена хинтом.",
      "difficulty": "hard"
    },
    {
      "id": 222,
      "question": "Какой механизм позволяет временно заблокировать логин при множественных неудачных попытках входа?",
      "options": [
        "Policy-based Management",
        "Windows Account Lockout Policies при Windows Authentication",
        "RLS",
        "Always Encrypted"
      ],
      "correct": 1,
      "explanation": "При использовании Windows Authentication политики блокировки учётных записей настраиваются на уровне домена/Windows.",
      "difficulty": "medium"
    },
    {
      "id": 223,
      "question": "Какой DMV использовать для просмотра всех открытых соединений к инстансу?",
      "options": [
        "sys.dm_exec_connections",
        "sys.dm_exec_sessions",
        "sys.dm_exec_requests",
        "sys.dm_tran_locks"
      ],
      "correct": 0,
      "explanation": "sys.dm_exec_connections содержит сведения о сетевых соединениях, включая адреса, протоколы и параметры шифрования.",
      "difficulty": "easy"
    },
    {
      "id": 224,
      "question": "Какой DMV использовать для просмотра пользователей/сессий, подключённых к серверу?",
      "options": [
        "sys.dm_exec_connections",
        "sys.dm_exec_sessions",
        "sys.dm_exec_requests",
        "sys.dm_tran_locks"
      ],
      "correct": 1,
      "explanation": "sys.dm_exec_sessions показывает активные и некоторые спящие сессии, их логины, базы, состояние и настройки.",
      "difficulty": "easy"
    },
    {
      "id": 225,
      "question": "Какой DMV использовать для просмотра текущих выполняющихся запросов?",
      "options": [
        "sys.dm_exec_requests",
        "sys.dm_exec_sessions",
        "sys.dm_exec_connections",
        "sys.dm_os_wait_stats"
      ],
      "correct": 0,
      "explanation": "sys.dm_exec_requests показывает активные запросы, ресурсные ожидания и контекст выполнения.",
      "difficulty": "easy"
    },
    {
      "id": 226,
      "question": "Какой тип статистики можно создать вручную по выражению, а не по отдельному столбцу?",
      "options": [
        "Filtered statistics",
        "Computed column statistics или statistics on expression",
        "Only auto statistics",
        "XML statistics"
      ],
      "correct": 1,
      "explanation": "Можно создать вычисляемый столбец или явно статистику по выражению, что улучшит оценки кардинальности сложных предикатов.",
      "difficulty": "hard"
    },
    {
      "id": 227,
      "question": "Что такое parameter embedding optimization (параметризация на стороне оптимизатора)?",
      "options": [
        "Всегда приводит к параметрическому запаху",
        "Возможность оптимизатора внутри Query Store использовать фиктивные значения вместо параметров при оценке кардинальности",
        "Отключение параметров",
        "Перенос параметров в tempdb"
      ],
      "correct": 1,
      "explanation": "Современный оптимизатор может применять техники embedding, подставляя примерные значения вместо параметров для лучшей оценки кардинальности.",
      "difficulty": "hard"
    },
    {
      "id": 228,
      "question": "Какой механизм в Query Store помогает автоматически исправлять регрессии планов выполнения?",
      "options": [
        "Automatic Tuning (FORCE_LAST_GOOD_PLAN)",
        "Extended Events",
        "Log Shipping",
        "Service Broker"
      ],
      "correct": 0,
      "explanation": "Automatic Tuning с FORCE_LAST_GOOD_PLAN может автоматически форсировать предыдущий стабильный план при ухудшении производительности.",
      "difficulty": "hard"
    },
    {
      "id": 229,
      "question": "Какой тип индекса в In-Memory OLTP лучше для запросов по диапазонам?",
      "options": [
        "Hash индекс",
        "Range (nonclustered) index",
        "Columnstore индекс",
        "Full-Text индекс"
      ],
      "correct": 1,
      "explanation": "Для диапазонных запросов в In-Memory OLTP рекомендуется использовать range indexes, тогда как hash-индексы оптимальны для равенств.",
      "difficulty": "hard"
    },
    {
      "id": 230,
      "question": "Какой тип репликации позволяет использовать моментальный снимок как начальную точку для транзакционной репликации?",
      "options": [
        "Снимковая репликация",
        "Репликация слиянием",
        "Log Shipping",
        "Always On"
      ],
      "correct": 0,
      "explanation": "Транзакционная репликация часто инициализируется снимковым бэкапом/публикацией (snapshot), после чего применяются дальнейшие транзакции.",
      "difficulty": "hard"
    },
    {
      "id": 231,
      "question": "Какой механизм позволяет прозрачно перенаправлять подключения к одной и той же логической базе в Always On AG?",
      "options": [
        "Listener (виртуальное имя и порт)",
        "Database Mail",
        "Log Shipping монитор",
        "SQL Browser"
      ],
      "correct": 0,
      "explanation": "Listener предоставляет единое виртуальное имя/порт для AG, перенаправляя клиентов на текущую первичную или вторичную реплику.",
      "difficulty": "medium"
    },
    {
      "id": 232,
      "question": "Какой тип Always On Availability Group доступен в Standard Edition?",
      "options": [
        "Traditional AG с несколькими вторичными",
        "Basic Availability Group с одной базой и ограничениями",
        "Нет поддержки AG",
        "Clusterless AG"
      ],
      "correct": 1,
      "explanation": "Standard Edition поддерживает Basic AG с ограничениями (одна база на группу, меньше реплик и т.п.).",
      "difficulty": "hard"
    },
    {
      "id": 233,
      "question": "Какой механизм резервного копирования позволяет шифровать сами файлы бэкапа?",
      "options": [
        "BACKUP ... WITH ENCRYPTION",
        "TDE",
        "Always Encrypted",
        "RLS"
      ],
      "correct": 0,
      "explanation": "BACKUP WITH ENCRYPTION шифрует создаваемый файл бэкапа, используя сертификат или ключ, независимо от TDE.",
      "difficulty": "medium"
    },
    {
      "id": 234,
      "question": "Какой тип индекса можно использовать для ускорения поиска по иерархическим данным, хранящимся в типе hierarchyid?",
      "options": [
        "Полнотекстовый индекс",
        "Обычный B-Tree индекс по столбцу hierarchyid",
        "Columnstore индекс",
        "XML индекс"
      ],
      "correct": 1,
      "explanation": "Тип hierarchyid индексируется как обычный B-Tree, позволяя эффективно выполнять операции по иерархическим путям.",
      "difficulty": "hard"
    },
    {
      "id": 235,
      "question": "Что делает функция WAITFOR DELAY '00:00:05'?",
      "options": [
        "Ставит на паузу только текущую сессию на 5 секунд",
        "Останавливает сервер",
        "Перезапускает службу",
        "Очищает журнал"
      ],
      "correct": 0,
      "explanation": "WAITFOR DELAY приостанавливает выполнение текущей партии T-SQL на заданное время.",
      "difficulty": "easy"
    },
    {
      "id": 236,
      "question": "Какой системный объект использовать для отправки e-mail из SQL Server?",
      "options": [
        "Database Mail",
        "Service Broker",
        "Extended Events",
        "SQL Trace"
      ],
      "correct": 0,
      "explanation": "Database Mail позволяет отправлять сообщения электронной почты, используя SMTP, из SQL Server Agent или T-SQL.",
      "difficulty": "easy"
    },
    {
      "id": 237,
      "question": "Какой тип индекса можно использовать для ускорения запросов по нескольким столбцам, когда порядок важен (например, ORDER BY Col1, Col2)?",
      "options": [
        "Составной индекс (Composite Index)",
        "Фильтрованный индекс",
        "Hash индекс",
        "Full-Text индекс"
      ],
      "correct": 0,
      "explanation": "Составной индекс с ключами (Col1, Col2) позволяет выполнять упорядоченные и фильтрационные операции без дополнительной сортировки.",
      "difficulty": "medium"
    },
    {
      "id": 238,
      "question": "Какой механизм можно использовать для ограничения количества одновременных запросов к определённой таблице или процедуре?",
      "options": [
        "Resource Governor с классификатором",
        "Always On",
        "Log Shipping",
        "Database Mail"
      ],
      "correct": 0,
      "explanation": "Resource Governor через классификаторный модуль может помещать сессии в разные группы ресурсов с лимитами CPU/Concurrency.",
      "difficulty": "hard"
    },
    {
      "id": 239,
      "question": "Какой DMV использовать, чтобы увидеть распределение ожиданий по типу за время работы сервера?",
      "options": [
        "sys.dm_os_wait_stats",
        "sys.dm_os_waiting_tasks",
        "sys.dm_exec_requests",
        "sys.dm_exec_sessions"
      ],
      "correct": 0,
      "explanation": "sys.dm_os_wait_stats агрегирует ожидания по типам с момента последнего сброса статистики или рестарта сервера.",
      "difficulty": "medium"
    },
    {
      "id": 240,
      "question": "Какой DMV использовать для анализа текущих задач (tasks), выполняемых движком?",
      "options": [
        "sys.dm_os_tasks",
        "sys.dm_os_wait_stats",
        "sys.dm_exec_requests",
        "sys.dm_exec_sessions"
      ],
      "correct": 0,
      "explanation": "sys.dm_os_tasks показывает внутренние задачи, связанные с запросами и сессиями, включая планировщик потоков.",
      "difficulty": "hard"
    },
    {
      "id": 241,
      "question": "Какой тип блокировок используется для операций чтения в SNAPSHOT изоляции?",
      "options": [
        "S-блокировки на данные",
        "Используются версии строк, чтение не берёт S-блокировки на обычные данные",
        "X-блокировки",
        "U-блокировки"
      ],
      "correct": 1,
      "explanation": "В SNAPSHOT читатели используют версионность и не блокируют данные S-блокировками, снижая конкуренцию с писателями.",
      "difficulty": "hard"
    },
    {
      "id": 242,
      "question": "Какой механизм позволяет изолировать транзакцию от изменений других транзакций, сделанных после её начала, но при этом не блокировать их?",
      "options": [
        "READ COMMITTED",
        "SNAPSHOT",
        "READ UNCOMMITTED",
        "REPEATABLE READ"
      ],
      "correct": 1,
      "explanation": "SNAPSHOT предоставляет консистентный снимок на момент начала транзакции, используя версионность, без блокировки писателей.",
      "difficulty": "medium"
    },
    {
      "id": 243,
      "question": "Какой режим изоляции в SQL Server наименее изоляционный и допускает грязные чтения?",
      "options": [
        "READ UNCOMMITTED",
        "READ COMMITTED",
        "REPEATABLE READ",
        "SERIALIZABLE"
      ],
      "correct": 0,
      "explanation": "READ UNCOMMITTED допускает чтение данных, которые ещё не зафиксированы (dirty reads).",
      "difficulty": "easy"
    },
    {
      "id": 244,
      "question": "Какой тип constraint гарантирует уникальность строк и может быть использован как кластерный ключ?",
      "options": [
        "CHECK",
        "PRIMARY KEY",
        "FOREIGN KEY",
        "DEFAULT"
      ],
      "correct": 1,
      "explanation": "PRIMARY KEY обеспечивает уникальность и не допускает NULL; по умолчанию создаёт уникальный индекс (часто кластерный).",
      "difficulty": "easy"
    },
    {
      "id": 245,
      "question": "Какой тип constraint обеспечивает уникальность, но разрешает одно значение NULL (в зависимости от колляции)?",
      "options": [
        "PRIMARY KEY",
        "UNIQUE",
        "FOREIGN KEY",
        "CHECK"
      ],
      "correct": 1,
      "explanation": "UNIQUE constraint обеспечивает уникальность не-NULL значений; поддержка нескольких NULL зависит от реализации и индексов.",
      "difficulty": "medium"
    },
    {
      "id": 246,
      "question": "Какой механизм позволяет разделить таблицу на несколько файловых групп по диапазонам значений ключа?",
      "options": [
        "Partitioned table",
        "Heap",
        "Clustered index только",
        "Temp table"
      ],
      "correct": 0,
      "explanation": "Партиционированные таблицы распределяют данные по секциям в разных файловых группах, основываясь на функции партиционирования.",
      "difficulty": "hard"
    },
    {
      "id": 247,
      "question": "Какой оператор T-SQL использовать для переключения секции между партиционированными таблицами?",
      "options": [
        "ALTER INDEX ... REBUILD",
        "ALTER TABLE ... SWITCH PARTITION",
        "MERGE TABLE",
        "CREATE PARTITION SWITCH"
      ],
      "correct": 1,
      "explanation": "ALTER TABLE ... SWITCH PARTITION выполняет метаданные-операцию перемещения секций между таблицами/индексами без копирования данных.",
      "difficulty": "hard"
    },
    {
      "id": 248,
      "question": "Какой механизм позволяет выполнить частичное восстановление базы, оставив некоторые файловые группы offline до их восстановления?",
      "options": [
        "Piecemal Restore",
        "Differential Restore",
        "Copy-Only Restore",
        "Point-in-time Restore"
      ],
      "correct": 0,
      "explanation": "Piecemal restore позволяет восстановить критичные файловые группы в первую очередь и позже восстанавливать остальные.",
      "difficulty": "hard"
    },
    {
      "id": 249,
      "question": "Какой тип backup содержит только изменения с момента конкретного полного backup'а, а не с момента любого предыдущего differential?",
      "options": [
        "DIFFERENTIAL",
        "LOG",
        "FILEGROUP",
        "COPY_ONLY"
      ],
      "correct": 0,
      "explanation": "DIFFERENTIAL backup всегда отсчитывает изменения от последнего полного backup'а (не Copy-Only).",
      "difficulty": "medium"
    },
    {
      "id": 250,
      "question": "Какой механизм позволяет уменьшить влияние длительных операций rebuild индексов на доступность, даже если ONLINE недоступен?",
      "options": [
        "Разбиение операции на батчи (batched index maintenance)",
        "Отключение индекса",
        "TRUNCATE TABLE",
        "DBCC DROPCLEANBUFFERS"
      ],
      "correct": 0,
      "explanation": "Разбиение обслуживания индексов на небольшие батчи снижает время удержания блокировок и нагрузку на систему.",
      "difficulty": "hard"
    },
    {
      "id": 251,
      "question": "Какой DMV использовать для просмотра статистики по использованию CPU по сессиям?",
      "options": [
        "sys.dm_exec_sessions",
        "sys.dm_exec_requests",
        "sys.dm_os_performance_counters",
        "sys.dm_exec_query_stats"
      ],
      "correct": 0,
      "explanation": "sys.dm_exec_sessions содержит обобщённые счётчики CPU time, logical_reads и др. по сессиям.",
      "difficulty": "medium"
    },
    {
      "id": 252,
      "question": "Какой DMV использовать для анализа потребления памяти по объектам памяти (memory clerks)?",
      "options": [
        "sys.dm_os_memory_clerks",
        "sys.dm_os_process_memory",
        "sys.dm_exec_sessions",
        "sys.dm_os_sys_info"
      ],
      "correct": 0,
      "explanation": "sys.dm_os_memory_clerks показывает распределение памяти между разными компонентами SQL Server (буферный пул, кэш планов и т.п.).",
      "difficulty": "hard"
    },
    {
      "id": 253,
      "question": "Какой тип таблиц в In-Memory OLTP не сохраняет данные после рестарта сервера?",
      "options": [
        "SCHEMA_AND_DATA",
        "SCHEMA_ONLY",
        "COLUMNSTORE",
        "TEMPORAL"
      ],
      "correct": 1,
      "explanation": "SCHEMA_ONLY memory-optimized таблицы теряют данные при рестарте, полезны для временных/кэширующих сценариев.",
      "difficulty": "hard"
    },
    {
      "id": 254,
      "question": "Какой механизм SQL Server позволяет хранить и выполнять CLR-код (например, C#) внутри базы?",
      "options": [
        "SQL CLR Integration",
        "Service Broker",
        "Extended Events",
        "Database Mail"
      ],
      "correct": 0,
      "explanation": "SQL CLR Integration позволяет создавать сборки .NET и использовать их как функции, процедуры или типы в SQL Server.",
      "difficulty": "hard"
    },
    {
      "id": 255,
      "question": "Какой риск связан с включением TRUSTWORTHY ON для базы данных?",
      "options": [
        "Отключение TDE",
        "Возможность эскалации привилегий через вредоносные объекты (например, CLR)",
        "Удаление логов",
        "Отключение индексов"
      ],
      "correct": 1,
      "explanation": "TRUSTWORTHY ON может позволить базе выполнять код с повышенными привилегиями, поэтому его включают только при строгом контроле.",
      "difficulty": "hard"
    },
    {
      "id": 256,
      "question": "Какой тип JOIN сохранит все строки из правой таблицы, даже если нет совпадений в левой?",
      "options": [
        "LEFT JOIN",
        "RIGHT JOIN",
        "INNER JOIN",
        "CROSS JOIN"
      ],
      "correct": 1,
      "explanation": "RIGHT OUTER JOIN сохраняет все строки правой таблицы, добавляя NULL для не совпавших строк левой.",
      "difficulty": "easy"
    },
    {
      "id": 257,
      "question": "Какой оператор использовать для вывода иерархии с отступами (tree) без использования CURSOR?",
      "options": [
        "Рекурсивный CTE",
        "TEMP TABLE",
        "CROSS JOIN",
        "FOR XML PATH"
      ],
      "correct": 0,
      "explanation": "Рекурсивные CTE часто используются для обхода иерархий (parent/child) и формирования дерева.",
      "difficulty": "medium"
    },
    {
      "id": 258,
      "question": "Какой тип индекса использовать для ускорения поиска по JSON-полям, если часто фильтруем по конкретному пути (JSON_VALUE)?",
      "options": [
        "Полнотекстовый индекс",
        "Создать вычисляемый столбец на JSON_VALUE(...) и индексировать его",
        "Columnstore индекс",
        "XML индекс"
      ],
      "correct": 1,
      "explanation": "Рекомендуемый подход – вынести нужное значение JSON в вычисляемый или физический столбец и индексировать его.",
      "difficulty": "hard"
    },
    {
      "id": 259,
      "question": "Какой инструмент использовать для первоначальной оценки конфигурации и проблем производительности SQL Server (Best Practices)?",
      "options": [
        "SQL Server Profiler",
        "Database Engine Tuning Advisor",
        "SQL Server Assessment (SQL Server Management Data Warehouse или Azure SQL Assessment)",
        "sp_who2"
      ],
      "correct": 2,
      "explanation": "Assessment-инструменты (включая Azure SQL Assessment) помогают проверить конфигурацию на соответствие лучшим практикам.",
      "difficulty": "hard"
    },
    {
      "id": 260,
      "question": "Какой механизм позволяет измерить длительность выполнения блока T-SQL, используя только встроенные функции времени?",
      "options": [
        "DATEDIFF(ms, @start, @end) с использованием SYSDATETIME() или GETDATE()",
        "DBCC TIME",
        "SET STATISTICS TIME OFF",
        "WAITFOR DELAY"
      ],
      "correct": 0,
      "explanation": "Можно сохранить значение SYSDATETIME() до и после выполнения блока и вычислить разницу через DATEDIFF.",
      "difficulty": "easy"
    },
    {
      "id": 261,
      "question": "Какой тип файла в базе данных хранит фактические данные таблиц и индексов?",
      "options": [
        "Лог-файл (.ldf)",
        "Файл данных (.mdf/.ndf)",
        "Файл трассировки (.trc)",
        "Файл бэкапа (.bak)"
      ],
      "correct": 1,
      "explanation": "Файлы данных (mdf/ndf) содержат страницы таблиц и индексов; ldf – журнал транзакций.",
      "difficulty": "easy"
    },
    {
      "id": 262,
      "question": "Какой DMV использовать для просмотра использования пространства файлами данных и журнала?",
      "options": [
        "sys.dm_db_file_space_usage",
        "sys.dm_io_virtual_file_stats",
        "sys.dm_os_buffer_descriptors",
        "sys.dm_exec_sessions"
      ],
      "correct": 0,
      "explanation": "sys.dm_db_file_space_usage особенно полезен для tempdb, показывая использование пространства журналом версий, internal objects и т.п.",
      "difficulty": "hard"
    },
    {
      "id": 263,
      "question": "Какой тип индекса рекомендуется создавать на внешнем ключе (FOREIGN KEY)?",
      "options": [
        "Кластерный индекс",
        "Некластерный индекс по столбцу внешнего ключа",
        "Columnstore индекс",
        "Индекс не нужен"
      ],
      "correct": 1,
      "explanation": "Индекс на внешнем ключе ускоряет проверки ссылочной целостности и операции JOIN с родительской таблицей.",
      "difficulty": "medium"
    },
    {
      "id": 264,
      "question": "Какой механизм SQL Server позволяет ограничить права администратора базы (db_owner) в Managed окружениях (например, Azure SQL)?",
      "options": [
        "Роль dbmanager",
        "Роль db_owner всегда полная",
        "Роль securityadmin",
        "Нет такой возможности"
      ],
      "correct": 0,
      "explanation": "В Azure SQL Database права серверных ролей и db_owner отличаются от on-prem; специальные роли вроде dbmanager ограничивают функциональность.",
      "difficulty": "hard"
    },
    {
      "id": 265,
      "question": "Какой механизм позволяет ограничить доступ к базе данных по определённым IP-адресам или подсетям?",
      "options": [
        "SQL Server Endpoint Permissions",
        "Firewall на уровне сервера/службы (Windows Firewall, Azure SQL firewall)",
        "RLS",
        "Always Encrypted"
      ],
      "correct": 1,
      "explanation": "Ограничение по IP реализуется на уровне брандмауэра сервера или облачного сервиса, а не средствами T-SQL.",
      "difficulty": "medium"
    },
    {
      "id": 266,
      "question": "Какой тип данных лучше использовать для хранения денежного значения с точностью до копеек?",
      "options": [
        "FLOAT",
        "DECIMAL(p, 2)",
        "REAL",
        "INT"
      ],
      "correct": 1,
      "explanation": "DECIMAL с фиксированной точностью избегает ошибок округления, присущих типам с плавающей точкой.",
      "difficulty": "easy"
    },
    {
      "id": 267,
      "question": "Какой тип данных лучше использовать для хранения флага (true/false) в SQL Server?",
      "options": [
        "BIT",
        "TINYINT",
        "CHAR(1)",
        "INT"
      ],
      "correct": 0,
      "explanation": "BIT – компактный тип для булевых значений; может принимать 0, 1 или NULL.",
      "difficulty": "easy"
    },
    {
      "id": 268,
      "question": "Какой тип данных лучше использовать для хранения фиксированной длины кода, например двухсимвольного ISO-кода страны?",
      "options": [
        "VARCHAR(2)",
        "CHAR(2)",
        "NVARCHAR(MAX)",
        "TEXT"
      ],
      "correct": 1,
      "explanation": "CHAR(2) оптимален для фиксированной длины строк, обеспечивая предсказуемое хранение и сравнение.",
      "difficulty": "easy"
    },
    {
      "id": 269,
      "question": "Какой тип данных использовать для хранения больших текстов (до нескольких мегабайт) в современных версиях SQL Server?",
      "options": [
        "TEXT/NTEXT",
        "VARCHAR(MAX)/NVARCHAR(MAX)",
        "IMAGE",
        "CHAR(8000)"
      ],
      "correct": 1,
      "explanation": "Типы TEXT/NTEXT/IMAGE устарели; вместо них следует использовать VARCHAR(MAX)/NVARCHAR(MAX)/VARBINARY(MAX).",
      "difficulty": "medium"
    },
    {
      "id": 270,
      "question": "Какой тип данных использовать для хранения бинарных файлов (например, документов) в таблице?",
      "options": [
        "VARBINARY(MAX)",
        "IMAGE",
        "XML",
        "NVARCHAR(MAX)"
      ],
      "correct": 0,
      "explanation": "VARBINARY(MAX) – рекомендуемый тип для бинарных данных; IMAGE устарел.",
      "difficulty": "medium"
    },
    {
      "id": 271,
      "question": "Какой оператор использовать для явного преобразования типа данных в T-SQL?",
      "options": [
        "CAST/CONVERT",
        "CHANGE TYPE",
        "ALTER TYPE",
        "TO_TYPE"
      ],
      "correct": 0,
      "explanation": "CAST и CONVERT выполняют явное преобразование типов; CONVERT также поддерживает стили форматирования.",
      "difficulty": "easy"
    },
    {
      "id": 272,
      "question": "Какой тип данных использовать для хранения только даты без времени?",
      "options": [
        "DATETIME",
        "DATE",
        "TIME",
        "SMALLDATETIME"
      ],
      "correct": 1,
      "explanation": "DATE хранит только компонент даты без времени и занимает меньше места, чем DATETIME.",
      "difficulty": "easy"
    },
    {
      "id": 273,
      "question": "Какой тип данных использовать для хранения только времени без даты?",
      "options": [
        "DATETIME",
        "TIME",
        "SMALLDATETIME",
        "DATE"
      ],
      "correct": 1,
      "explanation": "TIME хранит только компонент времени с заданной точностью, без даты.",
      "difficulty": "easy"
    },
    {
      "id": 274,
      "question": "Какой тип данных использовать для идентификатора, который должен быть уникален в распределённой системе?",
      "options": [
        "INT IDENTITY",
        "UNIQUEIDENTIFIER (GUID)",
        "BIGINT",
        "CHAR(36)"
      ],
      "correct": 1,
      "explanation": "UNIQUEIDENTIFIER (GUID) обеспечивает глобальную уникальность без координации с сервером, хотя имеет недостатки по размеру и фрагментации.",
      "difficulty": "medium"
    },
    {
      "id": 275,
      "question": "Какой тип данных использовать для автоинкрементного числового идентификатора?",
      "options": [
        "IDENTITY для INT/BIGINT",
        "UNIQUEIDENTIFIER",
        "ROWVERSION",
        "DECIMAL"
      ],
      "correct": 0,
      "explanation": "Свойство IDENTITY на столбце INT/BIGINT автоматически генерирует последовательные значения при вставке.",
      "difficulty": "easy"
    },
    {
      "id": 276,
      "question": "Какой тип данных лучше использовать для хранения версионного токена строки, но не для бизнес-логики?",
      "options": [
        "ROWVERSION/TIMESTAMP",
        "DATETIME",
        "INT",
        "GUID"
      ],
      "correct": 0,
      "explanation": "ROWVERSION – бинарный счётчик версий, автоматически увеличиваемый при изменениях; не несёт значения времени.",
      "difficulty": "medium"
    },
    {
      "id": 277,
      "question": "Какой тип данных использовать для хранения географических координат (широта/долгота) с возможностью пространственных запросов?",
      "options": [
        "GEOGRAPHY",
        "GEOMETRY",
        "VARBINARY(MAX)",
        "XML"
      ],
      "correct": 0,
      "explanation": "Тип GEOGRAPHY предназначен для хранения координат на сфере (широта/долгота) и поддерживает пространственные индексы и функции.",
      "difficulty": "hard"
    },
    {
      "id": 278,
      "question": "Какой тип данных использовать для хранения 2D геометрии (полигоны, линии) в произвольной системе координат?",
      "options": [
        "GEOGRAPHY",
        "GEOMETRY",
        "VARBINARY(MAX)",
        "XML"
      ],
      "correct": 1,
      "explanation": "Тип GEOMETRY хранит плоскую геометрию и также поддерживает пространственные индексы и функции.",
      "difficulty": "hard"
    },
    {
      "id": 279,
      "question": "Какой оператор использовать для определения того, находится ли точка внутри полигона в пространственных данных?",
      "options": [
        "STIntersects",
        "STBuffer",
        "STDistance",
        "STArea"
      ],
      "correct": 0,
      "explanation": "Метод STIntersects определяет, пересекаются ли два пространственных объекта (включая случай, когда точка внутри полигона).",
      "difficulty": "hard"
    },
    {
      "id": 280,
      "question": "Какой оператор использовать для сортировки результатов по вычисляемому выражению без повторного его указания в ORDER BY?",
      "options": [
        "ORDER BY 1",
        "ORDER BY алиас выражения",
        "ORDER BY *",
        "ORDER BY COLUMN_NAME"
      ],
      "correct": 1,
      "explanation": "Можно использовать алиас вычисляемого столбца в ORDER BY (если он определён в SELECT).",
      "difficulty": "easy"
    },
    {
      "id": 281,
      "question": "Какой риск при использовании ORDER BY 1 вместо имени столбца?",
      "options": [
        "Ошибка компиляции",
        "Хрупкость: изменение порядка столбцов в SELECT изменит семантику сортировки",
        "Отключение индексов",
        "Нарушение ссылочной целостности"
      ],
      "correct": 1,
      "explanation": "ORDER BY по позиции делает код менее читаемым и чувствительным к изменению списка столбцов.",
      "difficulty": "medium"
    },
    {
      "id": 282,
      "question": "Какой оператор использовать для применения оконной функции к результату агрегации?",
      "options": [
        "GROUP BY только",
        "Вложенный SELECT: сначала агрегат, затем оконная функция во внешнем запросе",
        "CROSS JOIN",
        "MERGE"
      ],
      "correct": 1,
      "explanation": "Часто требуется обернуть агрегатный запрос во внешний SELECT и там применить оконные функции.",
      "difficulty": "medium"
    },
    {
      "id": 283,
      "question": "Какой оператор использовать для замены NULL на значение по умолчанию при выборке?",
      "options": [
        "COALESCE/ISNULL",
        "NVL",
        "DECODE",
        "NVARCHAR"
      ],
      "correct": 0,
      "explanation": "COALESCE и ISNULL позволяют подставить значение вместо NULL; COALESCE – стандартный и поддерживает более двух аргументов.",
      "difficulty": "easy"
    },
    {
      "id": 284,
      "question": "Какой оператор использовать для условного выбора между двумя значениями в простых выражениях?",
      "options": [
        "CASE",
        "IIF",
        "DECODE",
        "IF-ELSE"
      ],
      "correct": 0,
      "explanation": "CASE – стандартный оператор условных выражений в SQL, поддерживаемый во всех версиях и контекстах.",
      "difficulty": "easy"
    },
    {
      "id": 285,
      "question": "Какой оператор использовать для выполнения условной логики на уровне блоков T-SQL (не в выражениях)?",
      "options": [
        "CASE",
        "IF ... ELSE",
        "IIF",
        "CHOOSE"
      ],
      "correct": 1,
      "explanation": "IF ... ELSE используется для условного выполнения блоков T-SQL (процедуры, скрипты).",
      "difficulty": "easy"
    },
    {
      "id": 286,
      "question": "Какой оператор использовать для динамического формирования и выполнения T-SQL строки?",
      "options": [
        "EXEC('...') или sp_executesql",
        "RUNSQL",
        "DO",
        "CALL"
      ],
      "correct": 0,
      "explanation": "EXEC и sp_executesql выполняют динамически сформированную строку T-SQL; sp_executesql поддерживает параметризацию.",
      "difficulty": "medium"
    },
    {
      "id": 287,
      "question": "Какой механизм предпочтительнее для динамического SQL с точки зрения безопасности и повторного использования планов?",
      "options": [
        "Конкатенация строк и EXEC",
        "sp_executesql с параметрами",
        "xp_cmdshell",
        "OPENROWSET"
      ],
      "correct": 1,
      "explanation": "sp_executesql с параметрами снижает риск SQL injection и улучшает повторное использование планов.",
      "difficulty": "hard"
    },
    {
      "id": 288,
      "question": "Какой риск связан с использованием xp_cmdshell?",
      "options": [
        "Отсутствие план-кэша",
        "Возможность выполнения произвольных команд ОС от имени службы SQL Server",
        "Отключение журналирования",
        "Удаление индексов"
      ],
      "correct": 1,
      "explanation": "xp_cmdshell позволяет выполнять команды ОС, что несёт серьёзные риски безопасности и обычно отключено по умолчанию.",
      "difficulty": "hard"
    },
    {
      "id": 289,
      "question": "Какой механизм можно использовать для экспорта результата запроса в CSV-файл без использования внешних утилит?",
      "options": [
        "bcp или sqlcmd в сочетании с T-SQL",
        "xp_cmdshell",
        "Database Mail",
        "Service Broker"
      ],
      "correct": 0,
      "explanation": "Утилиты bcp и sqlcmd, вызываемые из скриптов/агента, часто используются для экспорта данных в файлы.",
      "difficulty": "medium"
    },
    {
      "id": 290,
      "question": "Какой системный объект использовать для копирования данных между серверами с возможностью трансформаций?",
      "options": [
        "SSIS (SQL Server Integration Services)",
        "Service Broker",
        "Extended Events",
        "Database Mail"
      ],
      "correct": 0,
      "explanation": "SSIS – ETL-платформа для перемещения и трансформации данных между источниками, включая SQL Server.",
      "difficulty": "medium"
    },
    {
      "id": 291,
      "question": "Какой механизм SQL Server позволяет выполнять распределённые запросы к другим источникам данных (SQL, Oracle, Excel)?",
      "options": [
        "Linked Servers",
        "Service Broker",
        "Always On",
        "Extended Events"
      ],
      "correct": 0,
      "explanation": "Linked Servers позволяют выполнять запросы к внешним источникам через OLE DB провайдеры с использованием четырехчастных имён.",
      "difficulty": "medium"
    },
    {
      "id": 292,
      "question": "Какой риск при использовании Linked Servers для OLTP-нагрузок?",
      "options": [
        "Отключение индексов",
        "Высокие задержки, распределённые транзакции и сложность отладки",
        "Отключение TDE",
        "Невозможность выполнять SELECT"
      ],
      "correct": 1,
      "explanation": "Linked Servers добавляют сетевые задержки и могут вовлекать распределённые транзакции, что плохо сказывается на OLTP.",
      "difficulty": "hard"
    },
    {
      "id": 293,
      "question": "Какой механизм использовать для кеширования результатов тяжёлых запросов на стороне приложения, чтобы разгрузить базу?",
      "options": [
        "Query Store",
        "Внешний кэш (Redis, MemoryCache) с TTL",
        "Temp table",
        "Service Broker"
      ],
      "correct": 1,
      "explanation": "Часто кэширование делается на уровне приложения/внешнего кэша, а не в самой базе, для снижения нагрузки на SQL Server.",
      "difficulty": "medium"
    },
    {
      "id": 294,
      "question": "Какой механизм SQL Server можно использовать для кеширования редко изменяющихся справочников в памяти?",
      "options": [
        "In-Memory OLTP (memory-optimized таблицы)",
        "Tempdb",
        "Extended Events",
        "Database Mail"
      ],
      "correct": 0,
      "explanation": "Memory-optimized таблицы подходят для высокочастотного доступа к справочникам с минимальной задержкой.",
      "difficulty": "hard"
    },
    {
      "id": 295,
      "question": "Какой DMV использовать для анализа, какие таблицы занимают больше всего места в базе?",
      "options": [
        "sys.dm_db_partition_stats",
        "sys.dm_exec_query_stats",
        "sys.dm_os_buffer_descriptors",
        "sys.dm_os_wait_stats"
      ],
      "correct": 0,
      "explanation": "sys.dm_db_partition_stats даёт размер по строкам и страницам для каждой партиции/таблицы.",
      "difficulty": "medium"
    },
    {
      "id": 296,
      "question": "Какой системный каталог хранит сведения о зависимостях объектов (кто от кого зависит)?",
      "options": [
        "sys.sql_dependencies (устар.) и sys.dm_sql_referenced_entities/sys.dm_sql_referencing_entities",
        "sys.objects только",
        "sys.tables",
        "sys.columns"
      ],
      "correct": 0,
      "explanation": "Для анализа зависимостей рекомендуется использовать функции dm_sql_referenced_entities/dm_sql_referencing_entities, а не устаревший sys.sql_dependencies.",
      "difficulty": "hard"
    },
    {
      "id": 297,
      "question": "Какой механизм позволяет автоматически пересоздавать отсутствующие индексы на основе рекомендаций Database Tuning Advisor?",
      "options": [
        "Автоматическое индексирование в Azure SQL Database",
        "sp_autoindex",
        "DBCC INDEXREBUILD",
        "Extended Events"
      ],
      "correct": 0,
      "explanation": "В Azure SQL Database есть автоматическое индексирование, анализирующее нагрузку и создающее/удаляющее индексы.",
      "difficulty": "hard"
    },
    {
      "id": 298,
      "question": "Какой механизм SQL Server позволяет объединить несколько баз в один логический шардированный набор в Azure?",
      "options": [
        "Elastic Database Tools/Elastic Query",
        "Always On",
        "Log Shipping",
        "Replication"
      ],
      "correct": 0,
      "explanation": "Elastic Database Tools и Elastic Query позволяют обращаться к нескольким шардированным базам как к одному логическому набору.",
      "difficulty": "hard"
    },
    {
      "id": 299,
      "question": "Какой механизм использовать для миграции схемы и данных между серверами SQL Server с контролем версий?",
      "options": [
        "SSDT (SQL Server Data Tools) или DACPAC",
        "Database Mail",
        "Extended Events",
        "sp_detach_db/sp_attach_db"
      ],
      "correct": 0,
      "explanation": "SSDT и DACPAC позволяют описывать схему как код и выполнять контролируемые деплойments между серверами.",
      "difficulty": "hard"
    },
    {
      "id": 300,
      "question": "Какой общий подход рекомендуется при оптимизации сложных запросов в SQL Server?",
      "options": [
        "Сразу добавлять индексы на все столбцы",
        "Измерять, анализировать планы, уменьшать объём обрабатываемых данных, исправлять SARGability и только затем добавлять целевые индексы",
        "Отключать все триггеры",
        "Очистить кэш и перезапускать сервер при каждом изменении"
      ],
      "correct": 1,
      "explanation": "Лучший подход – системно анализировать планы, данные и статистики, минимизировать объём работы и затем точечно добавлять индексы и хинты.",
      "difficulty": "medium"
    }
  ]
}