{
  "version": "2.0.0",
  "lastUpdated": "2025-11-15",
  "category": "mssql",
  "questions": [
    {
      "id": 1,
      "question": "Что такое кластерный индекс в SQL Server?",
      "options": [
        "Отдельная структура, не влияющая на порядок данных",
        "Индекс, определяющий физический порядок строк таблицы",
        "Индекс только для VIEW",
        "Только уникальный индекс"
      ],
      "correct": 1,
      "explanation": "Кластерный индекс определяет физический порядок строк в таблице, делая таблицу упорядоченной B-деревом по ключу кластерного индекса.",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Для чего используется переменная @@ROWCOUNT?",
      "options": [
        "Возвращает число таблиц в БД",
        "Возвращает число строк, затронутых последней инструкцией",
        "Возвращает количество индексов на таблице",
        "Возвращает размер базы данных"
      ],
      "correct": 1,
      "explanation": "@@ROWCOUNT возвращает количество строк, затронутых последней выполненной инструкцией DML или SELECT.",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "Что показывает план выполнения запроса (Execution Plan)?",
      "options": [
        "Историю выполнений запросов",
        "Шаги и операторы, используемые оптимизатором для выполнения запроса",
        "Только статистику ввода-вывода",
        "Содержимое кэша планов"
      ],
      "correct": 1,
      "explanation": "План выполнения отображает операторы (скан, поиск, соединение и т.д.) и их порядок, выбранные оптимизатором для выполнения запроса.",
      "difficulty": "easy"
    },
    {
      "id": 4,
      "question": "Что такое некластерный индекс?",
      "options": [
        "Индекс, идентичный кластерному",
        "Отдельная структура B-дерева, хранящая ключ и указатель на данные",
        "Только полнотекстовый индекс",
        "Индекс, доступный только в памяти"
      ],
      "correct": 1,
      "explanation": "Некластерный индекс — отдельная структура, содержащая ключи и указатели на строки данных (RID или ключ кластерного индекса).",
      "difficulty": "easy"
    },
    {
      "id": 5,
      "question": "Какой уровень изоляции по умолчанию в SQL Server?",
      "options": [
        "READ UNCOMMITTED",
        "READ COMMITTED",
        "REPEATABLE READ",
        "SNAPSHOT"
      ],
      "correct": 1,
      "explanation": "По умолчанию используется уровень изоляции READ COMMITTED.",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "Чем NVARCHAR отличается от VARCHAR?",
      "options": [
        "NVARCHAR хранит только ASCII",
        "NVARCHAR хранит Unicode, VARCHAR — кодовую страницу",
        "Разницы нет",
        "VARCHAR хранит Unicode, NVARCHAR — нет"
      ],
      "correct": 1,
      "explanation": "NVARCHAR — Unicode (UTF-16), VARCHAR — однобайтовые кодировки согласно колляции.",
      "difficulty": "easy"
    },
    {
      "id": 7,
      "question": "Что делает функция GETDATE()?",
      "options": [
        "Возвращает текущую дату без времени",
        "Возвращает текущие дату и время на сервере",
        "Возвращает только время",
        "Устанавливает системное время"
      ],
      "correct": 1,
      "explanation": "GETDATE() возвращает текущие дату и время (datetime) сервера SQL.",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Какой порядок по умолчанию у ORDER BY без указания ASC/DESC?",
      "options": [
        "DESC",
        "ASC",
        "Случайный",
        "Зависит от индекса"
      ],
      "correct": 1,
      "explanation": "ORDER BY без модификатора по умолчанию сортирует по возрастанию (ASC).",
      "difficulty": "easy"
    },
    {
      "id": 9,
      "question": "Чем COUNT(*) отличается от COUNT(столбец)?",
      "options": [
        "COUNT(*) игнорирует NULL, COUNT(столбец) — нет",
        "COUNT(*) считает все строки, COUNT(столбец) игнорирует NULL",
        "Обе функции всегда совпадают",
        "COUNT(столбец) считает быстрее"
      ],
      "correct": 1,
      "explanation": "COUNT(*) считает все строки, COUNT(столбец) — только строки с ненулевым значением в столбце.",
      "difficulty": "easy"
    },
    {
      "id": 10,
      "question": "Что возвращает LEFT JOIN при отсутствии совпадений в правой таблице?",
      "options": [
        "Строки не возвращаются",
        "Строки из левой таблицы с NULL-значениями справа",
        "Только совпадающие строки",
        "Дубликаты левых строк"
      ],
      "correct": 1,
      "explanation": "LEFT JOIN возвращает все строки левой таблицы; при отсутствии совпадений столбцы правой таблицы будут NULL.",
      "difficulty": "easy"
    },
    {
      "id": 11,
      "question": "Что такое индекс с включёнными столбцами (INCLUDE) в некластерном индексе?",
      "options": [
        "Кластерный индекс",
        "Дополнительные неключевые столбцы, хранимые на уровне листьев",
        "Полнотекстовый индекс",
        "Только уникальный индекс"
      ],
      "correct": 1,
      "explanation": "INCLUDE добавляет неключевые столбцы на уровень листьев некластерного индекса для покрытия запросов без обращения к таблице.",
      "difficulty": "medium"
    },
    {
      "id": 12,
      "question": "Что такое covering index?",
      "options": [
        "Любой кластерный индекс",
        "Индекс, содержащий все необходимые запросу столбцы",
        "Индекс для внешних ключей",
        "Индекс для полнотекстового поиска"
      ],
      "correct": 1,
      "explanation": "Covering index покрывает запрос: все используемые столбцы присутствуют в ключе и/или включённых столбцах индекса.",
      "difficulty": "medium"
    },
    {
      "id": 13,
      "question": "Что такое SARGability?",
      "options": [
        "Способность запроса использовать последовательные GUID",
        "Способность предикатов эффективно использовать индексы",
        "Функция для сортировки",
        "Опция параллелизма"
      ],
      "correct": 1,
      "explanation": "SARGable-предикаты позволяют оптимизатору применять индексный поиск вместо полного сканирования.",
      "difficulty": "medium"
    },
    {
      "id": 14,
      "question": "Что делает опция OPTION(RECOMPILE) для запроса?",
      "options": [
        "Запрещает выполнение запроса",
        "Компилирует план заново при каждом выполнении, не кэшируя",
        "Удаляет статистики",
        "Включает параллелизм"
      ],
      "correct": 1,
      "explanation": "RECOMPILE заставляет оптимизатор строить новый план и не сохранять его в кэш, часто помогает при параметрическом запахе.",
      "difficulty": "medium"
    },
    {
      "id": 15,
      "question": "Какая разница между TEMP TABLE (#t) и TABLE variable (@t)?",
      "options": [
        "Нет разницы",
        "@t имеет иные правила оценки кардинальности и статистик",
        "#t доступна только в CLR",
        "@t хранится в другой базе"
      ],
      "correct": 1,
      "explanation": "Табличные переменные имеют иные правила оценки кардинальности и статистик; временные таблицы поддерживают статистики и зачастую оптимизируются лучше.",
      "difficulty": "medium"
    },
    {
      "id": 16,
      "question": "Чем SEQUENCE отличается от IDENTITY?",
      "options": [
        "SEQUENCE работает только в памяти",
        "SEQUENCE — объект БД, независимый от таблицы; IDENTITY — свойство столбца",
        "IDENTITY всегда уникален, SEQUENCE — нет",
        "IDENTITY можно использовать в нескольких таблицах"
      ],
      "correct": 1,
      "explanation": "SEQUENCE — отдельный объект, который можно использовать в разных таблицах; IDENTITY — свойство конкретного столбца таблицы.",
      "difficulty": "medium"
    },
    {
      "id": 17,
      "question": "Что делает Query Store?",
      "options": [
        "Удаляет планы выполнения",
        "Собирает историю запросов, планов и метрик для анализа",
        "Выполняет бэкапы",
        "Отключает параллелизм"
      ],
      "correct": 1,
      "explanation": "Query Store сохраняет планы и статистику выполнения запросов, облегчая анализ регрессий и форсирование планов.",
      "difficulty": "medium"
    },
    {
      "id": 18,
      "question": "Назначение DBCC CHECKDB?",
      "options": [
        "Сжатие базы",
        "Проверка логической и физической целостности БД",
        "Создание индексов",
        "Смена колляции"
      ],
      "correct": 1,
      "explanation": "DBCC CHECKDB проверяет целостность всех объектов и страниц базы данных.",
      "difficulty": "medium"
    },
    {
      "id": 19,
      "question": "Какой режим восстановления позволяет точечное восстановление во времени при наличии лог-бэкапов?",
      "options": [
        "SIMPLE",
        "FULL",
        "SUSPECT",
        "READ_ONLY"
      ],
      "correct": 1,
      "explanation": "FULL позволяет точечное восстановление при наличии цепочки бэкапов: полный, дифференциальный и лог-бэкапы.",
      "difficulty": "medium"
    },
    {
      "id": 20,
      "question": "Для чего используют фильтрованные индексы (Filtered Index)?",
      "options": [
        "Для шифрования",
        "Для индексации подмножества строк с предикатом WHERE",
        "Для бэкапа",
        "Для репликации"
      ],
      "correct": 1,
      "explanation": "Фильтрованные индексы создаются на подмножество данных, снижая размер и ускоряя запросы по условию фильтра.",
      "difficulty": "medium"
    },
    {
      "id": 21,
      "question": "Что такое Columnstore индекс?",
      "options": [
        "Индекс по строкам",
        "Колонночный индекс, оптимизированный для аналитических нагрузок",
        "Только для временных таблиц",
        "Только уникальный индекс"
      ],
      "correct": 1,
      "explanation": "Columnstore хранит данные по столбцам, обеспечивает сильное сжатие и эффективен для сканирования больших наборов данных.",
      "difficulty": "medium"
    },
    {
      "id": 22,
      "question": "Что делает MAXDOP?",
      "options": [
        "Ограничивает максимальную глубину индексов",
        "Ограничивает максимальную степень параллелизма запроса",
        "Отключает планы",
        "Увеличивает размер буферного пула"
      ],
      "correct": 1,
      "explanation": "MAXDOP ограничивает максимальное число параллельных потоков, используемых для выполнения одного запроса.",
      "difficulty": "medium"
    },
    {
      "id": 23,
      "question": "Чем SNAPSHOT Isolation отличается от READ COMMITTED SNAPSHOT (RCSI)?",
      "options": [
        "Никак",
        "SNAPSHOT требует явного SET TRANSACTION ISOLATION LEVEL; RCSI прозрачно заменяет блокировки чтением версий",
        "RCSI — выше по уровню, чем SERIALIZABLE",
        "SNAPSHOT блокирует меньше, чем RCSI"
      ],
      "correct": 1,
      "explanation": "SNAPSHOT — явный уровень транзакции; RCSI — режим базы, делающий READ COMMITTED версионным.",
      "difficulty": "medium"
    },
    {
      "id": 24,
      "question": "Что такое параметрический запах (Parameter Sniffing)?",
      "options": [
        "Повреждение параметров",
        "Использование плана, оптимизированного под конкретные значения параметров, что может вредить другим значениям",
        "Ошибка компиляции",
        "Сбой репликации"
      ],
      "correct": 1,
      "explanation": "Оптимизатор при компиляции учитывает текущие значения параметров; полученный план может быть неэффективным для других значений.",
      "difficulty": "medium"
    },
    {
      "id": 25,
      "question": "Какой оператор T-SQL удобно использовать для нумерации строк в рамках раздела?",
      "options": [
        "GROUPING SETS",
        "ROW_NUMBER() OVER(PARTITION BY ... ORDER BY ...)",
        "HASHBYTES",
        "FOR XML PATH"
      ],
      "correct": 1,
      "explanation": "Функция ROW_NUMBER() с оконным определением нумерует строки в каждом разделе согласно сортировке.",
      "difficulty": "medium"
    },
    {
      "id": 26,
      "question": "Для чего используется CROSS APPLY?",
      "options": [
        "Полнотекстовый поиск",
        "Применение табличной функции к каждой строке внешнего набора",
        "Сжатие страниц",
        "Репликация"
      ],
      "correct": 1,
      "explanation": "CROSS APPLY соединяет внешнюю таблицу с результатом табличной функции, вызываемой для каждой строки.",
      "difficulty": "medium"
    },
    {
      "id": 27,
      "question": "Чем отличается OUTER APPLY от CROSS APPLY?",
      "options": [
        "Ничем",
        "OUTER APPLY сохраняет строки внешней таблицы при пустом результате функции",
        "CROSS APPLY делает LEFT JOIN",
        "OUTER APPLY быстрее"
      ],
      "correct": 1,
      "explanation": "OUTER APPLY аналогичен LEFT JOIN для APPLY: строки внешней стороны сохраняются даже при отсутствии результата функции (NULL-ы).",
      "difficulty": "medium"
    },
    {
      "id": 28,
      "question": "В чём преимущество Filtered Statistics?",
      "options": [
        "Создают бэкапы",
        "Даёт более точные оценки для подмножеств данных",
        "Включают CDC",
        "Отключают параллелизм"
      ],
      "correct": 1,
      "explanation": "Фильтрованные статистики улучшают оценку кардинальности для специфичных предикатов по подмножеству данных.",
      "difficulty": "medium"
    },
    {
      "id": 29,
      "question": "Чем отличается FULL от DIFFERENTIAL backup?",
      "options": [
        "DIFF содержит только лог",
        "DIFF содержит изменения с момента последнего полного бэкапа",
        "FULL включает только данные за день",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "DIFFERENTIAL хранит изменения относительно базового полного бэкапа, ускоряя восстановление.",
      "difficulty": "medium"
    },
    {
      "id": 30,
      "question": "Для чего используют партиционирование таблиц?",
      "options": [
        "Для шифрования",
        "Для масштабируемого управления крупными таблицами (управление сечениями, переключение, локальные индексы)",
        "Для генерации GUID",
        "Для снятия дампа памяти"
      ],
      "correct": 1,
      "explanation": "Партиционирование помогает управлять и обслуживать большие таблицы (переключение секций, локальные операции индексации).",
      "difficulty": "medium"
    },
    {
      "id": 31,
      "question": "Какое преимущество у параметра OPTION(OPTIMIZE FOR ...) ?",
      "options": [
        "Отключает статистики",
        "Позволяет указать оптимизатору, под какие значения строить план",
        "Включает инMemory",
        "Делает запрос атомарным"
      ],
      "correct": 1,
      "explanation": "OPTIMIZE FOR позволяет явно указать значения параметров для компиляции плана, обходя влияние текущих значений.",
      "difficulty": "medium"
    },
    {
      "id": 32,
      "question": "Как определить и исследовать взаимоблокировку (deadlock)?",
      "options": [
        "Через DBCC LOG", 
        "Через Extended Events/Trace флаги/SQL Server Error Log",
        "Никак",
        "Только через репликацию"
      ],
      "correct": 1,
      "explanation": "Взаимоблокировки фиксируются через Extended Events (system_health) и могут попадать в журнал ошибок; доступны графы deadlock.",
      "difficulty": "medium"
    },
    {
      "id": 33,
      "question": "Что такое Read-Ahead в SQL Server?",
      "options": [
        "Механизм резервного копирования",
        "Предварительное чтение страниц данными движком ввода-вывода",
        "Метод шифрования",
        "Механизм журналирования"
      ],
      "correct": 1,
      "explanation": "Read-Ahead — механизм предварительного чтения страниц из диска в буферный пул для ускорения сканов.",
      "difficulty": "medium"
    },
    {
      "id": 34,
      "question": "Назначение DMV sys.dm_exec_query_stats?",
      "options": [
        "Показывает структуру страниц",
        "Возвращает агрегированные статистики по выполненным планам",
        "Управляет правами",
        "Создаёт индексы"
      ],
      "correct": 1,
      "explanation": "sys.dm_exec_query_stats содержит статистику по кэшированным планам: время, логические чтения, выполнение и т.д.",
      "difficulty": "medium"
    },
    {
      "id": 35,
      "question": "Какова роль статистик в оптимизаторе запросов?",
      "options": [
        "Не используются",
        "Помогают оценить кардинальность и выбрать план",
        "Только для бэкапов",
        "Только для шифрования"
      ],
      "correct": 1,
      "explanation": "Статистики информируют оптимизатор о распределении значений, что влияет на выбор операторов и соединений.",
      "difficulty": "medium"
    },
    {
      "id": 36,
      "question": "Где хранятся объекты TempDB и как она используется?",
      "options": [
        "В пользовательской БД",
        "В системной базе TempDB для временных объектов, версионности, хеш-операций и т.д.",
        "В master",
        "Только в памяти"
      ],
      "correct": 1,
      "explanation": "TempDB — системная БД для временных таблиц, версий строк, операций сортировки/хеширования, промежуточных результатов и т.д.",
      "difficulty": "medium"
    },
    {
      "id": 37,
      "question": "Как быстро обновить статистики во всей базе?",
      "options": [
        "DBCC CHECKDB",
        "EXEC sp_updatestats",
        "ALTER DATABASE SET RECOVERY",
        "DBCC FREEPROCCACHE"
      ],
      "correct": 1,
      "explanation": "sp_updatestats обновляет устаревшие статистики во всей базе данных.",
      "difficulty": "medium"
    },
    {
      "id": 38,
      "question": "Чем отличается логическая и физическая фрагментация индекса?",
      "options": [
        "Нет отличий",
        "Логическая — порядок ключей; физическая — расположение страниц на диске/расхождение последовательностей",
        "Логическая — только для кластерных",
        "Физическая — только в памяти"
      ],
      "correct": 1,
      "explanation": "Логическая фрагментация — нарушение последовательности ключей; физическая — разреженное/несмежное размещение страниц, ухудшающее последовательное чтение.",
      "difficulty": "medium"
    },
    {
      "id": 39,
      "question": "Что делает WITH (NOLOCK)?",
      "options": [
        "Гарантирует читаемую консистентность",
        "Позволяет чтение без блокировок с риском грязного чтения",
        "Ускоряет только записи",
        "Включает снапшот"
      ],
      "correct": 1,
      "explanation": "NOLOCK (READ UNCOMMITTED) читает без ожидания, но возможны грязные, неповторяемые чтения и фантомы.",
      "difficulty": "medium"
    },
    {
      "id": 40,
      "question": "Какой тип соединения обычно эффективен при неравенствах и больших объёмах?",
      "options": [
        "Nested Loops",
        "Hash Match",
        "Merge Join",
        "Cartesian Join"
      ],
      "correct": 1,
      "explanation": "Hash Match эффективно обрабатывает большие наборы и неравенства, жертвуя памятью и возможными проливами в TempDB.",
      "difficulty": "medium"
    },
    {
      "id": 41,
      "question": "Где задаётся Cost Threshold for Parallelism?",
      "options": [
        "На уровне запроса",
        "На уровне сервера (sp_configure)",
        "Только на уровне базы",
        "В плане бэкапа"
      ],
      "correct": 1,
      "explanation": "Cost Threshold for Parallelism — настройка сервера, определяющая порог стоимости для запуска параллелизма.",
      "difficulty": "medium"
    },
    {
      "id": 42,
      "question": "Какая особенность у MERGE?",
      "options": [
        "Никогда не вызывает блокировок",
        "Комплексный оператор UPSERT, требующий аккуратности из-за известных нюансов",
        "Только для in-memory",
        "Требует CLR"
      ],
      "correct": 1,
      "explanation": "MERGE объединяет INSERT/UPDATE/DELETE; необходимо тщательно тестировать из-за чувствительности к дубликатам и триггерам.",
      "difficulty": "medium"
    },
    {
      "id": 43,
      "question": "Что такое системно-версионируемые (temporal) таблицы?",
      "options": [
        "Только для временных данных",
        "Таблицы, автоматически сохраняющие историю изменений в связанной истории",
        "Таблицы только для чтения",
        "Таблицы без индексов"
      ],
      "correct": 1,
      "explanation": "Temporal таблицы поддерживают версионность строк с исторической таблицей для запросов на момент времени (AS OF).",
      "difficulty": "medium"
    },
    {
      "id": 44,
      "question": "Какое преимущество у Resumable Index Rebuild?",
      "options": [
        "Ускоряет бэкапы",
        "Позволяет приостанавливать и возобновлять перестроение индекса",
        "Отменяет фрагментацию",
        "Меняет колляцию"
      ],
      "correct": 1,
      "explanation": "Resumable Rebuild позволяет прервать и затем возобновить перестроение индекса, удобно для крупных объектов.",
      "difficulty": "medium"
    },
    {
      "id": 45,
      "question": "Чем Columnstore Batch Mode полезен?",
      "options": [
        "Для OLTP вставок",
        "Обрабатывает данные пакетами, снижая накладные расходы операторов",
        "Для шифрования",
        "Для CDC"
      ],
      "correct": 1,
      "explanation": "Batch Mode обрабатывает строки в пакетах, что уменьшает CPU и ускоряет аналитические запросы.",
      "difficulty": "medium"
    },
    {
      "id": 46,
      "question": "Что делает DBCC FREEPROCCACHE?",
      "options": [
        "Удаляет данные",
        "Очищает кэш планов выполнения",
        "Останавливает сервер",
        "Чинит индексы"
      ],
      "correct": 1,
      "explanation": "DBCC FREEPROCCACHE очищает кэш планов; используйте осторожно, возможны просадки производительности.",
      "difficulty": "medium"
    },
    {
      "id": 47,
      "question": "Как создать покрывающий индекс для запроса со SELECT ... WHERE A = ? AND возвращающий B, C?",
      "options": [
        "CREATE INDEX IX ON T(B, C) INCLUDE (A)",
        "CREATE INDEX IX ON T(A) INCLUDE (B, C)",
        "CREATE INDEX IX ON T(C, B)",
        "CREATE INDEX IX ON T(A, B, C) UNIQUE"
      ],
      "correct": 1,
      "explanation": "Ключ: A для фильтрации, включённые B, C для покрытия результата без обращения к таблице.",
      "difficulty": "medium"
    },
    {
      "id": 48,
      "question": "Что такое RLS (Row-Level Security)?",
      "options": [
        "Шифрование данных",
        "Ограничение доступа к строкам с помощью предикатных функций",
        "Резервное копирование строк",
        "Сжатие строк"
      ],
      "correct": 1,
      "explanation": "Row-Level Security позволяет ограничивать видимость строк, применяя предикатную функцию безопасности к запросам.",
      "difficulty": "medium"
    },
    {
      "id": 49,
      "question": "Чем Dynamic Data Masking отличается от шифрования?",
      "options": [
        "Это то же самое",
        "Маскирование — презентационный слой, не защищает данные в хранилище",
        "Маскирование — аппаратное шифрование",
        "Шифрование — презентационный слой"
      ],
      "correct": 1,
      "explanation": "DDM скрывает значения при чтении для определённых ролей, но не шифрует данные на диске или в бэкапах.",
      "difficulty": "medium"
    },
    {
      "id": 50,
      "question": "Что делает TDE (Transparent Data Encryption)?",
      "options": [
        "Шифрует только лог",
        "Шифрует файлы данных и лога на уровне файлов (в покое)",
        "Шифрует трафик",
        "Маскирует данные"
      ],
      "correct": 1,
      "explanation": "TDE шифрует файлы данных/журнала и бэкапы; данные в памяти и трафик не шифруются TDE.",
      "difficulty": "medium"
    },
    {
      "id": 51,
      "question": "Чем Always Encrypted отличается от TDE?",
      "options": [
        "Нет отличий",
        "Always Encrypted шифрует данные на стороне клиента, не раскрывая их серверу",
        "TDE шифрует трафик",
        "Always Encrypted — только для логов"
      ],
      "correct": 1,
      "explanation": "Always Encrypted обеспечивает шифрование чувствительных данных на клиенте; сервер хранит и обрабатывает зашифрованные значения.",
      "difficulty": "medium"
    },
    {
      "id": 52,
      "question": "Что такое Page/Row Compression?",
      "options": [
        "Сжатие только колонок",
        "Механизмы сжатия строк/страниц для экономии места и иногда ускорения IO",
        "Сжатие только логов",
        "Только для tempdb"
      ],
      "correct": 1,
      "explanation": "Row/Page compression уменьшают размер данных, снижая IO; CPU нагрузка может вырасти.",
      "difficulty": "medium"
    },
    {
      "id": 53,
      "question": "Что делает REBUILD индекса по сравнению с REORGANIZE?",
      "options": [
        "Ничего",
        "REBUILD перестраивает индекс полностью; REORGANIZE дефрагментирует постранично",
        "Оба одинаковы",
        "REORGANIZE удаляет индекс"
      ],
      "correct": 1,
      "explanation": "REBUILD создаёт индекс заново, может обновлять статистики; REORGANIZE выполняет онлайн-дефрагментацию листьев.",
      "difficulty": "medium"
    },
    {
      "id": 54,
      "question": "Как быстро определить наиболее нагруженные запросы по чтениям?",
      "options": [
        "sys.objects",
        "sys.dm_exec_query_stats c CROSS APPLY sys.dm_exec_sql_text",
        "sp_help",
        "sys.all_columns"
      ],
      "correct": 1,
      "explanation": "Используйте DMV sys.dm_exec_query_stats совместно с sys.dm_exec_sql_text для анализа логических чтений/времени.",
      "difficulty": "medium"
    },
    {
      "id": 55,
      "question": "Чем OUTER JOIN отличается от INNER JOIN?",
      "options": [
        "Ничем",
        "OUTER JOIN сохраняет строки одной стороны при отсутствии совпадений",
        "INNER JOIN сохраняет все строки",
        "OUTER JOIN удаляет дубликаты"
      ],
      "correct": 1,
      "explanation": "LEFT/RIGHT OUTER JOIN сохраняет строки левой/правой таблицы даже без совпадений, заполняя NULL.",
      "difficulty": "medium"
    },
    {
      "id": 56,
      "question": "Какой объект использовать для трассировки событий вместо Profiler?",
      "options": [
        "DBCC TRACEON",
        "Extended Events",
        "SQLMail",
        "Replication Monitor"
      ],
      "correct": 1,
      "explanation": "Extended Events — современный, малозатратный механизм трассировки событий, заменяющий SQL Trace/Profiler.",
      "difficulty": "medium"
    },
    {
      "id": 57,
      "question": "Что делает READ_COMMITTED_SNAPSHOT (RCSI) на уровне базы?",
      "options": [
        "Отключает блокировки",
        "Переводит READ COMMITTED на версионное чтение из tempdb",
        "Включает снапшот на сервере",
        "Увеличивает MAXDOP"
      ],
      "correct": 1,
      "explanation": "RCSI меняет поведение READ COMMITTED на чтение версий из tempdb, снижая блокировки читателей/писателей.",
      "difficulty": "medium"
    },
    {
      "id": 58,
      "question": "Что такое FORCESEEK?",
      "options": [
        "Хинт для сортировки",
        "Хинт, заставляющий использовать поиск по индексу вместо скана",
        "Хинт для партиций",
        "Хинт для сжатия"
      ],
      "correct": 1,
      "explanation": "FORCESEEK заставляет использовать оператор Index Seek при наличии подходящего индекса.",
      "difficulty": "medium"
    },
    {
      "id": 59,
      "question": "Как ограничить ресурсы для группы сессий?",
      "options": [
        "Database Mail",
        "Resource Governor",
        "Service Broker",
        "Log Shipping"
      ],
      "correct": 1,
      "explanation": "Resource Governor позволяет ограничивать CPU/IO/Memory для групп рабочих нагрузок.",
      "difficulty": "medium"
    },
    {
      "id": 60,
      "question": "Где хранятся планы выполнения?",
      "options": [
        "В tempdb таблицах",
        "В кэше планов в памяти (процедурный кэш)",
        "В журнале транзакций",
        "В системных индексах диска"
      ],
      "correct": 1,
      "explanation": "Кэш планов в памяти содержит скомпилированные планы до их вытеснения по давлению на память.",
      "difficulty": "medium"
    },
    {
      "id": 61,
      "question": "Что такое параметр FORCE_LAST_GOOD_PLAN в Query Store?",
      "options": [
        "Удаляет все планы",
        "Автоматически форсирует стабильный план при обнаружении регрессии",
        "Запрещает параллелизм",
        "Отключает Query Store"
      ],
      "correct": 1,
      "explanation": "Автотюнинг Query Store может форсировать предыдущий успешный план при регрессии производительности.",
      "difficulty": "hard"
    },
    {
      "id": 62,
      "question": "Чем latch отличается от lock?",
      "options": [
        "Это одно и то же",
        "Latch — внутренняя защита структур памяти/страниц; lock — логическая синхронизация транзакций",
        "Lock — быстрее",
        "Latch используется в журнале транзакций"
      ],
      "correct": 1,
      "explanation": "Латчи защищают внутренние структуры и не участвуют в изоляции транзакций; блокировки обеспечивают изоляцию уровней транзакций.",
      "difficulty": "hard"
    },
    {
      "id": 63,
      "question": "Что такое ghost records?",
      "options": [
        "Записи в журнале",
        "Помеченные к удалению строки, очищаемые фоновым процессом",
        "Сжатые строки",
        "Шифрованные строки"
      ],
      "correct": 1,
      "explanation": "Ghost records — логически удалённые строки, физически очищаемые позднее процессом ghost cleanup.",
      "difficulty": "hard"
    },
    {
      "id": 64,
      "question": "Сколько шагов в гистограмме статистики может хранить SQL Server?",
      "options": [
        "64",
        "200",
        "1024",
        "4096"
      ],
      "correct": 1,
      "explanation": "Гистограмма статистики содержит до 200 шагов, отражающих распределение значений.",
      "difficulty": "hard"
    },
    {
      "id": 65,
      "question": "Что даёт параметр 'Optimize for Ad hoc Workloads'?",
      "options": [
        "Увеличивает MAXDOP",
        "Сохраняет скомпилированные планы ad-hoc сначала в сжатом виде (stub)",
        "Отключает сжатие",
        "Ускоряет журналирование"
      ],
      "correct": 1,
      "explanation": "Опция уменьшает давление на кэш планов, сохраняя stub для одноразовых запросов до повторного использования.",
      "difficulty": "hard"
    },
    {
      "id": 66,
      "question": "Где настраивается Forced Parameterization и что она делает?",
      "options": [
        "На уровне сервера; отключает кэш",
        "На уровне базы; заставляет параметризовать запросы для повторного использования планов",
        "На уровне запроса; включает параллелизм",
        "В tempdb; ускоряет сортировки"
      ],
      "correct": 1,
      "explanation": "Forced Parameterization — настройка базы: оптимизатор выполняет параметризацию, повышая повторное использование планов.",
      "difficulty": "hard"
    },
    {
      "id": 67,
      "question": "Что такое 'spill to TempDB' в операторах Hash/SORT?",
      "options": [
        "Сжатие данных",
        "Выгрузка промежуточных данных на диск при нехватке памяти",
        "Шифрование tempdb",
        "Удаление статистик"
      ],
      "correct": 1,
      "explanation": "При недостатке grant памяти операторы разливаются в tempdb, что ухудшает производительность.",
      "difficulty": "hard"
    },
    {
      "id": 68,
      "question": "Как снизить контеншен в tempdb при высокой конкуренции?",
      "options": [
        "Добавить больше журналов",
        "Добавить несколько файлов tempdb одинакового размера и включить trace flags/параметры при необходимости",
        "Отключить tempdb",
        "Переключить в READ_ONLY"
      ],
      "correct": 1,
      "explanation": "Рекомендуется несколько равных по размеру файлов tempdb, что уменьшает горячие точки распределения страниц.",
      "difficulty": "hard"
    },
    {
      "id": 69,
      "question": "Что такое Write-Ahead Logging (WAL) в SQL Server?",
      "options": [
        "Сжатие логов",
        "Принцип записи в журнал до записи данных на диск",
        "Шифрование логов",
        "Очистка логов"
      ],
      "correct": 1,
      "explanation": "Сначала запись фиксируется в журнале транзакций, затем соответствующие страницы могут быть записаны в данные.",
      "difficulty": "hard"
    },
    {
      "id": 70,
      "question": "Что такое VLF (Virtual Log File) и почему их количество важно?",
      "options": [
        "Сегменты данных в tempdb",
        "Внутренние сегменты журнала; слишком много VLF замедляет операции восстановления и бэкапа",
        "Индексы журнала",
        "Статистики журнала"
      ],
      "correct": 1,
      "explanation": "VLF — части файла журнала; чрезмерное количество приводит к деградации некоторых операций.",
      "difficulty": "hard"
    },
    {
      "id": 71,
      "question": "Instant File Initialization влияет на что?",
      "options": [
        "На файлы журнала",
        "На файлы данных, ускоряя рост/создание за счёт пропуска нулевания",
        "На буферный пул",
        "На кэш планов"
      ],
      "correct": 1,
      "explanation": "IFI ускоряет операции с файлами данных; на файлы журнала не распространяется.",
      "difficulty": "hard"
    },
    {
      "id": 72,
      "question": "Какие ограничения у Always Encrypted при поиске?",
      "options": [
        "Нет ограничений",
        "Невозможность эффективного LIKE и неиндексируемость детерминированно зашифрованных выражений по шаблонам",
        "Нельзя читать",
        "Только для GUID"
      ],
      "correct": 1,
      "explanation": "Шифрование препятствует операциям по шаблонам и диапазонам; детерминированное шифрование поддерживает равенство, но не LIKE/диапазоны.",
      "difficulty": "hard"
    },
    {
      "id": 73,
      "question": "Как работает Row Versioning в SNAPSHOT/RCSI?",
      "options": [
        "Записывает версии в master",
        "Хранит старые версии строк в tempdb для изоляции читателей",
        "Сжимает индексы",
        "Меняет MAXDOP"
      ],
      "correct": 1,
      "explanation": "Версии строк сохраняются в tempdb и используются для чтения согласованного снимка без блокировок.",
      "difficulty": "hard"
    },
    {
      "id": 74,
      "question": "Что такое план-гайды (Plan Guides)?",
      "options": [
        "Бэкапы планов",
        "Механизм принудительного применения хинтов к запросам без изменения кода",
        "Шифрование планов",
        "Удаление планов"
      ],
      "correct": 1,
      "explanation": "Plan Guides позволяют навязывать хинты/параметры компиляции конкретным запросам.",
      "difficulty": "hard"
    },
    {
      "id": 75,
      "question": "Какой параметр влияет на версию кардинального оценщика (CE) для запроса?",
      "options": [
        "DBCC DROPCLEANBUFFERS",
        "USE HINT('QUERY_OPTIMIZER_COMPATIBILITY_LEVEL_150')",
        "SET NOCOUNT ON",
        "DBCC CHECKIDENT"
      ],
      "correct": 1,
      "explanation": "Хинт QUERY_OPTIMIZER_COMPATIBILITY_LEVEL_X позволяет задать CE независимо от уровня совместимости базы.",
      "difficulty": "hard"
    },
    {
      "id": 76,
      "question": "Чем отличается CDC от Change Tracking?",
      "options": [
        "CDC быстрее",
        "CDC пишет детали изменений и данные в системные таблицы; CT отслеживает факты изменений без хранения старых значений",
        "CT хранит все версии",
        "Нет отличий"
      ],
      "correct": 1,
      "explanation": "CDC фиксирует вставки/удаления/старые/новые значения; CT — лёгкий механизм, показывающий что и когда изменилось.",
      "difficulty": "hard"
    },
    {
      "id": 77,
      "question": "Какой тип репликации лучше для почти реального времени и низкой задержки?",
      "options": [
        "Снимковая (Snapshot)",
        "Транзакционная (Transactional)",
        "Слияния (Merge)",
        "Лог шиппинг"
      ],
      "correct": 1,
      "explanation": "Транзакционная репликация обеспечивает низкую задержку доставки изменений подписчикам.",
      "difficulty": "hard"
    },
    {
      "id": 78,
      "question": "Что обеспечивает синхронная реплика в Always On AG?",
      "options": [
        "Минимальные задержки",
        "Подтверждение записи на вторичной реплике перед фиксацией на первичной",
        "Шифрование трафика",
        "Автоиндексацию"
      ],
      "correct": 1,
      "explanation": "В синхронном режиме коммит на первичной ожидает подтверждения записи на вторичной для консистентности.",
      "difficulty": "hard"
    },
    {
      "id": 79,
      "question": "Что такое переключение партиции (Partition Switch)?",
      "options": [
        "Репликация",
        "Метаданные операция перемещения секции между таблицами/индексами",
        "Сжатие секций",
        "Шифрование секций"
      ],
      "correct": 1,
      "explanation": "ALTER TABLE ... SWITCH PARTITION выполняет быструю метаданную операцию перемещения секции.",
      "difficulty": "hard"
    },
    {
      "id": 80,
      "question": "Как восстановить только повреждённую страницу данных?",
      "options": [
        "DBCC REPAIR_ALLOW_DATA_LOSS",
        "Page Restore из бэкапа при наличии полного/лог-бэкапов",
        "TRUNCATE TABLE",
        "ALTER DATABASE SET SINGLE_USER"
      ],
      "correct": 1,
      "explanation": "Page Restore позволяет восстановить отдельные страницы при полной цепочке бэкапов.",
      "difficulty": "hard"
    },
    {
      "id": 81,
      "question": "В чём особенность ONLINE INDEX REBUILD?",
      "options": [
        "Не блокирует вообще",
        "Минимизирует блокировки DML чтения/записи, но возможны короткие блокировки метаданных",
        "Только для heap",
        "Отключает триггеры"
      ],
      "correct": 1,
      "explanation": "ONLINE rebuild допускает конкурентный доступ, за исключением кратких блокировок схемы/метаданных.",
      "difficulty": "hard"
    },
    {
      "id": 82,
      "question": "Как включить инкрементальные статистики на партиционированной таблице?",
      "options": [
        "ALTER INDEX",
        "CREATE/UPDATE STATISTICS ... WITH INCREMENTAL = ON",
        "DBCC CHECKDB",
        "ALTER DATABASE SET INCREMENTAL"
      ],
      "correct": 1,
      "explanation": "Инкрементальные статистики создаются/обновляются с опцией INCREMENTAL = ON для партиционированных объектов.",
      "difficulty": "hard"
    },
    {
      "id": 83,
      "question": "Какие преимущества у Sparse Columns?",
      "options": [
        "Ускоряют сортировки",
        "Экономят место при большом количестве NULL",
        "Ускоряют Always On",
        "Ускоряют CDC"
      ],
      "correct": 1,
      "explanation": "Sparse Columns эффективны при высоком проценте NULL-значений, снижая потребление хранения.",
      "difficulty": "hard"
    },
    {
      "id": 84,
      "question": "Что такое Delta Store в Columnstore?",
      "options": [
        "Хранилище логов",
        "Строковое хранилище вставок, позже уплотняемое в сжатые столбцовые сегменты",
        "Сжатие строк",
        "Буферный пул"
      ],
      "correct": 1,
      "explanation": "Delta Store — промежуточное строковое хранилище для недавно вставленных строк до сжатия в сегменты.",
      "difficulty": "hard"
    },
    {
      "id": 85,
      "question": "Что обеспечивает сегмент-элиминация (Segment Elimination) в Columnstore?",
      "options": [
        "Сжатие логов",
        "Пропуск чтения сегментов по статистике минимума/максимума значений",
        "Удаление NULL",
        "Автопараллелизм"
      ],
      "correct": 1,
      "explanation": "Сегменты содержат min/max; несоответствующие сегменты пропускаются, уменьшая IO.",
      "difficulty": "hard"
    },
    {
      "id": 86,
      "question": "Чем Heap отличается от таблицы с кластерным индексом?",
      "options": [
        "Наличием кластерного ключа",
        "Heap не имеет кластерного индекса; строки не упорядочены",
        "Heap всегда быстрее",
        "Heap хранится только в tempdb"
      ],
      "correct": 1,
      "explanation": "Heap — таблица без кластерного индекса; возможны forwarding-указатели при обновлениях переменной длины.",
      "difficulty": "hard"
    },
    {
      "id": 87,
      "question": "Что такое Forwarded Records и где встречаются?",
      "options": [
        "В журнале",
        "В heap при обновлении строк переменной длины с перемещением на другую страницу",
        "В кластерных индексах",
        "В tempdb только"
      ],
      "correct": 1,
      "explanation": "В heap возможны пересылки (forwarding) — указатели с прежнего места на новое размещение строки, ухудшая чтение.",
      "difficulty": "hard"
    },
    {
      "id": 88,
      "question": "Что такое Memory Grant и где его видно?",
      "options": [
        "Выделение памяти для серверных ролей",
        "Память, выделяемая запросу для операторов (Hash/Sort), видна в плане и DMV",
        "Память буферного пула",
        "Память CLR"
      ],
      "correct": 1,
      "explanation": "Memory Grant — объём памяти на запрос для операторов; недооценка ведёт к spill, переоценка — к простаиванию.",
      "difficulty": "hard"
    },
    {
      "id": 89,
      "question": "Что такое Query Hash/Plan Hash?",
      "options": [
        "Контрольная сумма данных",
        "Хэши нормализованного текста запроса/плана для агрегации статистики",
        "Хэши имени индекса",
        "Хэши файла"
      ],
      "correct": 1,
      "explanation": "Query/Plan Hash используются в DMV для группировки запросов/планов независимо от параметров.",
      "difficulty": "hard"
    },
    {
      "id": 90,
      "question": "Как минимизировать эскалацию блокировок?",
      "options": [
        "Включить NOLOCK",
        "Дробить операции батчами, использовать хинты/трейсы осторожно",
        "Увеличить PAGE_SIZE",
        "Сжать данные"
      ],
      "correct": 1,
      "explanation": "Разбиение больших модификаций на партии и корректная стратегия индексации снижают вероятность эскалации до таблицы.",
      "difficulty": "hard"
    },
    {
      "id": 91,
      "question": "Как работает Ownership Chaining?",
      "options": [
        "Передаёт права между серверами",
        "Если объекты имеют одного владельца, проверка прав может не требоваться на каждом шаге",
        "Шифрует процедуры",
        "Блокирует транзакции"
      ],
      "correct": 1,
      "explanation": "Цепочка владения позволяет вызывать объекты без явной проверки прав на каждый объект при совпадении владельца.",
      "difficulty": "hard"
    },
    {
      "id": 92,
      "question": "Чем Service Broker полезен?",
      "options": [
        "Для бэкапов",
        "Асинхронные надёжные очереди сообщений внутри SQL Server",
        "Для репликации",
        "Для индексации"
      ],
      "correct": 1,
      "explanation": "Service Broker реализует очереди/диалоги для асинхронной обработки внутри СУБД с гарантией доставки.",
      "difficulty": "hard"
    },
    {
      "id": 93,
      "question": "Что даёт Contained Database?",
      "options": [
        "Больше файлов",
        "Упрощает перенос, позволяя логинам/пользователям быть локальными для базы",
        "Сжатие логов",
        "Ускоряет сортировки"
      ],
      "correct": 1,
      "explanation": "Contained Database минимизирует зависимость от серверных логинов и настроек, упрощая миграцию.",
      "difficulty": "hard"
    },
    {
      "id": 94,
      "question": "Чем отличается Transparent Data Encryption от шифрования на уровне столбцов (Cell-level)?",
      "options": [
        "Ничем",
        "TDE — шифрование на уровне файлов; шифрование столбцов — на уровне значений",
        "Оба на уровне значений",
        "Оба шифруют трафик"
      ],
      "correct": 1,
      "explanation": "TDE шифрует файлы/бэкапы; шифрование столбцов (старый подход) шифрует данные в конкретных столбцах.",
      "difficulty": "hard"
    },
    {
      "id": 95,
      "question": "Какая роль у Database Master Key и Certificate при TDE?",
      "options": [
        "Не используются",
        "DMK защищает сертификат, который защищает Database Encryption Key",
        "Сертификат шифрует буферный пул",
        "DMK хранит данные"
      ],
      "correct": 1,
      "explanation": "Иерархия: Service Master Key -> Database Master Key -> Certificate -> Database Encryption Key (TDE).",
      "difficulty": "hard"
    },
    {
      "id": 96,
      "question": "Что такое resumable online index create и когда полезен?",
      "options": [
        "Создание индекса для tempdb",
        "Создание индекса с возможностью паузы/возобновления — полезно для больших объектов",
        "Создание индекса без логирования",
        "Создание индекса без блокировок вообще"
      ],
      "correct": 1,
      "explanation": "Resumable create/rebuild позволяет прерывать долгие операции индексации и возобновлять позже.",
      "difficulty": "hard"
    },
    {
      "id": 97,
      "question": "Чем JSON поддержка в SQL Server ограничена?",
      "options": [
        "Нет ограничений",
        "Нет отдельного JSON-типа; JSON хранится в NVARCHAR и обрабатывается функциями OPENJSON/JSON_VALUE",
        "JSON хранится как бинарный тип",
        "JSON требует CLR"
      ],
      "correct": 1,
      "explanation": "SQL Server не имеет нативного JSON-типа; используется NVARCHAR и набор функций JSON_*.",
      "difficulty": "hard"
    },
    {
      "id": 98,
      "question": "Для чего нужны графовые таблицы (Graph Tables)?",
      "options": [
        "Для колонночного хранения",
        "Для моделирования вершин/рёбер и графовых запросов MATCH",
        "Для CDC",
        "Для репликации"
      ],
      "correct": 1,
      "explanation": "Graph Tables добавляют сущности узлов/рёбер и синтаксис MATCH для графовых сценариев.",
      "difficulty": "hard"
    },
    {
      "id": 99,
      "question": "Что такое natively compiled procedures в In-Memory OLTP?",
      "options": [
        "Обычные процедуры",
        "Процедуры, компилируемые в машинный код для работы с memory-optimized таблицами",
        "CLR-процедуры",
        "Процедуры для JSON"
      ],
      "correct": 1,
      "explanation": "Natively compiled процедуры оптимизированы для In-Memory таблиц, компилируются в машинный код, обеспечивая низкую задержку.",
      "difficulty": "hard"
    },
    {
      "id": 100,
      "question": "Какой тип индекса в In-Memory OLTP выбрать для точных равенств на уникальном ключе?",
      "options": [
        "Range индекс",
        "Hash индекс с подходящим bucket count",
        "Columnstore индекс",
        "XML индекс"
      ],
      "correct": 1,
      "explanation": "Hash-индексы эффективны для операций равенства, важно правильно подобрать количество корзин.",
      "difficulty": "hard"
    }
  ]
}