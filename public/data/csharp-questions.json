{
  "version": "1.1.0",
  "lastUpdated": "2025-11-15",
  "category": "csharp",
  "questions": [
    {
      "id": 1,
      "question": "Какой модификатор доступа по умолчанию у членов класса в C#?",
      "options": ["public", "private", "protected", "internal"],
      "correct": 1,
      "explanation": "По умолчанию члены класса имеют модификатор private и доступны только внутри класса.",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Что делает ключевое слово var?",
      "options": [
        "Определяет динамический тип во время выполнения",
        "Выполняет вывод статического типа на этапе компиляции",
        "Делает переменную глобальной",
        "Делает переменную неизменяемой"
      ],
      "correct": 1,
      "explanation": "var выполняет вывод статического типа компилятором, тип остаётся строго статическим.",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "Что делает оператор using (стейтмент) в C#?",
      "options": [
        "Подключает пространство имён",
        "Гарантирует вызов Dispose у объекта по выходу из блока",
        "Создаёт новый поток",
        "Отключает сборку мусора"
      ],
      "correct": 1,
      "explanation": "using-стейтмент гарантирует вызов Dispose для IDisposable-объекта при выходе из блока, даже при исключениях.",
      "difficulty": "easy"
    },
    {
      "id": 4,
      "question": "Что возвращает оператор is?",
      "options": ["Тип значения переменной", "Булево значение совместимости с типом", "Хэш-код объекта", "Размер типа в байтах"],
      "correct": 1,
      "explanation": "Оператор is возвращает true/false, проверяя совместимость объекта с типом (включая pattern matching).",
      "difficulty": "easy"
    },
    {
      "id": 5,
      "question": "Для чего используется string interpolation ($\"...\")?",
      "options": [
        "Для конкатенации строк в рантайме без форматирования",
        "Для безопасного HTML-энкодинга",
        "Для удобного форматирования строк с подстановкой выражений",
        "Для компиляции строк в выражения"
      ],
      "correct": 2,
      "explanation": "Интерполяция строк позволяет подставлять выражения в строку с форматированием.",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "Чем отличается const от readonly?",
      "options": [
        "const назначается в рантайме, readonly — в компиляции",
        "const вычисляется на этапе компиляции, readonly — в рантайме",
        "Они полностью идентичны",
        "readonly только для значимых типов"
      ],
      "correct": 1,
      "explanation": "const требует константного выражения на этапе компиляции, readonly может инициализироваться в конструкторе (рантайм).",
      "difficulty": "easy"
    },
    {
      "id": 7,
      "question": "Какой тип у литерала \"text\" в C#?",
      "options": ["char", "ReadOnlySpan<char>", "string", "object"],
      "correct": 2,
      "explanation": "Строковый литерал имеет тип string (System.String).",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Какой интерфейс реализует перечисление IEnumerator<T>?",
      "options": ["IEnumerable<T>", "IDisposable", "IComparable<T>", "ICloneable"],
      "correct": 1,
      "explanation": "IEnumerator<T> реализует IDisposable для корректного освобождения ресурсов при перечислении.",
      "difficulty": "easy"
    },
    {
      "id": 9,
      "question": "Что делает ключевое слово static у члена класса?",
      "options": [
        "Делает член доступным только для экземпляров",
        "Препятствует наследованию",
        "Связывает член с типом, а не экземпляром",
        "Делает член приватным"
      ],
      "correct": 2,
      "explanation": "static связывает член с типом, общий для всех экземпляров и доступный без создания объекта.",
      "difficulty": "easy"
    },
    {
      "id": 10,
      "question": "Что такое nullable-значимый тип в C#?",
      "options": [
        "Ссылочный тип, допускающий null",
        "Значимый тип с возможностью хранения null через Nullable<T>",
        "Любой тип с атрибутом [Nullable]",
        "Это dynamic"
      ],
      "correct": 1,
      "explanation": "Nullable<T> (синтаксис T?) позволяет значимому типу хранить отсутствие значения (null).",
      "difficulty": "easy"
    },

    {
      "id": 11,
      "question": "Чем отличается class от struct?",
      "options": [
        "struct — ссылочный тип, class — значимый",
        "Оба ссылочные типы",
        "class — ссылочный тип, struct — значимый",
        "Оба значимые типы"
      ],
      "correct": 2,
      "explanation": "class — ссылочный тип (в куче), struct — значимый (обычно на стеке или внутри содержащего типа).",
      "difficulty": "medium"
    },
    {
      "id": 12,
      "question": "Для чего нужны extension-методы?",
      "options": [
        "Чтобы наследовать sealed классы",
        "Чтобы добавить методы к существующим типам без наследования",
        "Чтобы перегрузить операторы",
        "Чтобы изменить приватные члены типов"
      ],
      "correct": 1,
      "explanation": "Extension-методы позволяют добавлять методы к типам без изменения их исходного кода и без наследования.",
      "difficulty": "medium"
    },
    {
      "id": 13,
      "question": "Что делает ключевое слово async в сигнатуре метода?",
      "options": [
        "Создаёт новый поток",
        "Позволяет использовать await и генерирует state machine",
        "Делает метод неблокирующим гарантированно",
        "Запрещает исключения"
      ],
      "correct": 1,
      "explanation": "async позволяет использовать await; компилятор строит state machine. Новый поток не создаётся автоматически.",
      "difficulty": "medium"
    },
    {
      "id": 14,
      "question": "Как корректно отменять асинхронные операции?",
      "options": [
        "Через Thread.Abort",
        "Через CancellationToken",
        "Через GC.Collect",
        "Это невозможно"
      ],
      "correct": 1,
      "explanation": "Стандартный механизм отмены — пробрасывание CancellationToken и его проверка/прерывание.",
      "difficulty": "medium"
    },
    {
      "id": 15,
      "question": "Чем отличается IEnumerable<T> от IQueryable<T>?",
      "options": [
        "IEnumerable<T> формирует выражение запроса, IQueryable<T> — перечисляет",
        "IQueryable<T> описывает выражение, исполняемое провайдером (отложенно)",
        "Это одно и то же",
        "IQueryable<T> работает только с файлами"
      ],
      "correct": 1,
      "explanation": "IQueryable<T> представляет выражение для провайдера (например, БД), IEnumerable<T> — перечисление в памяти.",
      "difficulty": "medium"
    },
    {
      "id": 16,
      "question": "Где хранится замыкание (captured variables) лямбды?",
      "options": ["В стеке", "В выделенном объекте диспетчера замыканий (куча)", "В регистре CPU", "В атрибутах метода"],
      "correct": 1,
      "explanation": "Захваченные переменные хранятся в сгенерированном объекте (closure) в куче.",
      "difficulty": "medium"
    },
    {
      "id": 17,
      "question": "Что делает оператор ?? (null-coalescing)?",
      "options": [
        "Вызывает исключение при null",
        "Возвращает левый операнд, если он не null, иначе правый",
        "Преобразует тип в nullable",
        "Удаляет null из коллекции"
      ],
      "correct": 1,
      "explanation": "Оператор ?? возвращает значение по умолчанию, если слева null.",
      "difficulty": "medium"
    },
    {
      "id": 18,
      "question": "Что такое record в C#?",
      "options": [
        "Тип для небезопасного кода",
        "Синтаксический сахар для анонимных типов",
        "Ссылочный (или значимый) тип с семантикой равенства по значению",
        "Специальный тип для БД"
      ],
      "correct": 2,
      "explanation": "record — тип с равенством по содержимому (value-based equality), поддерживает with-выражения.",
      "difficulty": "medium"
    },
    {
      "id": 19,
      "question": "Чем отличается override от new при переопределении метода?",
      "options": [
        "override скрывает метод базового класса",
        "new переопределяет виртуальный метод",
        "override переопределяет virtual, new скрывает (hides) метод",
        "Они эквивалентны"
      ],
      "correct": 2,
      "explanation": "override переопределяет virtual/abstract; new — скрывает член базового класса при совпадении сигнатуры.",
      "difficulty": "medium"
    },
    {
      "id": 20,
      "question": "Как избежать утечек при событиях .NET?",
      "options": [
        "Не отписываться — GC сам разберётся",
        "Использовать слабые ссылки или явно отписываться",
        "Использовать dynamic",
        "Вызывать GC.Collect после события"
      ],
      "correct": 1,
      "explanation": "Подписчик удерживается издателем; важно отписываться или применять слабые события/паттерны.",
      "difficulty": "medium"
    },
    {
      "id": 21,
      "question": "Где корректнее хранить общий HttpClient?",
      "options": [
        "Создавать новый на каждый запрос",
        "Переиспользовать долгоживущий экземпляр/Factory",
        "Wrap в using для каждого вызова",
        "Использовать WebRequest вместо него"
      ],
      "correct": 1,
      "explanation": "Рекомендуется переиспользовать HttpClient или использовать IHttpClientFactory, чтобы избежать сокет-исчерпания.",
      "difficulty": "medium"
    },
    {
      "id": 22,
      "question": "Что делает ConfigureAwait(false)?",
      "options": [
        "Запрещает ожидание",
        "Не захватывает SynchronizationContext при продолжении",
        "Создаёт новый поток",
        "Гарантирует UI-контекст"
      ],
      "correct": 1,
      "explanation": "ConfigureAwait(false) сообщает не возвращаться в исходный контекст (UI/ASP.NET) после await.",
      "difficulty": "medium"
    },
    {
      "id": 23,
      "question": "Чем отличается Task.Run от Task.Factory.StartNew по умолчанию?",
      "options": [
        "Ничем не отличается",
        "Task.Run оптимизирован для CPU-bound и использует стандартные параметры",
        "StartNew всегда долгоживущий",
        "Run создаёт новый поток вне пула"
      ],
      "correct": 1,
      "explanation": "Task.Run — удобный шорткат для пула потоков с безопасными дефолтами, StartNew требует явной конфигурации.",
      "difficulty": "medium"
    },
    {
      "id": 24,
      "question": "Что такое span в C# (Span<T>)?",
      "options": [
        "Ссылочный тип для потоков",
        "Структура, представляющая непрерывный участок памяти с безопасными срезами",
        "Класс для JSON",
        "Особый тип исключений"
      ],
      "correct": 1,
      "explanation": "Span<T> — ref struct для безопасного доступа к непрерывным участкам памяти без выделений.",
      "difficulty": "medium"
    },
    {
      "id": 25,
      "question": "Чем отличаются ref и out параметры?",
      "options": [
        "ref требует инициализации до вызова, out — нет",
        "out требует инициализации до вызова, ref — нет",
        "Они эквивалентны",
        "out для ссылочных типов, ref — для значимых"
      ],
      "correct": 0,
      "explanation": "ref — аргумент должен быть инициализирован; out — должен быть присвоен в методе.",
      "difficulty": "medium"
    },
    {
      "id": 26,
      "question": "Что такое CancellationTokenSource?",
      "options": [
        "Токен отмены",
        "Источник, создающий и сигналящий токен отмены",
        "Таймер",
        "Провайдер потоков"
      ],
      "correct": 1,
      "explanation": "CTS создаёт CancellationToken и управляет сигналом отмены для связанных операций.",
      "difficulty": "medium"
    },
    {
      "id": 27,
      "question": "Что делает оператор ??= ?",
      "options": [
        "Присваивает null левому операнду",
        "Присваивает правый операнд, если левый равен null",
        "Сравнивает на равенство",
        "Удаляет null"
      ],
      "correct": 1,
      "explanation": "Оператор ??= присваивает значение справа только если слева null.",
      "difficulty": "medium"
    },
    {
      "id": 28,
      "question": "Для чего нужен lock?",
      "options": [
        "Запускает асинхронную операцию",
        "Предотвращает одновременный доступ нескольких потоков к критической секции",
        "Останавливает процесс",
        "Гарантирует отсутствие исключений"
      ],
      "correct": 1,
      "explanation": "lock (Monitor) обеспечивает взаимное исключение при доступе к разделяемым ресурсам.",
      "difficulty": "medium"
    },
    {
      "id": 29,
      "question": "Что такое boxing в C#?",
      "options": [
        "Преобразование ссылочного типа в значимый",
        "Упаковка значимого типа в объект (ссылочный тип)",
        "Удаление объекта",
        "Оптимизация JIT"
      ],
      "correct": 1,
      "explanation": "Boxing упаковывает значение (например, int) в object, приводит к выделению в куче.",
      "difficulty": "medium"
    },
    {
      "id": 30,
      "question": "Какой тип у выражения nameof(x)?",
      "options": ["char[]", "string", "ReadOnlySpan<char>", "object"],
      "correct": 1,
      "explanation": "nameof возвращает строку с именем символа/типа/члена при компиляции.",
      "difficulty": "medium"
    },
    {
      "id": 31,
      "question": "Что делает ключевое слово sealed?",
      "options": [
        "Делает класс абстрактным",
        "Запрещает наследование от класса или переопределение метода",
        "Делает методы приватными",
        "Включает небезопасный код"
      ],
      "correct": 1,
      "explanation": "sealed запрещает наследование (для класса) или дальнейшее переопределение (для метода).",
      "difficulty": "medium"
    },
    {
      "id": 32,
      "question": "Чем отличается throw от throw ex в catch?",
      "options": [
        "Одинаково сохраняют стек",
        "throw пересбрасывает с сохранением стека, throw ex сбрасывает стек",
        "throw ex безопаснее",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "throw сохраняет исходный стек, throw ex перезаписывает точку возникновения исключения.",
      "difficulty": "medium"
    },
    {
      "id": 33,
      "question": "Какое назначение using-директивы (using Namespace;)?",
      "options": [
        "Освобождение ресурсов",
        "Упрощение ссылок на типы из пространства имён",
        "Компиляция в одиночный модуль",
        "Создание алиасов методов"
      ],
      "correct": 1,
      "explanation": "using-директива упрощает доступ к типам в пространстве имён без полного имени.",
      "difficulty": "medium"
    },
    {
      "id": 34,
      "question": "Чем отличается IEnumerable<T> от List<T>?",
      "options": [
        "IEnumerable<T> — коллекция со случайным доступом",
        "IEnumerable<T> — интерфейс перечисления, List<T> — конкретная коллекция",
        "List<T> — интерфейс, IEnumerable<T> — класс",
        "Нет отличий"
      ],
      "correct": 1,
      "explanation": "IEnumerable<T> задаёт контракт перечисления, List<T> — реализация динамического массива.",
      "difficulty": "medium"
    },
    {
      "id": 35,
      "question": "Какой тип исключений предназначен для отмены?",
      "options": [
        "OperationCanceledException",
        "InvalidOperationException",
        "TimeoutException",
        "TaskCanceledException нельзя использовать"
      ],
      "correct": 0,
      "explanation": "Отмена стандартно сигнализируется через OperationCanceledException/TaskCanceledException.",
      "difficulty": "medium"
    },
    {
      "id": 36,
      "question": "Что вернёт Dictionary<TKey,TValue>[key] при отсутствии ключа?",
      "options": [
        "null",
        "Исключение KeyNotFoundException",
        "Значение по умолчанию",
        "false"
      ],
      "correct": 1,
      "explanation": "Индексатор Dictionary бросает KeyNotFoundException при отсутствии ключа.",
      "difficulty": "medium"
    },
    {
      "id": 37,
      "question": "Для чего нужны атрибуты (Attributes) в C#?",
      "options": [
        "Для JIT-компиляции",
        "Для добавления метаданных к программным элементам",
        "Для выделения памяти",
        "Для оптимизации IL"
      ],
      "correct": 1,
      "explanation": "Атрибуты добавляют метаданные, используемые рантаймом, рефлексией и инструментами.",
      "difficulty": "medium"
    },
    {
      "id": 38,
      "question": "Чем отличается DateTime от DateTimeOffset?",
      "options": [
        "DateTimeOffset хранит смещение от UTC, DateTime — нет",
        "DateTime всегда UTC",
        "DateTimeOffset работает только в Linux",
        "Нет отличий"
      ],
      "correct": 0,
      "explanation": "DateTimeOffset инкапсулирует момент времени и смещение от UTC, избегая неоднозначностей часовых поясов.",
      "difficulty": "medium"
    },
    {
      "id": 39,
      "question": "Что делает оператора => в объявлениях членов?",
      "options": [
        "Обозначает лямбда-выражение или выражение-член",
        "Является оператором сравнения",
        "Создаёт кортеж",
        "Объявляет индексатор"
      ],
      "correct": 0,
      "explanation": "=> используется для лямбд и для членов, определяемых выражением (expression-bodied members).",
      "difficulty": "medium"
    },
    {
      "id": 40,
      "question": "Какой паттерн предпочтителен для одноразовых ресурсов?",
      "options": [
        "IDisposable + using",
        "Singleton",
        "Factory",
        "Observer"
      ],
      "correct": 0,
      "explanation": "Для детерминированного освобождения ресурсов реализуют IDisposable и используют using.",
      "difficulty": "medium"
    },
    {
      "id": 41,
      "question": "Что делает оператор ?. (null-conditional)?",
      "options": [
        "Бросает исключение при null",
        "Возвращает null вместо обращения к члену, если объект равен null",
        "Заменяет null на пустую строку",
        "Вызывает Dispose при null"
      ],
      "correct": 1,
      "explanation": "?. предотвращает NullReferenceException, возвращая null для результата цепочки.",
      "difficulty": "medium"
    },
    {
      "id": 42,
      "question": "Где уместно применять async void?",
      "options": [
        "Везде для упрощения",
        "В обработчиках событий",
        "В методах библиотек",
        "В контроллерах ASP.NET"
      ],
      "correct": 1,
      "explanation": "async void стоит использовать только для обработчиков событий; иначе — возвращать Task/Task<T>.",
      "difficulty": "medium"
    },
    {
      "id": 43,
      "question": "Как избежать лишних аллокаций при конкатенации строк в цикле?",
      "options": [
        "Использовать +",
        "Использовать StringBuilder",
        "Использовать string.Intern",
        "Вызывать GC.Collect"
      ],
      "correct": 1,
      "explanation": "StringBuilder минимизирует аллокации при множественных соединениях строк.",
      "difficulty": "medium"
    },
    {
      "id": 44,
      "question": "Что возвращает оператор as при невозможности приведения?",
      "options": ["Исключение", "null", "false", "default(T) для T"] ,
      "correct": 1,
      "explanation": "as возвращает null при неудачном привидении к ссылочному или nullable типу.",
      "difficulty": "medium"
    },
    {
      "id": 45,
      "question": "Как добавить метод расширения?",
      "options": [
        "В любом классе",
        "В статическом классе со статическим методом и первым параметром this",
        "В интерфейсе",
        "В record"
      ],
      "correct": 1,
      "explanation": "Extension-метод — статический метод в статическом классе, первый параметр помечен this T.",
      "difficulty": "medium"
    },
    {
      "id": 46,
      "question": "Что такое expression tree (Expression<TDelegate>)?",
      "options": [
        "Выполняемая лямбда",
        "Дерево, описывающее выражение для анализа/трансляции",
        "Массив байтов",
        "IL-код"
      ],
      "correct": 1,
      "explanation": "Expression деревья представляют выражения как структуру данных, которая может быть проанализирована или скомпилирована.",
      "difficulty": "medium"
    },
    {
      "id": 47,
      "question": "Какая разница между First и FirstOrDefault в LINQ?",
      "options": [
        "Оба бросают при отсутствии",
        "First бросает исключение, FirstOrDefault возвращает default",
        "FirstOrDefault быстрее всегда",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "First требует хотя бы один элемент, FirstOrDefault возвращает default(T) при пустой последовательности.",
      "difficulty": "medium"
    },
    {
      "id": 48,
      "question": "Для чего служит interface IDisposable?",
      "options": [
        "Для управления потоками",
        "Для детерминированного освобождения неуправляемых/управляемых ресурсов",
        "Для сериализации",
        "Для логирования"
      ],
      "correct": 1,
      "explanation": "IDisposable определяет метод Dispose для явного освобождения ресурсов.",
      "difficulty": "medium"
    },
    {
      "id": 49,
      "question": "Что такое default literal (default)?",
      "options": [
        "Всегда null",
        "Литерал, означающий значение по умолчанию для контекстного типа",
        "Литерал для нулевого значения",
        "Запрещён в generic"
      ],
      "correct": 1,
      "explanation": "default без типа принимает значение по умолчанию контекста (например, default(int) == 0).",
      "difficulty": "medium"
    },
    {
      "id": 50,
      "question": "Какое назначение ключевого слова volatile?",
      "options": [
        "Запрещает JIT",
        "Обеспечивает, что поле читается/пишется напрямую, минуя кэш регистров/оптимизации",
        "Делает поле неизменным",
        "Создаёт блокировку"
      ],
      "correct": 1,
      "explanation": "volatile запрещает определённые оптимизации и обеспечивает видимость изменений между потоками.",
      "difficulty": "medium"
    },
    {
      "id": 51,
      "question": "Чем отличается internal от protected internal?",
      "options": [
        "internal — доступ из любого места",
        "protected internal — доступ либо из сборки, либо из наследников",
        "protected internal — только из наследников в одной сборке",
        "Они одинаковы"
      ],
      "correct": 1,
      "explanation": "protected internal — объединение: доступ либо из текущей сборки, либо из наследников (в любой сборке).",
      "difficulty": "medium"
    },
    {
      "id": 52,
      "question": "Как избежать deadlock в UI-коде с await?",
      "options": [
        "Использовать .Result",
        "Использовать ConfigureAwait(false) в библиотечном коде и не блокировать Result/Wait",
        "Вызывать GC.Collect",
        "Запретить async"
      ],
      "correct": 1,
      "explanation": "Не блокировать асинхронный код синхронно; в библиотечном коде использовать ConfigureAwait(false).",
      "difficulty": "medium"
    },
    {
      "id": 53,
      "question": "Что такое PLINQ?",
      "options": [
        "Параллельный LINQ для параллельной обработки коллекций",
        "LINQ для PostgreSQL",
        "LINQ для файлов",
        "Библиотека сериализации"
      ],
      "correct": 0,
      "explanation": "PLINQ позволяет параллелить операции LINQ над коллекциями при подходящих задачах.",
      "difficulty": "medium"
    },
    {
      "id": 54,
      "question": "Что делает Interlocked.Increment(ref x)?",
      "options": [
        "Увеличивает без потокобезопасности",
        "Атомарно увеличивает значение",
        "Блокирует поток",
        "Создаёт новый int"
      ],
      "correct": 1,
      "explanation": "Interlocked обеспечивает атомарные операции для примитивов без явных блокировок.",
      "difficulty": "medium"
    },
    {
      "id": 55,
      "question": "Зачем нужен CancellationToken.ThrowIfCancellationRequested()?",
      "options": [
        "Для игнорирования отмены",
        "Для выброса OperationCanceledException при запросе отмены",
        "Для логирования",
        "Для освобождения ресурсов"
      ],
      "correct": 1,
      "explanation": "Метод бросает OperationCanceledException, корректно сигнализируя отмену вверх по стеку.",
      "difficulty": "medium"
    },

    {
      "id": 56,
      "question": "Что такое SynchronizationContext и как он влияет на await?",
      "options": [
        "Это диспетчер исключений",
        "Это абстракция контекста синхронизации; await по умолчанию продолжает на захваченном контексте",
        "Это поток UI",
        "Это ресурс GC"
      ],
      "correct": 1,
      "explanation": "SynchronizationContext определяет, где выполняется продолжение await; UI/ASP.NET контексты возвращают выполнение в исходную среду.",
      "difficulty": "hard"
    },
    {
      "id": 57,
      "question": "Как работает TaskCompletionSource и когда его применять?",
      "options": [
        "Для блокировки потоков",
        "Для вручную управляемого завершения Task, обёртки обратных вызовов/сигналов",
        "Для сериализации JSON",
        "Для синхронного ввода-вывода"
      ],
      "correct": 1,
      "explanation": "TCS позволяет вручную завершать задачи и мостить callback-API в awaitable-модель.",
      "difficulty": "hard"
    },
    {
      "id": 58,
      "question": "В чём риск бесконтрольного использования ConfigureAwait(false) в UI приложениях?",
      "options": [
        "Утечка сокетов",
        "Продолжение может выполняться не в UI-контексте и ломать доступ к UI",
        "Отключение GC",
        "Отключение исключений"
      ],
      "correct": 1,
      "explanation": "После await код может оказаться не в UI-контексте; доступ к UI должен быть маршалирован.",
      "difficulty": "hard"
    },
    {
      "id": 59,
      "question": "Чем опасен Thread.Sleep в ASP.NET Core обработчике?",
      "options": [
        "Ничем",
        "Блокирует поток пула, снижая пропускную способность и вызывая starvation",
        "Ускоряет обработку",
        "Снимает блокировки"
      ],
      "correct": 1,
      "explanation": "Блокировка потока уменьшает throughput. Следует использовать await Task.Delay или асинхронные API.",
      "difficulty": "hard"
    },
    {
      "id": 60,
      "question": "В чём разница между Server GC и Workstation GC?",
      "options": [
        "Server GC быстрее для однопоточности",
        "Server GC оптимизирован для многопроцессорных серверов, Workstation — для настольных систем",
        "Workstation GC всегда без пауз",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "Server GC использует несколько heap и параллелизм; Workstation нацелена на интерактивность.",
      "difficulty": "hard"
    },
    {
      "id": 61,
      "question": "Когда следует использовать ValueTask вместо Task?",
      "options": [
        "Всегда",
        "Когда часто возвращается синхронный результат и важно уменьшить аллокации",
        "Только в UI",
        "Только для I/O"
      ],
      "correct": 1,
      "explanation": "ValueTask уменьшает аллокации при часто завершении синхронно; использовать осторожно из-за сложностей повторного await.",
      "difficulty": "hard"
    },
    {
      "id": 62,
      "question": "Что такое ref struct и ограничения его использования?",
      "options": [
        "Ссылочный тип без ограничений",
        "Структура, которая должна жить на стеке; нельзя боксировать/захватывать/хранить в полях классов",
        "Обычная struct",
        "record struct с равенством по ссылке"
      ],
      "correct": 1,
      "explanation": "ref struct (например, Span<T>) ограничен областью стека, недоступен для boxing и захвата в lambda/iterator.",
      "difficulty": "hard"
    },
    {
      "id": 63,
      "question": "Как работает память больших объектов (LOH) в .NET?",
      "options": [
        "LOH собирается в каждом поколении",
        "LOH хранит большие объекты, компактификация реже; аллокации > ~85К попадают в LOH",
        "LOH — это стек",
        "LOH — для кода JIT"
      ],
      "correct": 1,
      "explanation": "Large Object Heap собирается реже и влияет на паузы; крупные массивы строк/байт попадают туда.",
      "difficulty": "hard"
    },
    {
      "id": 64,
      "question": "В чём разница между immutable и thread-safe типами?",
      "options": [
        "Нет разницы",
        "Immutable не меняет состояние, thread-safe гарантирует корректность при одновременных изменениях",
        "Thread-safe — всегда быстрее",
        "Immutable требует блокировок"
      ],
      "correct": 1,
      "explanation": "Иммутабельность упрощает потокобезопасность, но не равнозначна ей; thread-safe может включать синхронизацию.",
      "difficulty": "hard"
    },
    {
      "id": 65,
      "question": "Какие проблемы решает ReaderWriterLockSlim?",
      "options": [
        "Синхронизация только записи",
        "Разделение доступа: множество читателей или один писатель",
        "Замена Interlocked",
        "Изоляция транзакций"
      ],
      "correct": 1,
      "explanation": "RWLockSlim позволяет параллельные чтения при отсутствии записей, снижая contention.",
      "difficulty": "hard"
    },
    {
      "id": 66,
      "question": "Что такое memory barrier и как она связана с volatile?",
      "options": [
        "Это сборщик мусора",
        "Барьер упорядочивает операции памяти; volatile вводит барьеры при чтении/записи",
        "Это блокировка",
        "Это таймер"
      ],
      "correct": 1,
      "explanation": "Памятные барьеры ограничивают переупорядочивание CPU/компилятора; volatile добавляет соответствующие барьеры.",
      "difficulty": "hard"
    },
    {
      "id": 67,
      "question": "Зачем нужен ArrayPool<T>?",
      "options": [
        "Для сортировки массивов",
        "Для повторного использования буферов и снижения аллокаций",
        "Для сериализации массивов",
        "Для потоков UI"
      ],
      "correct": 1,
      "explanation": "ArrayPool<T> позволяет арендовать/возвращать массивы, уменьшая давление на GC в высоконагруженных сценариях.",
      "difficulty": "hard"
    },
    {
      "id": 68,
      "question": "Чем отличается EqualityComparer<T>.Default от object.Equals?",
      "options": [
        "Не отличается",
        "EqualityComparer<T>.Default учитывает перегрузки IEquatable<T>/Equals для T",
        "object.Equals быстрее",
        "EqualityComparer<T> игнорирует generics"
      ],
      "correct": 1,
      "explanation": "EqualityComparer<T>.Default использует оптимальные реализации равенства для типа T (включая IEquatable<T>).",
      "difficulty": "hard"
    },
    {
      "id": 69,
      "question": "Когда предпочтительно использовать struct (значимый тип)?",
      "options": [
        "Для объектов с богатыми иерархиями",
        "Для маленьких, неизменяемых значений без необходимости полиморфизма",
        "Всегда",
        "Никогда"
      ],
      "correct": 1,
      "explanation": "struct целесообразен для небольших, часто копируемых, иммутабельных значений, чтобы избежать аллокаций в куче.",
      "difficulty": "hard"
    },
    {
      "id": 70,
      "question": "Что такое source generator в Roslyn?",
      "options": [
        "Рантайм транспайлер",
        "Компиляторная надстройка, генерирующая исходный код во время компиляции",
        "JIT-оптимизатор",
        "Инструмент ILMerge"
      ],
      "correct": 1,
      "explanation": "Source generators позволяют анализировать код и добавлять сгенерированные исходники на этапе компиляции.",
      "difficulty": "hard"
    },
    {
      "id": 71,
      "question": "Как избежать утечек памяти при событиях со статическими издателями?",
      "options": [
        "Никак",
        "Явно отписываться или использовать слабые подписки",
        "Использовать GC.SuppressFinalize",
        "Кэшировать делегаты в static"
      ],
      "correct": 1,
      "explanation": "Статические события удерживают подписчиков долговременно; требуется отписка/слабые ссылки.",
      "difficulty": "hard"
    },
    {
      "id": 72,
      "question": "В чём особенность IAsyncEnumerable<T>?",
      "options": [
        "Перечисляет синхронно",
        "Позволяет асинхронное потоковое перечисление с await foreach",
        "Требует PLINQ",
        "Работает только в UI"
      ],
      "correct": 1,
      "explanation": "IAsyncEnumerable<T> возвращает элементы асинхронно; потребляется через await foreach.",
      "difficulty": "hard"
    },
    {
      "id": 73,
      "question": "Что такое Channels (System.Threading.Channels)?",
      "options": [
        "Сетевые сокеты",
        "Высокопроизводительные потокобезопасные очереди для продюсер-консюмер",
        "Файловые дескрипторы",
        "HTTP-стримы"
      ],
      "correct": 1,
      "explanation": "Channels предоставляют эффективную асинхронную передачу сообщений между продюсерами и консюмерами.",
      "difficulty": "hard"
    },
    {
      "id": 74,
      "question": "Когда стоит использовать Span<T>/Memory<T> вместо массива/строки?",
      "options": [
        "Всегда",
        "Когда важно избегать аллокаций/копирования и работать со срезами",
        "Только в UI",
        "Только с БД"
      ],
      "correct": 1,
      "explanation": "Span/Memory позволяют безопасно работать с подмассивами/буферами без дополнительных аллокаций.",
      "difficulty": "hard"
    },
    {
      "id": 75,
      "question": "Чем опасен непереопределённый GetHashCode при переопределении Equals?",
      "options": [
        "Ничем",
        "Нарушает контракт хэш-коллекций, может приводить к ошибкам поиска",
        "Ускоряет сравнение",
        "Вызывает GC"
      ],
      "correct": 1,
      "explanation": "Контракт требует согласованности Equals и GetHashCode; иначе Dictionary/HashSet работают некорректно.",
      "difficulty": "hard"
    },
    {
      "id": 76,
      "question": "Как работает пул потоков .NET (ThreadPool)?",
      "options": [
        "Создаёт поток на каждую задачу",
        "Переиспользует ограниченный набор потоков, адаптивно масштабируясь",
        "Не используется Task",
        "Только для UI"
      ],
      "correct": 1,
      "explanation": "ThreadPool переиспользует потоки, подстраивая их количество под нагрузку (Hill Climbing).",
      "difficulty": "hard"
    },
    {
      "id": 77,
      "question": "Почему небезопасно хранить ссылку на Span<T>?",
      "options": [
        "Потому что это класс",
        "Span<T> — ref struct со стековой семантикой; хранение/boxing запрещены",
        "Потому что GC",
        "Не компилируется из-за sealed"
      ],
      "correct": 1,
      "explanation": "ref struct нельзя боксировать/захватывать, иначе теряется гарантия жизненного цикла и безопасность.",
      "difficulty": "hard"
    },
    {
      "id": 78,
      "question": "В чём разница между ImmutableArray<T> и IReadOnlyList<T>?",
      "options": [
        "Оба неизменяемы гарантированно",
        "ImmutableArray<T> гарантирует неизменяемость, IReadOnlyList<T> лишь интерфейс только для чтения",
        "IReadOnlyList<T> быстрее",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "IReadOnlyList не гарантирует, что базовая коллекция неизменяемая; ImmutableArray — гарантирует.",
      "difficulty": "hard"
    },
    {
      "id": 79,
      "question": "Что такое covariance/contravariance в дженериках?",
      "options": [
        "Оптимизация JIT",
        "Совместимость направлений преобразований для параметров типа (out/in)",
        "Механизм сериализации",
        "Опция GC"
      ],
      "correct": 1,
      "explanation": "Ковариантность (out) разрешает TDerived->TBase, контравариантность (in) — обратное для параметров типа.",
      "difficulty": "hard"
    },
    {
      "id": 80,
      "question": "Как работает String.Intern и какие риски?",
      "options": [
        "Кэширует строки на LOH без ограничений",
        "Добавляет строку в пул интернирования; риск — утечки памяти при чрезмерном интернировании",
        "Сериализует строки",
        "Ускоряет GC"
      ],
      "correct": 1,
      "explanation": "Интернирование удерживает строки до завершения домена, что может привести к росту памяти.",
      "difficulty": "hard"
    },
    {
      "id": 81,
      "question": "Почему важно Dispose/await using для IAsyncDisposable?",
      "options": [
        "Не важно",
        "Корректное освобождение асинхронных ресурсов (например, потоков, сокетов)",
        "Ускоряет JIT",
        "Требуется только в UI"
      ],
      "correct": 1,
      "explanation": "IAsyncDisposable требует асинхронной очистки; await using гарантирует завершение асинхронных освобождений.",
      "difficulty": "hard"
    },
    {
      "id": 82,
      "question": "Как HttpClientFactory помогает с DNS-обновлениями?",
      "options": [
        "Никак",
        "Переиспользует SocketsHttpHandler с управлением временем жизни, учитывая DNS-обновления",
        "Создаёт новый HttpClient каждый раз",
        "Отключает кеширование DNS"
      ],
      "correct": 1,
      "explanation": "Factory управляет временем жизни хэндлера, что позволяет корректно учитывать обновления DNS.",
      "difficulty": "hard"
    },
    {
      "id": 83,
      "question": "Что такое deadlock при смешении async и sync?",
      "options": [
        "Ошибка компиляции",
        "Ситуация, когда поток блокирует ожидание, удерживая контекст, и задача ждёт возвращения контекста",
        "Сбой GC",
        "Остановка JIT"
      ],
      "correct": 1,
      "explanation": "Блокировка Result/Wait в контекстно-зависимом коде вызывает взаимную блокировку с продолжением await.",
      "difficulty": "hard"
    },
    {
      "id": 84,
      "question": "Чем отличается Newtonsoft.Json от System.Text.Json в .NET?",
      "options": [
        "Ничем",
        "System.Text.Json быстрее на типичных сценариях, но NewtonSoft функционально богаче",
        "Newtonsoft всегда быстрее",
        "System.Text.Json не поддерживает сериализацию"
      ],
      "correct": 1,
      "explanation": "System.Text.Json ориентирован на производительность и встроен, но Newtonsoft имеет больше фич/расширяемости.",
      "difficulty": "hard"
    },
    {
      "id": 85,
      "question": "Что делает stackalloc?",
      "options": [
        "Выделяет память в куче",
        "Выделяет память на стеке для локальных буферов",
        "Удаляет объект",
        "Запускает GC"
      ],
      "correct": 1,
      "explanation": "stackalloc выделяет память на стеке (Span<T>/stackalloc T[n]) для высокопроизводительных сценариев.",
      "difficulty": "hard"
    },
    {
      "id": 86,
      "question": "Зачем нужен Unsafe (System.Runtime.CompilerServices.Unsafe)?",
      "options": [
        "Для логирования",
        "Для низкоуровневых операций с памятью без проверок",
        "Для UI",
        "Для сериализации"
      ],
      "correct": 1,
      "explanation": "Unsafe предоставляет небезопасные утилиты для производительности; требует большой осторожности.",
      "difficulty": "hard"
    },
    {
      "id": 87,
      "question": "Как работает StringBuilder по части аллокаций?",
      "options": [
        "Аллоцирует новую строку при каждом Append",
        "Держит внутренний буфер и увеличивает его по мере необходимости",
        "Не аллоцирует вовсе",
        "Использует LOH всегда"
      ],
      "correct": 1,
      "explanation": "StringBuilder накапливает данные в буферах, снижая количество промежуточных строковых аллокаций.",
      "difficulty": "hard"
    },
    {
      "id": 88,
      "question": "Почему важно правильно реализовывать Dispose и финализатор?",
      "options": [
        "Чтобы ускорить JIT",
        "Для корректного освобождения неуправляемых ресурсов и избежания финализаторных пауз",
        "Чтобы включить инлайнинг",
        "Чтобы избежать boxing"
      ],
      "correct": 1,
      "explanation": "Dispose освобождает ресурсы детерминированно; финализатор — страховка, но дорогой и должен быть минимальным.",
      "difficulty": "hard"
    },
    {
      "id": 89,
      "question": "Как работает CancellationToken в связке тайм-аутов и linked tokens?",
      "options": [
        "Нельзя комбинировать",
        "Можно связывать несколько источников (CreateLinkedTokenSource) и задавать тайм-ауты",
        "Только один токен",
        "Только тайм-аут без отмены"
      ],
      "correct": 1,
      "explanation": "LinkedTokenSource объединяет отмену от нескольких источников; CTS может задавать тайм-ауты.",
      "difficulty": "hard"
    },
    {
      "id": 90,
      "question": "Что такое Structure of Arrays (SoA) vs Array of Structures (AoS) в .NET?",
      "options": [
        "Одинаково",
        "SoA хранит поля раздельно по массивам, улучшая локальность для отдельных полей",
        "AoS всегда быстрее",
        "SoA невозможен в .NET"
      ],
      "correct": 1,
      "explanation": "Выбор влияет на кэш-локальность и производительность; в .NET можно моделировать SoA вручную.",
      "difficulty": "hard"
    },
    {
      "id": 91,
      "question": "Как избежать блокировок при логировании в высоконагруженных сервисах?",
      "options": [
        "Использовать lock вокруг каждого Write",
        "Использовать неблокирующие очереди/буферы и фоновые писатели",
        "Логировать в UI-потоке",
        "Выключить логирование"
      ],
      "correct": 1,
      "explanation": "Async-логирование с буферами/очередями снижает влияние на горячие пути и contention.",
      "difficulty": "hard"
    },
    {
      "id": 92,
      "question": "Что означает агрессивное инлайнинг (MethodImplOptions.AggressiveInlining)?",
      "options": [
        "Гарантирует инлайнинг",
        "Подсказка JIT о желательности инлайнинга без гарантии",
        "Отключает инлайнинг",
        "Только для async методов"
      ],
      "correct": 1,
      "explanation": "Атрибут — лишь подсказка; JIT может проигнорировать из-за эвристик/размеров.",
      "difficulty": "hard"
    },
    {
      "id": 93,
      "question": "Почему важно избегать лишних аллокаций в горячем пути?",
      "options": [
        "Ускоряет GC и уменьшает паузы",
        "Замедляет код",
        "Не важно",
        "Только для UI"
      ],
      "correct": 0,
      "explanation": "Меньше мусора — меньше работы GC и выше предсказуемость задержек.",
      "difficulty": "hard"
    },
    {
      "id": 94,
      "question": "Как работает lock вокруг async/await?",
      "options": [
        "Безопасно использовать lock вокруг await",
        "lock не совместим с await; следует использовать SemaphoreSlim/AsyncLock",
        "await делает lock асинхронным",
        "lock ускоряет await"
      ],
      "correct": 1,
      "explanation": "await может покинуть критическую секцию; вместо lock применять SemaphoreSlim или специализированные async-замки.",
      "difficulty": "hard"
    },
    {
      "id": 95,
      "question": "Что такое false sharing и как его избежать?",
      "options": [
        "Потеря данных",
        "Конкуренция потоков из-за разделения кэш-линий; решается выравниванием/паддингом",
        "Сбой компиляции",
        "Ошибка сериализации"
      ],
      "correct": 1,
      "explanation": "Размещение горячих полей разных потоков в одной кэш-линии вызывает избыточную инвалидацию; помогает Padding/[StructLayout].",
      "difficulty": "hard"
    },
    {
      "id": 96,
      "question": "Почему важно не блокировать синхронно Result/Wait на Task в ASP.NET Core?",
      "options": [
        "Не важно",
        "Вызывает потенциальные дедлоки и утилизационные проблемы",
        "Ускоряет сервер",
        "Требуется для тайм-аутов"
      ],
      "correct": 1,
      "explanation": "Синхронная блокировка снижает масштабируемость и может дедлокить при контекстах/ресурсах.",
      "difficulty": "hard"
    },
    {
      "id": 97,
      "question": "Что такое TaskScheduler и зачем он нужен?",
      "options": [
        "Менеджер процессов ОС",
        "Компонент, определяющий, где и как выполняются задачи (например, текущий контекст/пул)",
        "Сериализатор",
        "Контроллер GC"
      ],
      "correct": 1,
      "explanation": "TaskScheduler управляет планированием задач; по умолчанию — ThreadPool, но можно переопределить.",
      "difficulty": "hard"
    },
    {
      "id": 98,
      "question": "Как снизить cost лога при отключённом уровне?",
      "options": [
        "Формировать строку заранее",
        "Использовать отложенное форматирование/проверку уровня (IsEnabled) или шаблоны",
        "Писать в Console",
        "Никак"
      ],
      "correct": 1,
      "explanation": "Проверка уровня/шаблонные API избегают лишних вычислений и аллокаций, когда лог отключён.",
      "difficulty": "hard"
    },
    {
      "id": 99,
      "question": "Зачем нужен Unsafe.SkipInit(out T)?",
      "options": [
        "Для очистки памяти",
        "Чтобы пропустить zero-init локалов для производительности (требует осторожности)",
        "Для GC",
        "Для сериализации"
      ],
      "correct": 1,
      "explanation": "SkipInit может избежать обнуления локала, но опасен при чтении неинициализированных данных.",
      "difficulty": "hard"
    },
    {
      "id": 100,
      "question": "Как использовать CancellationToken в IAsyncEnumerable<T>?",
      "options": [
        "Нельзя",
        "Передавать токен в метод-источник и использовать await foreach (var x in source.WithCancellation(token))",
        "Только через глобальную переменную",
        "Только через тайм-ауты"
      ],
      "correct": 1,
      "explanation": "IAsyncEnumerable поддерживает отмену через WithCancellation/Enumerator.MoveNextAsync(token).",
      "difficulty": "hard"
    }
  ]
}