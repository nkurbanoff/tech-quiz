{
  "version": "1.1.0",
  "lastUpdated": "2025-11-18",
  "category": "csharp",
  "questions": [
    {
      "id": 1,
      "question": "Какой модификатор доступа по умолчанию у членов класса в C#?",
      "options": ["public", "private", "protected", "internal"],
      "correct": 1,
      "explanation": "По умолчанию члены класса имеют модификатор private и доступны только внутри класса.",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Что делает ключевое слово var?",
      "options": [
        "Определяет динамический тип во время выполнения",
        "Выполняет вывод статического типа на этапе компиляции",
        "Делает переменную глобальной",
        "Делает переменную неизменяемой"
      ],
      "correct": 1,
      "explanation": "var выполняет вывод статического типа компилятором, тип остаётся строго статическим.",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "Что делает оператор using (стейтмент) в C#?",
      "options": [
        "Подключает пространство имён",
        "Гарантирует вызов Dispose у объекта по выходу из блока",
        "Создаёт новый поток",
        "Отключает сборку мусора"
      ],
      "correct": 1,
      "explanation": "using-стейтмент гарантирует вызов Dispose для IDisposable-объекта при выходе из блока, даже при исключениях.",
      "difficulty": "easy"
    },
    {
      "id": 4,
      "question": "Что возвращает оператор is?",
      "options": ["Тип значения переменной", "Булево значение совместимости с типом", "Хэш-код объекта", "Размер типа в байтах"],
      "correct": 1,
      "explanation": "Оператор is возвращает true/false, проверяя совместимость объекта с типом (включая pattern matching).",
      "difficulty": "easy"
    },
    {
      "id": 5,
      "question": "Для чего используется string interpolation ($\"...\")?",
      "options": [
        "Для конкатенации строк в рантайме без форматирования",
        "Для безопасного HTML-энкодинга",
        "Для удобного форматирования строк с подстановкой выражений",
        "Для компиляции строк в выражения"
      ],
      "correct": 2,
      "explanation": "Интерполяция строк позволяет подставлять выражения в строку с форматированием.",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "Чем отличается const от readonly?",
      "options": [
        "const назначается в рантайме, readonly — в компиляции",
        "const вычисляется на этапе компиляции, readonly — в рантайме",
        "Они полностью идентичны",
        "readonly только для значимых типов"
      ],
      "correct": 1,
      "explanation": "const требует константного выражения на этапе компиляции, readonly может инициализироваться в конструкторе (рантайм).",
      "difficulty": "easy"
    },
    {
      "id": 7,
      "question": "Какой тип у литерала \"text\" в C#?",
      "options": ["char", "ReadOnlySpan<char>", "string", "object"],
      "correct": 2,
      "explanation": "Строковый литерал имеет тип string (System.String).",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Какой интерфейс реализует перечисление IEnumerator<T>?",
      "options": ["IEnumerable<T>", "IDisposable", "IComparable<T>", "ICloneable"],
      "correct": 1,
      "explanation": "IEnumerator<T> реализует IDisposable для корректного освобождения ресурсов при перечислении.",
      "difficulty": "easy"
    },
    {
      "id": 9,
      "question": "Что делает ключевое слово static у члена класса?",
      "options": [
        "Делает член доступным только для экземпляров",
        "Препятствует наследованию",
        "Связывает член с типом, а не экземпляром",
        "Делает член приватным"
      ],
      "correct": 2,
      "explanation": "static связывает член с типом, общий для всех экземпляров и доступный без создания объекта.",
      "difficulty": "easy"
    },
    {
      "id": 10,
      "question": "Что такое nullable-значимый тип в C#?",
      "options": [
        "Ссылочный тип, допускающий null",
        "Значимый тип с возможностью хранения null через Nullable<T>",
        "Любой тип с атрибутом [Nullable]",
        "Это dynamic"
      ],
      "correct": 1,
      "explanation": "Nullable<T> (синтаксис T?) позволяет значимому типу хранить отсутствие значения (null).",
      "difficulty": "easy"
    },

    {
      "id": 11,
      "question": "Чем отличается class от struct?",
      "options": [
        "struct — ссылочный тип, class — значимый",
        "Оба ссылочные типы",
        "class — ссылочный тип, struct — значимый",
        "Оба значимые типы"
      ],
      "correct": 2,
      "explanation": "class — ссылочный тип (в куче), struct — значимый (обычно на стеке или внутри содержащего типа).",
      "difficulty": "medium"
    },
    {
      "id": 12,
      "question": "Для чего нужны extension-методы?",
      "options": [
        "Чтобы наследовать sealed классы",
        "Чтобы добавить методы к существующим типам без наследования",
        "Чтобы перегрузить операторы",
        "Чтобы изменить приватные члены типов"
      ],
      "correct": 1,
      "explanation": "Extension-методы позволяют добавлять методы к типам без изменения их исходного кода и без наследования.",
      "difficulty": "medium"
    },
    {
      "id": 13,
      "question": "Что делает ключевое слово async в сигнатуре метода?",
      "options": [
        "Создаёт новый поток",
        "Позволяет использовать await и генерирует state machine",
        "Делает метод неблокирующим гарантированно",
        "Запрещает исключения"
      ],
      "correct": 1,
      "explanation": "async позволяет использовать await; компилятор строит state machine. Новый поток не создаётся автоматически.",
      "difficulty": "medium"
    },
    {
      "id": 14,
      "question": "Как корректно отменять асинхронные операции?",
      "options": [
        "Через Thread.Abort",
        "Через CancellationToken",
        "Через GC.Collect",
        "Это невозможно"
      ],
      "correct": 1,
      "explanation": "Стандартный механизм отмены — пробрасывание CancellationToken и его проверка/прерывание.",
      "difficulty": "medium"
    },
    {
      "id": 15,
      "question": "Чем отличается IEnumerable<T> от IQueryable<T>?",
      "options": [
        "IEnumerable<T> формирует выражение запроса, IQueryable<T> — перечисляет",
        "IQueryable<T> описывает выражение, исполняемое провайдером (отложенно)",
        "Это одно и то же",
        "IQueryable<T> работает только с файлами"
      ],
      "correct": 1,
      "explanation": "IQueryable<T> представляет выражение для провайдера (например, БД), IEnumerable<T> — перечисление в памяти.",
      "difficulty": "medium"
    },
    {
      "id": 16,
      "question": "Где хранится замыкание (captured variables) лямбды?",
      "options": ["В стеке", "В выделенном объекте диспетчера замыканий (куча)", "В регистре CPU", "В атрибутах метода"],
      "correct": 1,
      "explanation": "Захваченные переменные хранятся в сгенерированном объекте (closure) в куче.",
      "difficulty": "medium"
    },
    {
      "id": 17,
      "question": "Что делает оператор ?? (null-coalescing)?",
      "options": [
        "Вызывает исключение при null",
        "Возвращает левый операнд, если он не null, иначе правый",
        "Преобразует тип в nullable",
        "Удаляет null из коллекции"
      ],
      "correct": 1,
      "explanation": "Оператор ?? возвращает значение по умолчанию, если слева null.",
      "difficulty": "medium"
    },
    {
      "id": 18,
      "question": "Что такое record в C#?",
      "options": [
        "Тип для небезопасного кода",
        "Синтаксический сахар для анонимных типов",
        "Ссылочный (или значимый) тип с семантикой равенства по значению",
        "Специальный тип для БД"
      ],
      "correct": 2,
      "explanation": "record — тип с равенством по содержимому (value-based equality), поддерживает with-выражения.",
      "difficulty": "medium"
    },
    {
      "id": 19,
      "question": "Чем отличается override от new при переопределении метода?",
      "options": [
        "override скрывает метод базового класса",
        "new переопределяет виртуальный метод",
        "override переопределяет virtual, new скрывает (hides) метод",
        "Они эквивалентны"
      ],
      "correct": 2,
      "explanation": "override переопределяет virtual/abstract; new — скрывает член базового класса при совпадении сигнатуры.",
      "difficulty": "medium"
    },
    {
      "id": 20,
      "question": "Как избежать утечек при событиях .NET?",
      "options": [
        "Не отписываться — GC сам разберётся",
        "Использовать слабые ссылки или явно отписываться",
        "Использовать dynamic",
        "Вызывать GC.Collect после события"
      ],
      "correct": 1,
      "explanation": "Подписчик удерживается издателем; важно отписываться или применять слабые события/паттерны.",
      "difficulty": "medium"
    },
    {
      "id": 21,
      "question": "Где корректнее хранить общий HttpClient?",
      "options": [
        "Создавать новый на каждый запрос",
        "Переиспользовать долгоживущий экземпляр/Factory",
        "Wrap в using для каждого вызова",
        "Использовать WebRequest вместо него"
      ],
      "correct": 1,
      "explanation": "Рекомендуется переиспользовать HttpClient или использовать IHttpClientFactory, чтобы избежать сокет-исчерпания.",
      "difficulty": "medium"
    },
    {
      "id": 22,
      "question": "Что делает ConfigureAwait(false)?",
      "options": [
        "Запрещает ожидание",
        "Не захватывает SynchronizationContext при продолжении",
        "Создаёт новый поток",
        "Гарантирует UI-контекст"
      ],
      "correct": 1,
      "explanation": "ConfigureAwait(false) сообщает не возвращаться в исходный контекст (UI/ASP.NET) после await.",
      "difficulty": "medium"
    },
    {
      "id": 23,
      "question": "Чем отличается Task.Run от Task.Factory.StartNew по умолчанию?",
      "options": [
        "Ничем не отличается",
        "Task.Run оптимизирован для CPU-bound и использует стандартные параметры",
        "StartNew всегда долгоживущий",
        "Run создаёт новый поток вне пула"
      ],
      "correct": 1,
      "explanation": "Task.Run — удобный шорткат для пула потоков с безопасными дефолтами, StartNew требует явной конфигурации.",
      "difficulty": "medium"
    },
    {
      "id": 24,
      "question": "Что такое span в C# (Span<T>)?",
      "options": [
        "Ссылочный тип для потоков",
        "Структура, представляющая непрерывный участок памяти с безопасными срезами",
        "Класс для JSON",
        "Особый тип исключений"
      ],
      "correct": 1,
      "explanation": "Span<T> — ref struct для безопасного доступа к непрерывным участкам памяти без выделений.",
      "difficulty": "medium"
    },
    {
      "id": 25,
      "question": "Чем отличаются ref и out параметры?",
      "options": [
        "ref требует инициализации до вызова, out — нет",
        "out требует инициализации до вызова, ref — нет",
        "Они эквивалентны",
        "out для ссылочных типов, ref — для значимых"
      ],
      "correct": 0,
      "explanation": "ref — аргумент должен быть инициализирован; out — должен быть присвоен в методе.",
      "difficulty": "medium"
    },
    {
      "id": 26,
      "question": "Что такое CancellationTokenSource?",
      "options": [
        "Токен отмены",
        "Источник, создающий и сигналящий токен отмены",
        "Таймер",
        "Провайдер потоков"
      ],
      "correct": 1,
      "explanation": "CTS создаёт CancellationToken и управляет сигналом отмены для связанных операций.",
      "difficulty": "medium"
    },
    {
      "id": 27,
      "question": "Что делает оператор ??= ?",
      "options": [
        "Присваивает null левому операнду",
        "Присваивает правый операнд, если левый равен null",
        "Сравнивает на равенство",
        "Удаляет null"
      ],
      "correct": 1,
      "explanation": "Оператор ??= присваивает значение справа только если слева null.",
      "difficulty": "medium"
    },
    {
      "id": 28,
      "question": "Для чего нужен lock?",
      "options": [
        "Запускает асинхронную операцию",
        "Предотвращает одновременный доступ нескольких потоков к критической секции",
        "Останавливает процесс",
        "Гарантирует отсутствие исключений"
      ],
      "correct": 1,
      "explanation": "lock (Monitor) обеспечивает взаимное исключение при доступе к разделяемым ресурсам.",
      "difficulty": "medium"
    },
    {
      "id": 29,
      "question": "Что такое boxing в C#?",
      "options": [
        "Преобразование ссылочного типа в значимый",
        "Упаковка значимого типа в объект (ссылочный тип)",
        "Удаление объекта",
        "Оптимизация JIT"
      ],
      "correct": 1,
      "explanation": "Boxing упаковывает значение (например, int) в object, приводит к выделению в куче.",
      "difficulty": "medium"
    },
    {
      "id": 30,
      "question": "Какой тип у выражения nameof(x)?",
      "options": ["char[]", "string", "ReadOnlySpan<char>", "object"],
      "correct": 1,
      "explanation": "nameof возвращает строку с именем символа/типа/члена при компиляции.",
      "difficulty": "medium"
    },
    {
      "id": 31,
      "question": "Что делает ключевое слово sealed?",
      "options": [
        "Делает класс абстрактным",
        "Запрещает наследование от класса или переопределение метода",
        "Делает методы приватными",
        "Включает небезопасный код"
      ],
      "correct": 1,
      "explanation": "sealed запрещает наследование (для класса) или дальнейшее переопределение (для метода).",
      "difficulty": "medium"
    },
    {
      "id": 32,
      "question": "Чем отличается throw от throw ex в catch?",
      "options": [
        "Одинаково сохраняют стек",
        "throw пересбрасывает с сохранением стека, throw ex сбрасывает стек",
        "throw ex безопаснее",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "throw сохраняет исходный стек, throw ex перезаписывает точку возникновения исключения.",
      "difficulty": "medium"
    },
    {
      "id": 33,
      "question": "Какое назначение using-директивы (using Namespace;)?",
      "options": [
        "Освобождение ресурсов",
        "Упрощение ссылок на типы из пространства имён",
        "Компиляция в одиночный модуль",
        "Создание алиасов методов"
      ],
      "correct": 1,
      "explanation": "using-директива упрощает доступ к типам в пространстве имён без полного имени.",
      "difficulty": "medium"
    },
    {
      "id": 34,
      "question": "Чем отличается IEnumerable<T> от List<T>?",
      "options": [
        "IEnumerable<T> — коллекция со случайным доступом",
        "IEnumerable<T> — интерфейс перечисления, List<T> — конкретная коллекция",
        "List<T> — интерфейс, IEnumerable<T> — класс",
        "Нет отличий"
      ],
      "correct": 1,
      "explanation": "IEnumerable<T> задаёт контракт перечисления, List<T> — реализация динамического массива.",
      "difficulty": "medium"
    },
    {
      "id": 35,
      "question": "Какой тип исключений предназначен для отмены?",
      "options": [
        "OperationCanceledException",
        "InvalidOperationException",
        "TimeoutException",
        "TaskCanceledException нельзя использовать"
      ],
      "correct": 0,
      "explanation": "Отмена стандартно сигнализируется через OperationCanceledException/TaskCanceledException.",
      "difficulty": "medium"
    },
    {
      "id": 36,
      "question": "Что вернёт Dictionary<TKey,TValue>[key] при отсутствии ключа?",
      "options": [
        "null",
        "Исключение KeyNotFoundException",
        "Значение по умолчанию",
        "false"
      ],
      "correct": 1,
      "explanation": "Индексатор Dictionary бросает KeyNotFoundException при отсутствии ключа.",
      "difficulty": "medium"
    },
    {
      "id": 37,
      "question": "Для чего нужны атрибуты (Attributes) в C#?",
      "options": [
        "Для JIT-компиляции",
        "Для добавления метаданных к программным элементам",
        "Для выделения памяти",
        "Для оптимизации IL"
      ],
      "correct": 1,
      "explanation": "Атрибуты добавляют метаданные, используемые рантаймом, рефлексией и инструментами.",
      "difficulty": "medium"
    },
    {
      "id": 38,
      "question": "Чем отличается DateTime от DateTimeOffset?",
      "options": [
        "DateTimeOffset хранит смещение от UTC, DateTime — нет",
        "DateTime всегда UTC",
        "DateTimeOffset работает только в Linux",
        "Нет отличий"
      ],
      "correct": 0,
      "explanation": "DateTimeOffset инкапсулирует момент времени и смещение от UTC, избегая неоднозначностей часовых поясов.",
      "difficulty": "medium"
    },
    {
      "id": 39,
      "question": "Что делает оператора => в объявлениях членов?",
      "options": [
        "Обозначает лямбда-выражение или выражение-член",
        "Является оператором сравнения",
        "Создаёт кортеж",
        "Объявляет индексатор"
      ],
      "correct": 0,
      "explanation": "=> используется для лямбд и для членов, определяемых выражением (expression-bodied members).",
      "difficulty": "medium"
    },
    {
      "id": 40,
      "question": "Какой паттерн предпочтителен для одноразовых ресурсов?",
      "options": [
        "IDisposable + using",
        "Singleton",
        "Factory",
        "Observer"
      ],
      "correct": 0,
      "explanation": "Для детерминированного освобождения ресурсов реализуют IDisposable и используют using.",
      "difficulty": "medium"
    },
    {
      "id": 41,
      "question": "Что делает оператор ?. (null-conditional)?",
      "options": [
        "Бросает исключение при null",
        "Возвращает null вместо обращения к члену, если объект равен null",
        "Заменяет null на пустую строку",
        "Вызывает Dispose при null"
      ],
      "correct": 1,
      "explanation": "?. предотвращает NullReferenceException, возвращая null для результата цепочки.",
      "difficulty": "medium"
    },
    {
      "id": 42,
      "question": "Где уместно применять async void?",
      "options": [
        "Везде для упрощения",
        "В обработчиках событий",
        "В методах библиотек",
        "В контроллерах ASP.NET"
      ],
      "correct": 1,
      "explanation": "async void стоит использовать только для обработчиков событий; иначе — возвращать Task/Task<T>.",
      "difficulty": "medium"
    },
    {
      "id": 43,
      "question": "Как избежать лишних аллокаций при конкатенации строк в цикле?",
      "options": [
        "Использовать +",
        "Использовать StringBuilder",
        "Использовать string.Intern",
        "Вызывать GC.Collect"
      ],
      "correct": 1,
      "explanation": "StringBuilder минимизирует аллокации при множественных соединениях строк.",
      "difficulty": "medium"
    },
    {
      "id": 44,
      "question": "Что возвращает оператор as при невозможности приведения?",
      "options": ["Исключение", "null", "false", "default(T) для T"] ,
      "correct": 1,
      "explanation": "as возвращает null при неудачном привидении к ссылочному или nullable типу.",
      "difficulty": "medium"
    },
    {
      "id": 45,
      "question": "Как добавить метод расширения?",
      "options": [
        "В любом классе",
        "В статическом классе со статическим методом и первым параметром this",
        "В интерфейсе",
        "В record"
      ],
      "correct": 1,
      "explanation": "Extension-метод — статический метод в статическом классе, первый параметр помечен this T.",
      "difficulty": "medium"
    },
    {
      "id": 46,
      "question": "Что такое expression tree (Expression<TDelegate>)?",
      "options": [
        "Выполняемая лямбда",
        "Дерево, описывающее выражение для анализа/трансляции",
        "Массив байтов",
        "IL-код"
      ],
      "correct": 1,
      "explanation": "Expression деревья представляют выражения как структуру данных, которая может быть проанализирована или скомпилирована.",
      "difficulty": "medium"
    },
    {
      "id": 47,
      "question": "Какая разница между First и FirstOrDefault в LINQ?",
      "options": [
        "Оба бросают при отсутствии",
        "First бросает исключение, FirstOrDefault возвращает default",
        "FirstOrDefault быстрее всегда",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "First требует хотя бы один элемент, FirstOrDefault возвращает default(T) при пустой последовательности.",
      "difficulty": "medium"
    },
    {
      "id": 48,
      "question": "Для чего служит interface IDisposable?",
      "options": [
        "Для управления потоками",
        "Для детерминированного освобождения неуправляемых/управляемых ресурсов",
        "Для сериализации",
        "Для логирования"
      ],
      "correct": 1,
      "explanation": "IDisposable определяет метод Dispose для явного освобождения ресурсов.",
      "difficulty": "medium"
    },
    {
      "id": 49,
      "question": "Что такое default literal (default)?",
      "options": [
        "Всегда null",
        "Литерал, означающий значение по умолчанию для контекстного типа",
        "Литерал для нулевого значения",
        "Запрещён в generic"
      ],
      "correct": 1,
      "explanation": "default без типа принимает значение по умолчанию контекста (например, default(int) == 0).",
      "difficulty": "medium"
    },
    {
      "id": 50,
      "question": "Какое назначение ключевого слова volatile?",
      "options": [
        "Запрещает JIT",
        "Обеспечивает, что поле читается/пишется напрямую, минуя кэш регистров/оптимизации",
        "Делает поле неизменным",
        "Создаёт блокировку"
      ],
      "correct": 1,
      "explanation": "volatile запрещает определённые оптимизации и обеспечивает видимость изменений между потоками.",
      "difficulty": "medium"
    },
    {
      "id": 51,
      "question": "Чем отличается internal от protected internal?",
      "options": [
        "internal — доступ из любого места",
        "protected internal — доступ либо из сборки, либо из наследников",
        "protected internal — только из наследников в одной сборке",
        "Они одинаковы"
      ],
      "correct": 1,
      "explanation": "protected internal — объединение: доступ либо из текущей сборки, либо из наследников (в любой сборке).",
      "difficulty": "medium"
    },
    {
      "id": 52,
      "question": "Как избежать deadlock в UI-коде с await?",
      "options": [
        "Использовать .Result",
        "Использовать ConfigureAwait(false) в библиотечном коде и не блокировать Result/Wait",
        "Вызывать GC.Collect",
        "Запретить async"
      ],
      "correct": 1,
      "explanation": "Не блокировать асинхронный код синхронно; в библиотечном коде использовать ConfigureAwait(false).",
      "difficulty": "medium"
    },
    {
      "id": 53,
      "question": "Что такое PLINQ?",
      "options": [
        "Параллельный LINQ для параллельной обработки коллекций",
        "LINQ для PostgreSQL",
        "LINQ для файлов",
        "Библиотека сериализации"
      ],
      "correct": 0,
      "explanation": "PLINQ позволяет параллелить операции LINQ над коллекциями при подходящих задачах.",
      "difficulty": "medium"
    },
    {
      "id": 54,
      "question": "Что делает Interlocked.Increment(ref x)?",
      "options": [
        "Увеличивает без потокобезопасности",
        "Атомарно увеличивает значение",
        "Блокирует поток",
        "Создаёт новый int"
      ],
      "correct": 1,
      "explanation": "Interlocked обеспечивает атомарные операции для примитивов без явных блокировок.",
      "difficulty": "medium"
    },
    {
      "id": 55,
      "question": "Зачем нужен CancellationToken.ThrowIfCancellationRequested()?",
      "options": [
        "Для игнорирования отмены",
        "Для выброса OperationCanceledException при запросе отмены",
        "Для логирования",
        "Для освобождения ресурсов"
      ],
      "correct": 1,
      "explanation": "Метод бросает OperationCanceledException, корректно сигнализируя отмену вверх по стеку.",
      "difficulty": "medium"
    },

    {
      "id": 56,
      "question": "Что такое SynchronizationContext и как он влияет на await?",
      "options": [
        "Это диспетчер исключений",
        "Это абстракция контекста синхронизации; await по умолчанию продолжает на захваченном контексте",
        "Это поток UI",
        "Это ресурс GC"
      ],
      "correct": 1,
      "explanation": "SynchronizationContext определяет, где выполняется продолжение await; UI/ASP.NET контексты возвращают выполнение в исходную среду.",
      "difficulty": "hard"
    },
    {
      "id": 57,
      "question": "Как работает TaskCompletionSource и когда его применять?",
      "options": [
        "Для блокировки потоков",
        "Для вручную управляемого завершения Task, обёртки обратных вызовов/сигналов",
        "Для сериализации JSON",
        "Для синхронного ввода-вывода"
      ],
      "correct": 1,
      "explanation": "TCS позволяет вручную завершать задачи и мостить callback-API в awaitable-модель.",
      "difficulty": "hard"
    },
    {
      "id": 58,
      "question": "В чём риск бесконтрольного использования ConfigureAwait(false) в UI приложениях?",
      "options": [
        "Утечка сокетов",
        "Продолжение может выполняться не в UI-контексте и ломать доступ к UI",
        "Отключение GC",
        "Отключение исключений"
      ],
      "correct": 1,
      "explanation": "После await код может оказаться не в UI-контексте; доступ к UI должен быть маршалирован.",
      "difficulty": "hard"
    },
    {
      "id": 59,
      "question": "Чем опасен Thread.Sleep в ASP.NET Core обработчике?",
      "options": [
        "Ничем",
        "Блокирует поток пула, снижая пропускную способность и вызывая starvation",
        "Ускоряет обработку",
        "Снимает блокировки"
      ],
      "correct": 1,
      "explanation": "Блокировка потока уменьшает throughput. Следует использовать await Task.Delay или асинхронные API.",
      "difficulty": "hard"
    },
    {
      "id": 60,
      "question": "В чём разница между Server GC и Workstation GC?",
      "options": [
        "Server GC быстрее для однопоточности",
        "Server GC оптимизирован для многопроцессорных серверов, Workstation — для настольных систем",
        "Workstation GC всегда без пауз",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "Server GC использует несколько heap и параллелизм; Workstation нацелена на интерактивность.",
      "difficulty": "hard"
    },
    {
      "id": 61,
      "question": "Когда следует использовать ValueTask вместо Task?",
      "options": [
        "Всегда",
        "Когда часто возвращается синхронный результат и важно уменьшить аллокации",
        "Только в UI",
        "Только для I/O"
      ],
      "correct": 1,
      "explanation": "ValueTask уменьшает аллокации при часто завершении синхронно; использовать осторожно из-за сложностей повторного await.",
      "difficulty": "hard"
    },
    {
      "id": 62,
      "question": "Что такое ref struct и ограничения его использования?",
      "options": [
        "Ссылочный тип без ограничений",
        "Структура, которая должна жить на стеке; нельзя боксировать/захватывать/хранить в полях классов",
        "Обычная struct",
        "record struct с равенством по ссылке"
      ],
      "correct": 1,
      "explanation": "ref struct (например, Span<T>) ограничен областью стека, недоступен для boxing и захвата в lambda/iterator.",
      "difficulty": "hard"
    },
    {
      "id": 63,
      "question": "Как работает память больших объектов (LOH) в .NET?",
      "options": [
        "LOH собирается в каждом поколении",
        "LOH хранит большие объекты, компактификация реже; аллокации > ~85К попадают в LOH",
        "LOH — это стек",
        "LOH — для кода JIT"
      ],
      "correct": 1,
      "explanation": "Large Object Heap собирается реже и влияет на паузы; крупные массивы строк/байт попадают туда.",
      "difficulty": "hard"
    },
    {
      "id": 64,
      "question": "В чём разница между immutable и thread-safe типами?",
      "options": [
        "Нет разницы",
        "Immutable не меняет состояние, thread-safe гарантирует корректность при одновременных изменениях",
        "Thread-safe — всегда быстрее",
        "Immutable требует блокировок"
      ],
      "correct": 1,
      "explanation": "Иммутабельность упрощает потокобезопасность, но не равнозначна ей; thread-safe может включать синхронизацию.",
      "difficulty": "hard"
    },
    {
      "id": 65,
      "question": "Какие проблемы решает ReaderWriterLockSlim?",
      "options": [
        "Синхронизация только записи",
        "Разделение доступа: множество читателей или один писатель",
        "Замена Interlocked",
        "Изоляция транзакций"
      ],
      "correct": 1,
      "explanation": "RWLockSlim позволяет параллельные чтения при отсутствии записей, снижая contention.",
      "difficulty": "hard"
    },
    {
      "id": 66,
      "question": "Что такое memory barrier и как она связана с volatile?",
      "options": [
        "Это сборщик мусора",
        "Барьер упорядочивает операции памяти; volatile вводит барьеры при чтении/записи",
        "Это блокировка",
        "Это таймер"
      ],
      "correct": 1,
      "explanation": "Памятные барьеры ограничивают переупорядочивание CPU/компилятора; volatile добавляет соответствующие барьеры.",
      "difficulty": "hard"
    },
    {
      "id": 67,
      "question": "Зачем нужен ArrayPool<T>?",
      "options": [
        "Для сортировки массивов",
        "Для повторного использования буферов и снижения аллокаций",
        "Для сериализации массивов",
        "Для потоков UI"
      ],
      "correct": 1,
      "explanation": "ArrayPool<T> позволяет арендовать/возвращать массивы, уменьшая давление на GC в высоконагруженных сценариях.",
      "difficulty": "hard"
    },
    {
      "id": 68,
      "question": "Чем отличается EqualityComparer<T>.Default от object.Equals?",
      "options": [
        "Не отличается",
        "EqualityComparer<T>.Default учитывает перегрузки IEquatable<T>/Equals для T",
        "object.Equals быстрее",
        "EqualityComparer<T> игнорирует generics"
      ],
      "correct": 1,
      "explanation": "EqualityComparer<T>.Default использует оптимальные реализации равенства для типа T (включая IEquatable<T>).",
      "difficulty": "hard"
    },
    {
      "id": 69,
      "question": "Когда предпочтительно использовать struct (значимый тип)?",
      "options": [
        "Для объектов с богатыми иерархиями",
        "Для маленьких, неизменяемых значений без необходимости полиморфизма",
        "Всегда",
        "Никогда"
      ],
      "correct": 1,
      "explanation": "struct целесообразен для небольших, часто копируемых, иммутабельных значений, чтобы избежать аллокаций в куче.",
      "difficulty": "hard"
    },
    {
      "id": 70,
      "question": "Что такое source generator в Roslyn?",
      "options": [
        "Рантайм транспайлер",
        "Компиляторная надстройка, генерирующая исходный код во время компиляции",
        "JIT-оптимизатор",
        "Инструмент ILMerge"
      ],
      "correct": 1,
      "explanation": "Source generators позволяют анализировать код и добавлять сгенерированные исходники на этапе компиляции.",
      "difficulty": "hard"
    },
    {
      "id": 71,
      "question": "Как избежать утечек памяти при событиях со статическими издателями?",
      "options": [
        "Никак",
        "Явно отписываться или использовать слабые подписки",
        "Использовать GC.SuppressFinalize",
        "Кэшировать делегаты в static"
      ],
      "correct": 1,
      "explanation": "Статические события удерживают подписчиков долговременно; требуется отписка/слабые ссылки.",
      "difficulty": "hard"
    },
    {
      "id": 72,
      "question": "В чём особенность IAsyncEnumerable<T>?",
      "options": [
        "Перечисляет синхронно",
        "Позволяет асинхронное потоковое перечисление с await foreach",
        "Требует PLINQ",
        "Работает только в UI"
      ],
      "correct": 1,
      "explanation": "IAsyncEnumerable<T> возвращает элементы асинхронно; потребляется через await foreach.",
      "difficulty": "hard"
    },
    {
      "id": 73,
      "question": "Что такое Channels (System.Threading.Channels)?",
      "options": [
        "Сетевые сокеты",
        "Высокопроизводительные потокобезопасные очереди для продюсер-консюмер",
        "Файловые дескрипторы",
        "HTTP-стримы"
      ],
      "correct": 1,
      "explanation": "Channels предоставляют эффективную асинхронную передачу сообщений между продюсерами и консюмерами.",
      "difficulty": "hard"
    },
    {
      "id": 74,
      "question": "Когда стоит использовать Span<T>/Memory<T> вместо массива/строки?",
      "options": [
        "Всегда",
        "Когда важно избегать аллокаций/копирования и работать со срезами",
        "Только в UI",
        "Только с БД"
      ],
      "correct": 1,
      "explanation": "Span/Memory позволяют безопасно работать с подмассивами/буферами без дополнительных аллокаций.",
      "difficulty": "hard"
    },
    {
      "id": 75,
      "question": "Чем опасен непереопределённый GetHashCode при переопределении Equals?",
      "options": [
        "Ничем",
        "Нарушает контракт хэш-коллекций, может приводить к ошибкам поиска",
        "Ускоряет сравнение",
        "Вызывает GC"
      ],
      "correct": 1,
      "explanation": "Контракт требует согласованности Equals и GetHashCode; иначе Dictionary/HashSet работают некорректно.",
      "difficulty": "hard"
    },
    {
      "id": 76,
      "question": "Как работает пул потоков .NET (ThreadPool)?",
      "options": [
        "Создаёт поток на каждую задачу",
        "Переиспользует ограниченный набор потоков, адаптивно масштабируясь",
        "Не используется Task",
        "Только для UI"
      ],
      "correct": 1,
      "explanation": "ThreadPool переиспользует потоки, подстраивая их количество под нагрузку (Hill Climbing).",
      "difficulty": "hard"
    },
    {
      "id": 77,
      "question": "Почему небезопасно хранить ссылку на Span<T>?",
      "options": [
        "Потому что это класс",
        "Span<T> — ref struct со стековой семантикой; хранение/boxing запрещены",
        "Потому что GC",
        "Не компилируется из-за sealed"
      ],
      "correct": 1,
      "explanation": "ref struct нельзя боксировать/захватывать, иначе теряется гарантия жизненного цикла и безопасность.",
      "difficulty": "hard"
    },
    {
      "id": 78,
      "question": "В чём разница между ImmutableArray<T> и IReadOnlyList<T>?",
      "options": [
        "Оба неизменяемы гарантированно",
        "ImmutableArray<T> гарантирует неизменяемость, IReadOnlyList<T> лишь интерфейс только для чтения",
        "IReadOnlyList<T> быстрее",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "IReadOnlyList не гарантирует, что базовая коллекция неизменяемая; ImmutableArray — гарантирует.",
      "difficulty": "hard"
    },
    {
      "id": 79,
      "question": "Что такое covariance/contravariance в дженериках?",
      "options": [
        "Оптимизация JIT",
        "Совместимость направлений преобразований для параметров типа (out/in)",
        "Механизм сериализации",
        "Опция GC"
      ],
      "correct": 1,
      "explanation": "Ковариантность (out) разрешает TDerived->TBase, контравариантность (in) — обратное для параметров типа.",
      "difficulty": "hard"
    },
    {
      "id": 80,
      "question": "Как работает String.Intern и какие риски?",
      "options": [
        "Кэширует строки на LOH без ограничений",
        "Добавляет строку в пул интернирования; риск — утечки памяти при чрезмерном интернировании",
        "Сериализует строки",
        "Ускоряет GC"
      ],
      "correct": 1,
      "explanation": "Интернирование удерживает строки до завершения домена, что может привести к росту памяти.",
      "difficulty": "hard"
    },
    {
      "id": 81,
      "question": "Почему важно Dispose/await using для IAsyncDisposable?",
      "options": [
        "Не важно",
        "Корректное освобождение асинхронных ресурсов (например, потоков, сокетов)",
        "Ускоряет JIT",
        "Требуется только в UI"
      ],
      "correct": 1,
      "explanation": "IAsyncDisposable требует асинхронной очистки; await using гарантирует завершение асинхронных освобождений.",
      "difficulty": "hard"
    },
    {
      "id": 82,
      "question": "Как HttpClientFactory помогает с DNS-обновлениями?",
      "options": [
        "Никак",
        "Переиспользует SocketsHttpHandler с управлением временем жизни, учитывая DNS-обновления",
        "Создаёт новый HttpClient каждый раз",
        "Отключает кеширование DNS"
      ],
      "correct": 1,
      "explanation": "Factory управляет временем жизни хэндлера, что позволяет корректно учитывать обновления DNS.",
      "difficulty": "hard"
    },
    {
      "id": 83,
      "question": "Что такое deadlock при смешении async и sync?",
      "options": [
        "Ошибка компиляции",
        "Ситуация, когда поток блокирует ожидание, удерживая контекст, и задача ждёт возвращения контекста",
        "Сбой GC",
        "Остановка JIT"
      ],
      "correct": 1,
      "explanation": "Блокировка Result/Wait в контекстно-зависимом коде вызывает взаимную блокировку с продолжением await.",
      "difficulty": "hard"
    },
    {
      "id": 84,
      "question": "Чем отличается Newtonsoft.Json от System.Text.Json в .NET?",
      "options": [
        "Ничем",
        "System.Text.Json быстрее на типичных сценариях, но NewtonSoft функционально богаче",
        "Newtonsoft всегда быстрее",
        "System.Text.Json не поддерживает сериализацию"
      ],
      "correct": 1,
      "explanation": "System.Text.Json ориентирован на производительность и встроен, но Newtonsoft имеет больше фич/расширяемости.",
      "difficulty": "hard"
    },
    {
      "id": 85,
      "question": "Что делает stackalloc?",
      "options": [
        "Выделяет память в куче",
        "Выделяет память на стеке для локальных буферов",
        "Удаляет объект",
        "Запускает GC"
      ],
      "correct": 1,
      "explanation": "stackalloc выделяет память на стеке (Span<T>/stackalloc T[n]) для высокопроизводительных сценариев.",
      "difficulty": "hard"
    },
    {
      "id": 86,
      "question": "Зачем нужен Unsafe (System.Runtime.CompilerServices.Unsafe)?",
      "options": [
        "Для логирования",
        "Для низкоуровневых операций с памятью без проверок",
        "Для UI",
        "Для сериализации"
      ],
      "correct": 1,
      "explanation": "Unsafe предоставляет небезопасные утилиты для производительности; требует большой осторожности.",
      "difficulty": "hard"
    },
    {
      "id": 87,
      "question": "Как работает StringBuilder по части аллокаций?",
      "options": [
        "Аллоцирует новую строку при каждом Append",
        "Держит внутренний буфер и увеличивает его по мере необходимости",
        "Не аллоцирует вовсе",
        "Использует LOH всегда"
      ],
      "correct": 1,
      "explanation": "StringBuilder накапливает данные в буферах, снижая количество промежуточных строковых аллокаций.",
      "difficulty": "hard"
    },
    {
      "id": 88,
      "question": "Почему важно правильно реализовывать Dispose и финализатор?",
      "options": [
        "Чтобы ускорить JIT",
        "Для корректного освобождения неуправляемых ресурсов и избежания финализаторных пауз",
        "Чтобы включить инлайнинг",
        "Чтобы избежать boxing"
      ],
      "correct": 1,
      "explanation": "Dispose освобождает ресурсы детерминированно; финализатор — страховка, но дорогой и должен быть минимальным.",
      "difficulty": "hard"
    },
    {
      "id": 89,
      "question": "Как работает CancellationToken в связке тайм-аутов и linked tokens?",
      "options": [
        "Нельзя комбинировать",
        "Можно связывать несколько источников (CreateLinkedTokenSource) и задавать тайм-ауты",
        "Только один токен",
        "Только тайм-аут без отмены"
      ],
      "correct": 1,
      "explanation": "LinkedTokenSource объединяет отмену от нескольких источников; CTS может задавать тайм-ауты.",
      "difficulty": "hard"
    },
    {
      "id": 90,
      "question": "Что такое Structure of Arrays (SoA) vs Array of Structures (AoS) в .NET?",
      "options": [
        "Одинаково",
        "SoA хранит поля раздельно по массивам, улучшая локальность для отдельных полей",
        "AoS всегда быстрее",
        "SoA невозможен в .NET"
      ],
      "correct": 1,
      "explanation": "Выбор влияет на кэш-локальность и производительность; в .NET можно моделировать SoA вручную.",
      "difficulty": "hard"
    },
    {
      "id": 91,
      "question": "Как избежать блокировок при логировании в высоконагруженных сервисах?",
      "options": [
        "Использовать lock вокруг каждого Write",
        "Использовать неблокирующие очереди/буферы и фоновые писатели",
        "Логировать в UI-потоке",
        "Выключить логирование"
      ],
      "correct": 1,
      "explanation": "Async-логирование с буферами/очередями снижает влияние на горячие пути и contention.",
      "difficulty": "hard"
    },
    {
      "id": 92,
      "question": "Что означает агрессивное инлайнинг (MethodImplOptions.AggressiveInlining)?",
      "options": [
        "Гарантирует инлайнинг",
        "Подсказка JIT о желательности инлайнинга без гарантии",
        "Отключает инлайнинг",
        "Только для async методов"
      ],
      "correct": 1,
      "explanation": "Атрибут — лишь подсказка; JIT может проигнорировать из-за эвристик/размеров.",
      "difficulty": "hard"
    },
    {
      "id": 93,
      "question": "Почему важно избегать лишних аллокаций в горячем пути?",
      "options": [
        "Ускоряет GC и уменьшает паузы",
        "Замедляет код",
        "Не важно",
        "Только для UI"
      ],
      "correct": 0,
      "explanation": "Меньше мусора — меньше работы GC и выше предсказуемость задержек.",
      "difficulty": "hard"
    },
    {
      "id": 94,
      "question": "Как работает lock вокруг async/await?",
      "options": [
        "Безопасно использовать lock вокруг await",
        "lock не совместим с await; следует использовать SemaphoreSlim/AsyncLock",
        "await делает lock асинхронным",
        "lock ускоряет await"
      ],
      "correct": 1,
      "explanation": "await может покинуть критическую секцию; вместо lock применять SemaphoreSlim или специализированные async-замки.",
      "difficulty": "hard"
    },
    {
      "id": 95,
      "question": "Что такое false sharing и как его избежать?",
      "options": [
        "Потеря данных",
        "Конкуренция потоков из-за разделения кэш-линий; решается выравниванием/паддингом",
        "Сбой компиляции",
        "Ошибка сериализации"
      ],
      "correct": 1,
      "explanation": "Размещение горячих полей разных потоков в одной кэш-линии вызывает избыточную инвалидацию; помогает Padding/[StructLayout].",
      "difficulty": "hard"
    },
    {
      "id": 96,
      "question": "Почему важно не блокировать синхронно Result/Wait на Task в ASP.NET Core?",
      "options": [
        "Не важно",
        "Вызывает потенциальные дедлоки и утилизационные проблемы",
        "Ускоряет сервер",
        "Требуется для тайм-аутов"
      ],
      "correct": 1,
      "explanation": "Синхронная блокировка снижает масштабируемость и может дедлокить при контекстах/ресурсах.",
      "difficulty": "hard"
    },
    {
      "id": 97,
      "question": "Что такое TaskScheduler и зачем он нужен?",
      "options": [
        "Менеджер процессов ОС",
        "Компонент, определяющий, где и как выполняются задачи (например, текущий контекст/пул)",
        "Сериализатор",
        "Контроллер GC"
      ],
      "correct": 1,
      "explanation": "TaskScheduler управляет планированием задач; по умолчанию — ThreadPool, но можно переопределить.",
      "difficulty": "hard"
    },
    {
      "id": 98,
      "question": "Как снизить cost лога при отключённом уровне?",
      "options": [
        "Формировать строку заранее",
        "Использовать отложенное форматирование/проверку уровня (IsEnabled) или шаблоны",
        "Писать в Console",
        "Никак"
      ],
      "correct": 1,
      "explanation": "Проверка уровня/шаблонные API избегают лишних вычислений и аллокаций, когда лог отключён.",
      "difficulty": "hard"
    },
    {
      "id": 99,
      "question": "Зачем нужен Unsafe.SkipInit(out T)?",
      "options": [
        "Для очистки памяти",
        "Чтобы пропустить zero-init локалов для производительности (требует осторожности)",
        "Для GC",
        "Для сериализации"
      ],
      "correct": 1,
      "explanation": "SkipInit может избежать обнуления локала, но опасен при чтении неинициализированных данных.",
      "difficulty": "hard"
    },
    {
      "id": 100,
      "question": "Как использовать CancellationToken в IAsyncEnumerable<T>?",
      "options": [
        "Нельзя",
        "Передавать токен в метод-источник и использовать await foreach (var x in source.WithCancellation(token))",
        "Только через глобальную переменную",
        "Только через тайм-ауты"
      ],
      "correct": 1,
      "explanation": "IAsyncEnumerable поддерживает отмену через WithCancellation/Enumerator.MoveNextAsync(token).",
      "difficulty": "hard"
    },
    {
      "id": 101,
      "question": "Какое преимущество даёт pattern matching с ключевым словом is в C#?",
      "options": [
        "Позволяет выполнять сравнение только по ссылке",
        "Позволяет совмещать проверку типа и приведение с деструктуризацией в одном выражении",
        "Заменяет все операторы сравнения",
        "Используется только в switch"
      ],
      "correct": 1,
      "explanation": "Pattern matching с is позволяет в одном выражении проверить тип, выполнить приведение и, при необходимости, деструктурировать объект.",
      "difficulty": "medium"
    },
    {
      "id": 102,
      "question": "Чем switch-выражение отличается от классического switch-стейтмента?",
      "options": [
        "switch-выражение не может возвращать значение",
        "switch-выражение выражает выбор как выражение с результатом и поддерживает более богатые паттерны",
        "У switch-выражения обязательно нужны break",
        "Классический switch всегда быстрее"
      ],
      "correct": 1,
      "explanation": "switch-выражение возвращает значение, поддерживает exhaustiveness и сложные паттерны, в отличие от операторного switch.",
      "difficulty": "medium"
    },
    {
      "id": 103,
      "question": "Для чего используют ключевое слово when в switch-паттернах?",
      "options": [
        "Для объявления переменной",
        "Для добавления дополнительного логического условия к уже совпавшему паттерну",
        "Для обработки исключений",
        "Для объявления generic-ограничений"
      ],
      "correct": 1,
      "explanation": "when позволяет добавить guard-условие к паттерну в switch, делая ветку более точной.",
      "difficulty": "medium"
    },
    {
      "id": 104,
      "question": "Чем отличается record class от record struct?",
      "options": [
        "record class всегда значимый тип",
        "record class — ссылочный тип, record struct — значимый тип с семантикой по значению",
        "record struct не поддерживает сгенерированные методы Equals/GetHashCode",
        "record struct нельзя использовать в дженериках"
      ],
      "correct": 1,
      "explanation": "record class остаётся ссылочным типом, а record struct — значимым, оба имеют value-based equality и поддерживают сгенерированные методы.",
      "difficulty": "medium"
    },
    {
      "id": 105,
      "question": "Как работает оператор with для record-типов?",
      "options": [
        "Мутирует существующий экземпляр",
        "Создаёт копию объекта с изменением указанных свойств, оставляя исходный объект неизменным",
        "Удаляет свойства из объекта",
        "Вызывает финализатор"
      ],
      "correct": 1,
      "explanation": "with-выражение создаёт копию record с изменением выбранных свойств, что удобно для иммутабельных моделей.",
      "difficulty": "medium"
    },
    {
      "id": 106,
      "question": "Какой эффект у init-аксессора у свойств?",
      "options": [
        "Разрешает изменение свойства в любое время",
        "Разрешает присваивание только при инициализации объекта (инициализатор или конструктор)",
        "Запрещает использование свойства в конструкторах",
        "Делает свойство только для чтения"
      ],
      "correct": 1,
      "explanation": "init-only свойства можно устанавливать только в инициализаторе объекта или конструкторе, что удобно для полумутабельных DTO.",
      "difficulty": "medium"
    },
    {
      "id": 107,
      "question": "Что делает оператор ?? throw в выражении?",
      "options": [
        "Всегда бросает исключение",
        "Бросает исключение, если левый операнд равен null, иначе возвращает левый операнд",
        "Подавляет исключения",
        "Преобразует null в default"
      ],
      "correct": 1,
      "explanation": "Комбинация ?? и throw позволяет лаконично проверять аргументы и бросать исключение при null.",
      "difficulty": "medium"
    },
    {
      "id": 108,
      "question": "Как работает using-декларация (using var x = ...) по сравнению с using-блоком?",
      "options": [
        "Dispose вызывается немедленно после строки",
        "Dispose вызывается в конце области видимости, как и при using-блоке, но без дополнительного блока кода",

        "Dispose не вызывается автоматически",
        "using-декларация работает только с асинхронными ресурсами"
      ],
      "correct": 1,
      "explanation": "using-декларация регистрирует ресурс для Dispose в конце текущего блока, упрощая синтаксис по сравнению с using-блоком.",
      "difficulty": "medium"
    },
    {
      "id": 109,
      "question": "Какой из вариантов корректно объявляет async Main в консольном приложении C#?",
      "options": [
        "static void Main()",
        "static async Task Main(string[] args)",
        "public async void Main()",
        "static async void Main()"
      ],
      "correct": 1,
      "explanation": "Точка входа может быть объявлена как static async Task Main(string[] args) для использования await в Main.",
      "difficulty": "medium"
    },
    {
      "id": 110,
      "question": "Для чего используют ключевое слово global using в современных версиях C#?",
      "options": [
        "Для объявления глобальных переменных",
        "Для объявления using-директив, действующих во всей сборке без повторения в каждом файле",
        "Для включения небезопасного кода",
        "Для задания глобального пространства имён"
      ],
      "correct": 1,
      "explanation": "global using позволяет объявить импорт пространств имён один раз, сделав их доступными во всех файлах сборки.",
      "difficulty": "medium"
    },
    {
      "id": 111,
      "question": "Чем отличается top-level statements от классического Program.Main?",
      "options": [
        "Никак не отличается на уровне IL",
        "Top-level statements позволяют писать код без явного класса Program/метода Main, который компилятор сгенерирует сам",
        "Top-level statements доступны только в ASP.NET",
        "Main при этом становится абстрактным"
      ],
      "correct": 1,
      "explanation": "Top-level statements упрощают bootstrap: компилятор генерирует класс Program и Main за разработчика.",
      "difficulty": "medium"
    },
    {
      "id": 112,
      "question": "Какой тип возвращает оператор typeof(MyClass)?",
      "options": [
        "string",
        "System.Type",
        "System.Reflection.Assembly",
        "System.Object"
      ],
      "correct": 1,
      "explanation": "typeof возвращает объект System.Type, описывающий указанный тип.",
      "difficulty": "easy"
    },
    {
      "id": 113,
      "question": "Для чего используют ключевое слово checked?",
      "options": [
        "Для проверки ссылок на null",
        "Для явного включения проверки переполнения целочисленных операций",
        "Для проверки границ массива",
        "Для проверки доступа к памяти"
      ],
      "correct": 1,
      "explanation": "checked включает генерацию OverflowException при переполнении целочисленной арифметики, даже если по умолчанию проект скомпилирован без проверок.",
      "difficulty": "medium"
    },
    {
      "id": 114,
      "question": "Что делает оператор ?.[] в C#?",
      "options": [
        "Ничем не отличается от []",
        "Это null-условный индексатор: если объект слева null, возвращается null вместо обращения к индексатору",
        "Это оператор ranges",
        "Это оператор pattern matching"
      ],
      "correct": 1,
      "explanation": "?.[] позволяет безопасно вызывать индексатор для потенциально null-объекта, предотвращая NullReferenceException.",
      "difficulty": "medium"
    },
    {
      "id": 115,
      "question": "Чем отличается Range (..) от Index (^) в C#?",
      "options": [
        "Range работает только со строками, Index — только с массивами",
        "Range описывает диапазон элементов, Index описывает позицию относительно конца",
        "Index всегда считает от начала",
        "Range и Index — одно и то же"
      ],
      "correct": 1,
      "explanation": "Index (^) задаёт позицию от конца, а Range (..) задаёт диапазон элементов для срезов.",
      "difficulty": "medium"
    },
    {
      "id": 116,
      "question": "Какой интерфейс следует реализовать типу, чтобы поддержать await foreach?",
      "options": [
        "IEnumerable<T>",
        "IAsyncEnumerable<T>",
        "IEnumerator<T>",
        "IObservable<T>"
      ],
      "correct": 1,
      "explanation": "Для асинхронного перечисления используется интерфейс IAsyncEnumerable<T> и соответствующий IAsyncEnumerator<T>.",
      "difficulty": "medium"
    },
    {
      "id": 117,
      "question": "Какой эффект даёт ключевое слово required у свойств record/class?",
      "options": [
        "Делает свойство только для чтения",
        "Требует обязательной инициализации свойства при создании объекта (конструктор или инициализатор)",
        "Запрещает сериализацию свойства",
        "Делает свойство thread-safe"
      ],
      "correct": 1,
      "explanation": "required заставляет компилятор проверять, что свойство было инициализировано до завершения конструктора/инициализации.",
      "difficulty": "medium"
    },
    {
      "id": 118,
      "question": "Что такое file-scoped namespace (пространство имён с точкой с запятой)?",
      "options": [
        "Новый тип сборки",
        "Синтаксис, когда пространство имён объявляется в виде 'namespace X.Y;' и действует на весь файл без дополнительного блока",
        "Способ объявить локальное пространство имён внутри метода",
        "Старый синтаксис до C# 2.0"
      ],
      "correct": 1,
      "explanation": "File-scoped namespace избавляет от лишних уровней вложенности, распространяя объявление пространства имён на весь файл.",
      "difficulty": "medium"
    },
    {
      "id": 119,
      "question": "Для чего используется оператор stackalloc вместе с Span<T>?",
      "options": [
        "Для выделения памяти в управляемой куче",
        "Для выделения временного буфера на стеке и оборачивания его в Span<T> без дополнительной аллокации",
        "Для сериализации объектов",
        "Для блокировки потоков"
      ],
      "correct": 1,
      "explanation": "stackalloc + Span<T> позволяет работать с временными буферами на стеке, минимизируя давление на GC.",
      "difficulty": "hard"
    },
    {
      "id": 120,
      "question": "Какое преимущество даёт using static SomeClass;?",
      "options": [
        "Подключает только нестатические члены",
        "Позволяет вызывать статические члены класса без указания имени класса",
        "Включает небезопасный контекст",
        "Заменяет наследование"
      ],
      "correct": 1,
      "explanation": "using static импортирует статические члены типа в область видимости, упрощая их вызов без квалификатора.",
      "difficulty": "medium"
    },
    {
      "id": 121,
      "question": "Какой механизм в .NET используется для динамической загрузки сборок во время выполнения?",
      "options": [
        "System.GC",
        "System.Reflection (например, Assembly.Load/LoadFrom)",
        "System.Threading.Tasks",
        "System.Linq.Expressions"
      ],
      "correct": 1,
      "explanation": "Для динамической загрузки и анализа сборок используется пространство имён System.Reflection и методы Assembly.Load/LoadFrom.",
      "difficulty": "hard"
    },
    {
      "id": 122,
      "question": "Что такое dynamic и какие риски его использования?",
      "options": [
        "Тип, проверяемый компилятором как обычный generic",
        "Тип с поздним (runtime) разрешением операций, приводящий к потере статической типобезопасности и потенциальным runtime-ошибкам",
        "Синоним object",
        "Тип только для COM-интеропа, не применимый в обычном коде"
      ],
      "correct": 1,
      "explanation": "dynamic откладывает проверку членов на рантайм, что удобно для interop, но увеличивает риск RunTimeBinderException и накладные расходы.",
      "difficulty": "hard"
    },
    {
      "id": 123,
      "question": "Какой атрибут используется для указания того, что метод может быть вызван компилятором при генерации кода (например, для source generators)?",
      "options": [
        "[Obsolete]",
        "[ModuleInitializer]",
        "[CallerMemberName]",
        "[MethodImpl]"
      ],
      "correct": 1,
      "explanation": "Атрибут ModuleInitializer помечает метод, который компилятор вызывает один раз при инициализации модуля до основного кода.",
      "difficulty": "hard"
    },
    {
      "id": 124,
      "question": "Что делает атрибут [CallerMemberName] у параметра метода?",
      "options": [
        "Передаёт имя вызывающего файла",
        "Автоматически подставляет имя вызывающего члена (метода/свойства), если аргумент не указан явно",
        "Передаёт номер строки",
        "Передаёт стек вызовов"
      ],
      "correct": 1,
      "explanation": "CallerMemberName подставляет имя вызывающего члена, что удобно для реализации INotifyPropertyChanged и логирования.",
      "difficulty": "medium"
    },
    {
      "id": 125,
      "question": "Какой подход к внедрению зависимостей является стандартным в ASP.NET Core?",
      "options": [
        "Сервис-локатор",
        "Встроенный контейнер DI с регистрацией через IServiceCollection",
        "Статические синглтоны",
        "XML-конфигурация контейнера"
      ],
      "correct": 1,
      "explanation": "ASP.NET Core использует встроенный контейнер зависимостей с регистрацией сервисов в IServiceCollection (AddSingleton/Scoped/Transient).",
      "difficulty": "medium"
    },
    {
      "id": 126,
      "question": "Чем отличается Scoped-сервис от Transient в ASP.NET Core?",
      "options": [
        "Scoped создаётся на всё приложение, Transient — на запрос",
        "Scoped живёт в пределах одного HTTP-запроса/скоупа, Transient создаётся при каждом запросе зависимости",
        "Transient всегда синглтон",
        "Разницы нет"
      ],
      "correct": 1,
      "explanation": "Scoped-сервисы разделяют состояние в рамках одного запроса, тогда как Transient создаётся каждый раз при разрешении.",
      "difficulty": "medium"
    },
    {
      "id": 127,
      "question": "Для чего используют интерфейс IHostedService в .NET Generic Host?",
      "options": [
        "Для реализации контроллеров MVC",
        "Для фоновых служб, которые запускаются вместе с хостом и управляют своим жизненным циклом",
        "Для конфигурации middleware",
        "Для логирования"
      ],
      "correct": 1,
      "explanation": "IHostedService описывает фоновые службы (например, воркеры), которые стартуют/останавливаются вместе с хостом.",
      "difficulty": "medium"
    },
    {
      "id": 128,
      "question": "Что делает метод UseExceptionHandler в конвейере ASP.NET Core?",
      "options": [
        "Включает строгую проверку типов",
        "Добавляет middleware для централизованной обработки необработанных исключений и формирования стандартного ответа",
        "Отключает обработку исключений",
        "Включает логирование SQL"
      ],
      "correct": 1,
      "explanation": "UseExceptionHandler регистрирует middleware, которое перехватывает необработанные исключения и перенаправляет на указанный путь/обработчик.",
      "difficulty": "medium"
    },
    {
      "id": 129,
      "question": "Какой тип коллекции потокобезопасен для сценария \"producer-consumer\" из коробки?",
      "options": [
        "List<T>",
        "ConcurrentQueue<T>",
        "Dictionary<TKey,TValue>",
        "ObservableCollection<T>"
      ],
      "correct": 1,
      "explanation": "ConcurrentQueue<T> реализует неблокирующую потокобезопасную очередь, подходящую для producer-consumer сценариев.",
      "difficulty": "medium"
    },
    {
      "id": 130,
      "question": "Для чего применяют ключевое слово lock (object) при доступе к кэшу в многопоточном сервисе?",
      "options": [
        "Для ускорения доступа",
        "Для обеспечения взаимного исключения при чтении/записи разделяемого состояния",
        "Для включения GC",
        "Для сериализации данных"
      ],
      "correct": 1,
      "explanation": "lock защищает критические секции кода, не допуская одновременную модификацию разделяемых структур данных несколькими потоками.",
      "difficulty": "medium"
    },
    {
      "id": 131,
      "question": "Что такое middleware в ASP.NET Core?",
      "options": [
        "Фоновый поток для логирования",
        "Компонент конвейера обработки запроса/ответа, который может вызывать следующий компонент или прерывать цепочку",
        "Контроллер MVC",
        "Класс для работы с БД"
      ],
      "correct": 1,
      "explanation": "Middleware — это шаг конвейера HTTP-запроса, который может выполнять логику до/после следующего компонента или завершить обработку.",
      "difficulty": "easy"
    },
    {
      "id": 132,
      "question": "Какой жизненный цикл у Singleton-сервиса в ASP.NET Core?",
      "options": [
        "Создаётся на каждый HTTP-запрос",
        "Создаётся один раз на всё время жизни приложения",
        "Создаётся на каждый вызов контроллера",
        "Создаётся на каждый вызов метода"
      ],
      "correct": 1,
      "explanation": "Singleton-сервис создаётся один раз и переиспользуется в течение всей жизни приложения/хоста.",
      "difficulty": "easy"
    },
    {
      "id": 133,
      "question": "Какой атрибут применяется для пометки контроллера Web API в ASP.NET Core?",
      "options": [
        "[ApiController]",
        "[ControllerApi]",
        "[WebApi]",
        "[HttpApi]"
      ],
      "correct": 0,
      "explanation": "[ApiController] включает набор удобств для Web API: автоматическое приведение, проверки моделей и т.п.",
      "difficulty": "easy"
    },
    {
      "id": 134,
      "question": "Как в ASP.NET Core объявить конечную точку HTTP GET в минимальном API?",
      "options": [
        "app.MapPost(\"/items\", () => ...);",
        "app.MapGet(\"/items\", () => ...);",
        "app.UseEndpoints(\"/items\");",
        "app.Run(\"/items\");"
      ],
      "correct": 1,
      "explanation": "Для минимальных API используется MapGet/MapPost/MapPut/MapDelete и другие методы расширения на WebApplication.",
      "difficulty": "easy"
    },
    {
      "id": 135,
      "question": "Что такое Model Binding в ASP.NET Core MVC/Web API?",
      "options": [
        "Механизм DI",
        "Механизм преобразования входных данных HTTP (route, query, body, headers) в параметры методов/модели",
        "Механизм сериализации ответа",
        "Механизм логирования"
      ],
      "correct": 1,
      "explanation": "Model Binding берёт данные из запроса и заполняет параметры экшена/модели на основе имён и типов.",
      "difficulty": "medium"
    },
    {
      "id": 136,
      "question": "Для чего используется фильтр [Authorize] в ASP.NET Core?",
      "options": [
        "Для логирования запросов",
        "Для ограничения доступа к эндпоинтам на основе аутентификации/авторизации",
        "Для кэширования ответов",
        "Для валидации моделей"
      ],
      "correct": 1,
      "explanation": "[Authorize] проверяет, аутентифицирован ли пользователь и удовлетворяет ли он заданным политикам/ролям.",
      "difficulty": "easy"
    },
    {
      "id": 137,
      "question": "Что такое CancellationToken в контексте ASP.NET Core?",
      "options": [
        "Глобальный флаг завершения приложения",
        "Токен, сигнализирующий об отмене запроса (например, если клиент разорвал соединение)",
        "Токен для конфигурации DI",
        "Токен для кеширования"
      ],
      "correct": 1,
      "explanation": "HttpContext.RequestAborted предоставляет CancellationToken, который срабатывает при отмене клиентом запроса.",
      "difficulty": "medium"
    },
    {
      "id": 138,
      "question": "Какой интерфейс реализует логгер в ASP.NET Core?",
      "options": [
        "ILogger",
        "ILogger<T>",
        "ILog",
        "ILoggerFactory"
      ],
      "correct": 1,
      "explanation": "Чаще всего зависимости получают как ILogger<T>; но базовый интерфейс логгера — ILogger.",
      "difficulty": "easy"
    },
    {
      "id": 139,
      "question": "Для чего используется интерфейс IMemoryCache?",
      "options": [
        "Для распределённого кэша между сервисами",
        "Для кэша в памяти текущего процесса",
        "Для кэша на диск",
        "Для кэша в БД"
      ],
      "correct": 1,
      "explanation": "IMemoryCache реализует локальный in‑memory кэш в пределах процесса приложения.",
      "difficulty": "medium"
    },
    {
      "id": 140,
      "question": "Чем IDistributedCache отличается от IMemoryCache?",
      "options": [
        "Ничем",
        "IDistributedCache предназначен для распределённого кэша (например, Redis), IMemoryCache — только в памяти процесса",
        "IMemoryCache медленнее и всегда распределённый",
        "IDistributedCache работает только в монолитах"
      ],
      "correct": 1,
      "explanation": "IDistributedCache абстрагирует внешнее кэширующее хранилище, доступное нескольким инстансам приложения.",
      "difficulty": "medium"
    },
    {
      "id": 141,
      "question": "Что такое Health Checks в ASP.NET Core?",
      "options": [
        "Механизм логирования запросов",
        "Инфраструктура для проверки здоровья приложения и его зависимостей через стандартные эндпоинты",
        "Проверка паролей пользователей",
        "Фильтры безопасности"
      ],
      "correct": 1,
      "explanation": "Health Checks позволяют экспонировать статусы состояния приложения и внешних зависимостей (БД, кэша и т.п.).",
      "difficulty": "medium"
    },
    {
      "id": 142,
      "question": "Какой метод расширения используется для подключения Health Checks к конвейеру?",
      "options": [
        "app.UseHealthChecks();",
        "app.MapHealthChecks();",
        "app.AddHealthChecks();",
        "app.Health();"
      ],
      "correct": 1,
      "explanation": "Health Checks обычно мапятся через app.MapHealthChecks(path).",
      "difficulty": "medium"
    },
    {
      "id": 143,
      "question": "Что такое endpoint routing в ASP.NET Core?",
      "options": [
        "Система логирования",
        "Система сопоставления входящих запросов с конечными точками (эндпоинтами) и метаданными",
        "Система сериализации JSON",
        "Система DI"
      ],
      "correct": 1,
      "explanation": "Endpoint routing связывает HTTP-запросы с конечными точками (контроллеры, минимальные API и т.п.) и их метаданными.",
      "difficulty": "medium"
    },
    {
      "id": 144,
      "question": "Для чего используют атрибут [FromBody] в ASP.NET Core?",
      "options": [
        "Для чтения значения из строки запроса",
        "Для явного указания, что параметр должен быть десериализован из тела HTTP-запроса",
        "Для чтения из route-параметра",
        "Для чтения из заголовка"
      ],
      "correct": 1,
      "explanation": "[FromBody] говорит Model Binder взять данные из тела запроса (обычно JSON) и десериализовать в параметр.",
      "difficulty": "medium"
    },
    {
      "id": 145,
      "question": "Какой интерфейс реализуют фоновые задачи в ASP.NET Core, основанные на очереди?",
      "options": [
        "IHostedService",
        "IBackgroundTaskQueue",
        "IJob",
        "IAsyncAction"
      ],
      "correct": 0,
      "explanation": "Обычно фоновые задачи реализуют IHostedService/BackgroundService; очереди реализуются отдельными абстракциями поверх этого.",
      "difficulty": "medium"
    },
    {
      "id": 146,
      "question": "Что такое BackgroundService в .NET?",
      "options": [
        "Атрибут для фоновых методов",
        "Базовый абстрактный класс, реализующий паттерн фонового сервиса поверх IHostedService",
        "Класс для логирования",
        "Класс для health checks"
      ],
      "correct": 1,
      "explanation": "BackgroundService упрощает реализацию IHostedService через перегрузку метода ExecuteAsync.",
      "difficulty": "medium"
    },
    {
      "id": 147,
      "question": "Какой подход к конфигурации чаще всего применяется в ASP.NET Core?",
      "options": [
        "Жёстко зашитые константы в коде",
        "Конфигурационные провайдеры (JSON, переменные окружения, секреты) + IOptions<T>",
        "XML-конфиги только",
        "Registry Windows"
      ],
      "correct": 1,
      "explanation": "ASP.NET Core использует иерархию конфигурационных провайдеров и привязку к опциям через IOptions<T>/IOptionsSnapshot<T>.",
      "difficulty": "medium"
    },
    {
      "id": 148,
      "question": "Чем IOptionsSnapshot<T> отличается от IOptions<T>?",
      "options": [
        "Ничем",
        "IOptionsSnapshot<T> предоставляет значения на запрос и поддерживает перезагрузку конфигурации без перезапуска приложения",
        "IOptions<T> работает только в Development",
        "IOptionsSnapshot<T> доступен только в singleton-сервисах"
      ],
      "correct": 1,
      "explanation": "IOptionsSnapshot<T> создаёт снимок конфигурации на каждый HTTP-запрос и позволяет подхватывать изменения конфигов на лету.",
      "difficulty": "hard"
    },
    {
      "id": 149,
      "question": "Что такое Polly в контексте .NET приложений?",
      "options": [
        "Библиотека логирования",
        "Библиотека устойчивости (resilience) с политиками повторов, тайм-аутов, circuit breaker и т.п.",
        "Фреймворк для UI",
        "ORM для БД"
      ],
      "correct": 1,
      "explanation": "Polly предоставляет декларативные политики устойчивости для внешних вызовов: retry, circuit breaker, fallback и др.",
      "difficulty": "hard"
    },
    {
      "id": 150,
      "question": "Для чего в ASP.NET Core используют IHttpClientFactory совместно с Polly?",
      "options": [
        "Для генерации контроллеров",
        "Для конфигурации именованных/типизированных HttpClient с политиками повторов, тайм-аутов и circuit breaker",
        "Только для кэширования",
        "Только для аутентификации"
      ],
      "correct": 1,
      "explanation": "IHttpClientFactory позволяет централизованно настраивать HttpClient и навешивать на него политики устойчивости через Polly.",
      "difficulty": "hard"
    },
    {
      "id": 151,
      "question": "Что такое MediatR в типичных .NET и ASP.NET Core приложениях?",
      "options": [
        "Фреймворк для UI",
        "Библиотека реализации паттерна Mediator (CQRS, запросы/команды/notification), помогающая избавиться от жёстких связей",
        "ORM для EF Core",
        "Фреймворк тестирования"
      ],
      "correct": 1,
      "explanation": "MediatR маршрутизирует запросы/команды к их обработчикам и позволяет строить чистую архитектуру с тонкими контроллерами.",
      "difficulty": "hard"
    },
    {
      "id": 152,
      "question": "Что такое Clean Architecture в .NET-контексте?",
      "options": [
        "Архитектура с одним проектом",
        "Подход, где доменная модель и use case изолированы от инфраструктуры, UI и внешних деталей",
        "Синоним монолита",
        "Набор NuGet-пакетов"
      ],
      "correct": 1,
      "explanation": "Clean Architecture отделяет бизнес-правила от инфраструктурных деталей (БД, фреймворки), что упрощает тестирование и эволюцию системы.",
      "difficulty": "hard"
    },
    {
      "id": 153,
      "question": "Какой интерфейс в EF Core описывает контекст данных?",
      "options": [
        "IDbConnection",
        "DbContext",
        "IDbContext",
        "IDataContext"
      ],
      "correct": 1,
      "explanation": "В EF Core используется базовый класс DbContext, который описывает наборы сущностей и конфигурацию модели.",
      "difficulty": "easy"
    },
    {
      "id": 154,
      "question": "Что такое миграции в EF Core?",
      "options": [
        "Бэкапы БД",
        "Версионируемые описания изменений схемы БД, генерируемые из модели и применяемые к реальной БД",
        "Транзакции",
        "Отчёты по данным"
      ],
      "correct": 1,
      "explanation": "Миграции фиксируют изменения модели и позволяют приводить БД к нужной версии схемы.",
      "difficulty": "medium"
    },
    {
      "id": 155,
      "question": "Чем AsNoTracking() в EF Core отличается от обычного запроса?",
      "options": [
        "Ничем не отличается",
        "Запрос без отслеживания отключает change tracking, уменьшая накладные расходы для read-only сценариев",
        "Всегда кэширует результат",
        "Бросает исключение при изменении сущности"
      ],
      "correct": 1,
      "explanation": "AsNoTracking используется для чтения данных без необходимости отслеживания изменений, что уменьшает память и ускоряет запросы.",
      "difficulty": "medium"
    },
    {
      "id": 156,
      "question": "Что такое lazy loading в EF Core и чем оно опасно в Web-приложениях?",
      "options": [
        "Автоматическая загрузка зависимостей DI",
        "Отложенная загрузка навигационных свойств при первом обращении; может приводить к N+1 запросам и неожиданному доступу к БД",
        "Отложенная загрузка сборок",
        "Отложенная компиляция LINQ-запросов"
      ],
      "correct": 1,
      "explanation": "Lazy loading удобно, но может вызывать лишние запросы к БД и проблемы с контекстом/жизненным циклом в Web-приложениях.",
      "difficulty": "hard"
    },
    {
      "id": 157,
      "question": "Как реализовать паттерн Repository поверх EF Core в чистой архитектуре?",
      "options": [
        "Работать только с DbContext во всех слоях",
        "Определить интерфейсы репозиториев в доменном/аппликационном слое и реализовать их в инфраструктурном слое, инкапсулируя EF Core",
        "Создать статический класс с методами",
        "Использовать только Dapper"
      ],
      "correct": 1,
      "explanation": "Интерфейсы репозиториев находятся ближе к домену, а реализация на EF Core — во внешнем слое, внедряется через DI.",
      "difficulty": "hard"
    },
    {
      "id": 158,
      "question": "Что такое Dapper в .NET экосистеме?",
      "options": [
        "Полноценный ORM",
        "Micro-ORM, облегчающий маппинг SQL-результатов на объекты с минимальными накладными расходами",
        "Фреймворк для UI",
        "Система логирования"
      ],
      "correct": 1,
      "explanation": "Dapper — лёгкий micro-ORM поверх ADO.NET, фокусирующийся на скорости и явных SQL-запросах.",
      "difficulty": "medium"
    },
    {
      "id": 159,
      "question": "Чем транзакция в ADO.NET/EF Core помогает при работе с БД?",
      "options": [
        "Ускоряет запросы",
        "Гарантирует атомарность, согласованность, изолированность и долговечность (ACID) набора операций",
        "Отключает блокировки",
        "Упрощает логирование"
      ],
      "correct": 1,
      "explanation": "Транзакция обеспечивает, что набор операций над БД либо успешно выполняется целиком, либо полностью откатывается.",
      "difficulty": "medium"
    },
    {
      "id": 160,
      "question": "Что такое Unit of Work в контексте доступа к данным?",
      "options": [
        "Интерфейс логирования",
        "Абстракция, координирующая работу репозиториев и транзакций в рамках одного логического юнита работы",
        "Класс для health checks",
        "Обёртка вокруг HttpClient"
      ],
      "correct": 1,
      "explanation": "Unit of Work агрегирует операции репозиториев и позволяет атомарно сохранить изменения в БД.",
      "difficulty": "hard"
    },
    {
      "id": 161,
      "question": "Что такое CQRS в архитектуре .NET приложений?",
      "options": [
        "Шаблон логирования",
        "Подход, разделяющий модели/операции чтения (Query) и записи (Command) для упрощения масштабирования и оптимизации",
        "Фреймворк UI",
        "Тип транзакции"
      ],
      "correct": 1,
      "explanation": "CQRS разделяет ответственность: чтение и запись могут иметь разные модели, стеки и хранилища.",
      "difficulty": "hard"
    },
    {
      "id": 162,
      "question": "Что такое idempotent команда в Web API?",
      "options": [
        "Команда, которая всегда возвращает разные результаты",
        "Команда, которую можно безопасно выполнить несколько раз, не изменяя результат после первого успешного выполнения",
        "Команда, которая всегда приводит к ошибке",
        "Команда только для чтения"
      ],
      "correct": 1,
      "explanation": "Идемпотентность важна для повторов запросов: повторное выполнение не должно менять состояние сверх первого раза.",
      "difficulty": "hard"
    },
    {
      "id": 163,
      "question": "Какие HTTP-методы по спецификации считаются безопасными (safe)?",
      "options": [
        "GET, HEAD, OPTIONS, TRACE",
        "POST и PUT",
        "DELETE и PATCH",
        "Только GET"
      ],
      "correct": 0,
      "explanation": "Безопасные методы не должны изменять состояние ресурса на сервере, только читать.",
      "difficulty": "medium"
    },
    {
      "id": 164,
      "question": "Какие HTTP-методы считаются идемпотентными?",
      "options": [
        "GET, PUT, DELETE, HEAD, OPTIONS, TRACE",
        "Только POST",
        "Только GET",
        "Все методы"
      ],
      "correct": 0,
      "explanation": "Идемпотентные методы допускают повторный вызов без дополнительного изменения состояния после первого успешного запроса.",
      "difficulty": "medium"
    },
    {
      "id": 165,
      "question": "Какой статус-код HTTP обычно возвращают при успешном создании ресурса?",
      "options": [
        "200",
        "201",
        "204",
        "304"
      ],
      "correct": 1,
      "explanation": "201 Created применяется при успешном создании нового ресурса на сервере.",
      "difficulty": "easy"
    },
    {
      "id": 166,
      "question": "Что обозначает статус-код 204 No Content?",
      "options": [
        "Ошибка сервера",
        "Успешный запрос без тела ответа",
        "Редирект",
        "Неавторизованный доступ"
      ],
      "correct": 1,
      "explanation": "204 означает, что запрос успешно выполнен, но тело ответа отсутствует.",
      "difficulty": "easy"
    },
    {
      "id": 167,
      "question": "Что такое optimistic concurrency control в EF Core?",
      "options": [
        "Всегда блокировать строки в БД",
        "Контроль конкурентных обновлений через версии/штампы (rowversion, concurrency tokens) без длительных блокировок",
        "Использование только транзакций",
        "Отключение конкуренции"
      ],
      "correct": 1,
      "explanation": "Оптимистичная блокировка предполагает, что конфликты редки и решаются при сохранении изменений с проверкой версии.",
      "difficulty": "hard"
    },
    {
      "id": 168,
      "question": "Что такое circuit breaker в устойчивых распределённых системах?",
      "options": [
        "Механизм кэширования",
        "Паттерн, который временно блокирует вызовы к заведомо нестабильной зависимости, чтобы избежать каскадных отказов",
        "Тип транзакции",
        "Механизм аутентификации"
      ],
      "correct": 1,
      "explanation": "Circuit breaker переводит зависимость в состояние открытого/полуоткрытого переключателя после серии ошибок, предотвращая перегрузку.",
      "difficulty": "hard"
    },
    {
      "id": 169,
      "question": "Зачем использовать correlation ID в микросервисной архитектуре?",
      "options": [
        "Для кэширования",
        "Для сквозной трассировки запроса через несколько сервисов",
        "Для шифрования",
        "Для версионирования API"
      ],
      "correct": 1,
      "explanation": "Correlation ID помогает связать логи и трассировки по цепочке вызовов между сервисами.",
      "difficulty": "medium"
    },
    {
      "id": 170,
      "question": "Что такое idempotent consumer в messaging-системах (Kafka, RabbitMQ)?",
      "options": [
        "Консюмер, который всегда падает при ошибке",
        "Консюмер, который обрабатывает дубликаты сообщений без изменения итогового состояния",
        "Консюмер только для чтения",
        "Консюмер, который не использует ACK/NACK"
      ],
      "correct": 1,
      "explanation": "Идемпотентный консюмер умеет безопасно обрабатывать повторно доставленные сообщения, не дублируя эффекты.",
      "difficulty": "hard"
    },
    {
      "id": 171,
      "question": "Что такое outbox-паттерн в микросервисах?",
      "options": [
        "Стратегия кеширования",
        "Паттерн, при котором события для шины сообщений сначала записываются в таблицу БД в той же транзакции, что и бизнес-данные, а затем асинхронно публикуются",
        "Механизм health checks",
        "Паттерн авторизации"
      ],
      "correct": 1,
      "explanation": "Outbox помогает избегать несогласованности между БД и брокером сообщений, используя транзакцию БД как источник истины.",
      "difficulty": "hard"
    },
    {
      "id": 172,
      "question": "Что такое saga-паттерн в распределённых транзакциях?",
      "options": [
        "Сигнализация об ошибке",
        "Оркестрация или хореография серии локальных транзакций с компенсирующими действиями вместо глобальной распределённой транзакции",
        "Тип кэширования",
        "Паттерн health checks"
      ],
      "correct": 1,
      "explanation": "Саги позволяют строить долгоживущие бизнес-процессы без 2PC, используя компенсирующие операции при ошибках.",
      "difficulty": "hard"
    },
    {
      "id": 173,
      "question": "Что такое API Gateway в микросервисной архитектуре на .NET?",
      "options": [
        "Любой контроллер",
        "Фасад, принимающий внешние запросы и маршрутизирующий их на внутренние сервисы, реализующий кросс-срезочные функции (аутентификация, rate limiting и т.п.)",
        "SQL-сервер",
        "Очередь сообщений"
      ],
      "correct": 1,
      "explanation": "API Gateway скрывает внутреннюю топологию сервисов и реализует общие политики безопасности, кеширования и маршрутизации.",
      "difficulty": "medium"
    },
    {
      "id": 174,
      "question": "Что такое rate limiting в Web API?",
      "options": [
        "Кэширование результатов",
        "Ограничение числа запросов за единицу времени для клиента/токена/ключа",
        "Балансировка нагрузки между серверами",
        "Шифрование запросов"
      ],
      "correct": 1,
      "explanation": "Rate limiting защищает API от злоупотреблений и помогает справедливо распределять ресурсы.",
      "difficulty": "medium"
    },
    {
      "id": 175,
      "question": "Какой встроенный middleware ASP.NET Core отвечает за сжатие ответа?",
      "options": [
        "UseResponseCaching",
        "UseResponseCompression",
        "UseHsts",
        "UseStaticFiles"
      ],
      "correct": 1,
      "explanation": "UseResponseCompression включает сжатие HTTP-ответов (gzip, br) в зависимости от настроек и заголовков.",
      "difficulty": "easy"
    },
    {
      "id": 176,
      "question": "Что делает middleware UseResponseCaching?",
      "options": [
        "Включает сжатие ответа",
        "Включает кэширование ответов на стороне сервера на основе заголовков Cache-Control",
        "Включает логирование",
        "Включает health checks"
      ],
      "correct": 1,
      "explanation": "Response Caching позволяет серверу кешировать ответы и отдавать их без повторного выполнения логики.",
      "difficulty": "medium"
    },
    {
      "id": 177,
      "question": "Что такое CORS и зачем он нужен в Web API?",
      "options": [
        "Механизм логирования",
        "Механизм контроля междоменных запросов из браузера (разрешение/запрет доступа к ресурсам с других доменов)",
        "Механизм кеширования",
        "Механизм аутентификации"
      ],
      "correct": 1,
      "explanation": "CORS определяет, какие домены могут обращаться к ресурсам API из браузера (через заголовки Access-Control-*).",
      "difficulty": "easy"
    },
    {
      "id": 178,
      "question": "Чем отличается authentication от authorization в ASP.NET Core?",
      "options": [
        "Authentication отвечает за разрешения, authorization — за установление личности",
        "Authentication устанавливает личность (кто пользователь), authorization решает, что ему разрешено делать",
        "Они идентичны",
        "Оба относятся только к JWT"
      ],
      "correct": 1,
      "explanation": "Сначала происходит аутентификация (установление пользователя), затем авторизация (проверка прав).",
      "difficulty": "easy"
    },
    {
      "id": 179,
      "question": "Что такое JWT в ASP.NET Core аутентификации?",
      "options": [
        "Формат XML-конфигурации",
        "JSON Web Token — компактный токен с набором claims, подписанный (и иногда зашифрованный)",
        "Тип лог-файла",
        "Тип HTTP-заголовка"
      ],
      "correct": 1,
      "explanation": "JWT широко используется для Bearer-аутентификации в SPA и мобильных клиентах.",
      "difficulty": "medium"
    },
    {
      "id": 180,
      "question": "Какой интерфейс описывает текущего пользователя в ASP.NET Core?",
      "options": [
        "IUserContext",
        "ClaimsPrincipal",
        "IIdentityUser",
        "SecurityUser"
      ],
      "correct": 1,
      "explanation": "HttpContext.User имеет тип ClaimsPrincipal и хранит набор claims текущего пользователя.",
      "difficulty": "easy"
    },
    {
      "id": 181,
      "question": "Что такое HostedService в Kubernetes-деплое .NET приложения?",
      "options": [
        "Тип pod",
        "Фоновая служба .NET (IHostedService/BackgroundService), которая будет работать внутри контейнера",
        "Тип ingress",
        "Тип volume"
      ],
      "correct": 1,
      "explanation": "HostedService — это .NET-абстракция фоновых задач, которая спокойно работает внутри контейнеров Kubernetes.",
      "difficulty": "medium"
    },
    {
      "id": 182,
      "question": "Что такое readiness probe для .NET сервиса в Kubernetes?",
      "options": [
        "Проверка логов",
        "Проверка готовности сервиса принимать трафик (часто реализуется через health check endpoint)",
        "Проверка использования CPU",
        "Проверка версии .NET"
      ],
      "correct": 1,
      "explanation": "Readiness probe определяет, когда pod готов обрабатывать запросы; пока нет — не включается в балансировку.",
      "difficulty": "medium"
    },
    {
      "id": 183,
      "question": "Что такое liveness probe для .NET сервиса в Kubernetes?",
      "options": [
        "Проверка конфигурации",
        "Проверка жив ли процесс/приложение; при провале Kubernetes перезапускает контейнер",
        "Проверка версии API",
        "Проверка TLS"
      ],
      "correct": 1,
      "explanation": "Liveness probe помогает Kubernetes обнаружить зависшие/сломанные контейнеры и перезапустить их.",
      "difficulty": "medium"
    },
    {
      "id": 184,
      "question": "Что означает термин \"backpressure\" в системах с очередями/стримингом?",
      "options": [
        "Увеличение памяти",
        "Механизм, когда потребитель сигнализирует продюсеру о своём лимите, предотвращая переполнение",
        "Тип кэширования",
        "Механизм health checks"
      ],
      "correct": 1,
      "explanation": "Backpressure позволяет системе сдерживать скорость продюсера, если потребители не успевают обрабатывать сообщения.",
      "difficulty": "hard"
    },
    {
      "id": 185,
      "question": "Какой протокол чаще всего используется для gRPC в .NET?",
      "options": [
        "HTTP/1.1",
        "HTTP/2",
        "WebSocket",
        "TCP-сокеты без HTTP"
      ],
      "correct": 1,
      "explanation": "gRPC поверх HTTP/2 даёт мультиплексирование потоков и эффективную бинарную сериализацию.",
      "difficulty": "medium"
    },
    {
      "id": 186,
      "question": "Что такое Protobuf в контексте gRPC сервисов на .NET?",
      "options": [
        "Формат логов",
        "Бинарный формат сериализации данных и язык описания контрактов (proto-файлы)",
        "Формат конфигурации",
        "Формат SQL-запросов"
      ],
      "correct": 1,
      "explanation": "Protocol Buffers используются для описания сообщений и сервисов gRPC и последующей генерации C#-кода.",
      "difficulty": "medium"
    },
    {
      "id": 187,
      "question": "Для чего используют SpanJson/System.Text.Json Source Generators в .NET?",
      "options": [
        "Для логирования",
        "Для генерации оптимизированного кода сериализации/десериализации JSON на этапе компиляции",
        "Для миграций БД",
        "Для DI"
      ],
      "correct": 1,
      "explanation": "Source generators позволяют создать строго типизированный, высокопроизводительный код сериализации без reflection во время рантайма.",
      "difficulty": "hard"
    },
    {
      "id": 188,
      "question": "Что такое Hot Reload в .NET?",
      "options": [
        "Перезапуск процесса при изменении кода",
        "Возможность вносить изменения в работающие приложения и видеть результат без полного перезапуска",
        "Автоматическая миграция БД",
        "Функция GC"
      ],
      "correct": 1,
      "explanation": "Hot Reload ускоряет цикл разработки, позволяя менять код и обновлять поведение приложения на лету.",
      "difficulty": "easy"
    },
    {
      "id": 189,
      "question": "Что такое minimal APIs в ASP.NET Core?",
      "options": [
        "Отдельный фреймворк",
        "Лёгкий способ определения HTTP-эндпоинтов без контроллеров и лишнего шаблонного кода",
        "Только для gRPC",
        "Только для SignalR"
      ],
      "correct": 1,
      "explanation": "Minimal APIs позволяют описывать эндпоинты через MapGet/MapPost и лямбды, что хорошо подходит для микросервисов и простых API.",
      "difficulty": "easy"
    },
    {
      "id": 190,
      "question": "Что такое SignalR в ASP.NET Core?",
      "options": [
        "Библиотека для работы с БД",
        "Библиотека для двусторонней реального времени коммуникации между сервером и клиентами (WebSocket/Long Polling и др.)",
        "Библиотека логирования",
        "Библиотека health checks"
      ],
      "correct": 1,
      "explanation": "SignalR упрощает реализацию real-time функциональности: чаты, уведомления, трекинг и т.п.",
      "difficulty": "medium"
    },
    {
      "id": 191,
      "question": "Какой интерфейс реализует хаб в SignalR?",
      "options": [
        "IHub",
        "Наследование от Hub",
        "IAsyncHub",
        "IRealtimeHub"
      ],
      "correct": 1,
      "explanation": "Хаб реализуется через наследование от класса Hub или Hub<T>.",
      "difficulty": "easy"
    },
    {
      "id": 192,
      "question": "Какой механизм сериализации по умолчанию использует ASP.NET Core Web API в современных версиях?",
      "options": [
        "Newtonsoft.Json",
        "System.Text.Json",
        "BinaryFormatter",
        "XmlSerializer"
      ],
      "correct": 1,
      "explanation": "Начиная с ASP.NET Core 3+, по умолчанию используется System.Text.Json как сериализатор JSON.",
      "difficulty": "easy"
    },
    {
      "id": 193,
      "question": "Как включить Newtonsoft.Json вместо System.Text.Json в ASP.NET Core?",
      "options": [
        "Нельзя",
        "Добавить пакет Microsoft.AspNetCore.Mvc.NewtonsoftJson и вызвать AddNewtonsoftJson() при настройке MVC",
        "Заменить все контроллеры",
        "Поменять версию .NET"
      ],
      "correct": 1,
      "explanation": "Расширение AddNewtonsoftJson позволяет заменить System.Text.Json на Newtonsoft.Json для MVC/Web API.",
      "difficulty": "medium"
    },
    {
      "id": 194,
      "question": "Что такое HostBuilder/Generic Host в .NET?",
      "options": [
        "Только для консольных приложений",
        "Общая абстракция хоста приложения (конфигурация, DI, логирование, HostedServices) для разных типов приложений",
        "Фреймворк для UI",
        "Только для тестов"
      ],
      "correct": 1,
      "explanation": "Generic Host объединяет конфигурацию, DI, logging и жизненный цикл приложения в единую модель.",
      "difficulty": "medium"
    },
    {
      "id": 195,
      "question": "Что такое WebApplication в ASP.NET Core 6+?",
      "options": [
        "Пакет NuGet",
        "Упрощённая оболочка над HostBuilder/WebHost, объединяющая настройку и запуск Web-приложения",
        "Класс контроллера",
        "Middleware"
      ],
      "correct": 1,
      "explanation": "WebApplication и WebApplicationBuilder упрощают bootstrap ASP.NET Core приложений с минимальным кодом.",
      "difficulty": "easy"
    },
    {
      "id": 196,
      "question": "Какой паттерн часто применяют для конфигурации pipelines, клиентов и зависимостей в .NET?",
      "options": [
        "Builder",
        "Strategy",
        "Visitor",
        "Decorator"
      ],
      "correct": 0,
      "explanation": "Builder-подход позволяет пошагово конфигурировать сложные объекты/платформы (HostBuilder, WebApplicationBuilder, HttpClientFactory и др.).",
      "difficulty": "medium"
    },
    {
      "id": 197,
      "question": "Что такое ILoggerFactory в .NET?",
      "options": [
        "Фабрика HttpClient",
        "Фабрика логгеров, позволяющая создавать экземпляры ILogger и регистрировать провайдеров логирования",
        "Фабрика DbContext",
        "Фабрика HostedService"
      ],
      "correct": 1,
      "explanation": "ILoggerFactory управляет провайдерами логирования и создаёт ILogger по категориям/типам.",
      "difficulty": "medium"
    },
    {
      "id": 198,
      "question": "Какой интерфейс описывает абстракцию времени в .NET для тестируемости?",
      "options": [
        "IDateTime",
        "IClock/ITimeProvider (или встроенный TimeProvider в .NET 8)",
        "ITimer",
        "IDateProvider"
      ],
      "correct": 1,
      "explanation": "Выделение абстракции времени (IClock, TimeProvider) позволяет тестировать код, зависящий от текущего времени.",
      "difficulty": "hard"
    },
    {
      "id": 199,
      "question": "Что такое flaky-тесты в .NET проектах?",
      "options": [
        "Тесты, которые всегда зелёные",
        "Тесты, которые иногда проходят, а иногда падают без изменения кода из-за таймингов, внешних зависимостей и т.п.",
        "Тесты производительности",
        "Интеграционные тесты"
      ],
      "correct": 1,
      "explanation": "Flaky-тесты подрывают доверие к CI и требуют устранения источников нестабильности (задержки, race conditions, внешние сервисы).",
      "difficulty": "medium"
    },
    {
      "id": 200,
      "question": "Какой подход к тестированию ASP.NET Core Web API считается хорошей практикой?",
      "options": [
        "Тестировать только приватные методы контроллеров",
        "Писать unit-тесты бизнес-логики и интеграционные/functional-тесты поверх TestServer/WebApplicationFactory",
        "Проверять только наличие контроллеров",
        "Полагаться исключительно на ручное тестирование через Postman"
      ],
      "correct": 1,
      "explanation": "Комбинация unit-тестов для домена и интеграционных/functional-тестов для API даёт хорошее покрытие без излишней хрупкости.",
      "difficulty": "hard"
    },
    {
      "id": 201,
      "question": "Какие слои обычно выделяют в Clean Architecture для .NET?",
      "options": [
        "UI, Application, Domain, Infrastructure",
        "Controllers, Services, Repositories",
        "Views, ViewModels, Migrations",
        "Core, Utils, Common"
      ],
      "correct": 0,
      "explanation": "Классическая Clean Architecture предполагает слои UI (внешний), Application (use cases), Domain (модель и правила), Infrastructure (внешние реализации). Зависимости направлены внутрь к домену.",
      "difficulty": "medium"
    },
    {
      "id": 202,
      "question": "Где должны жить бизнес-правила в Clean Architecture?",
      "options": [
        "В слое Infrastructure",
        "В слое Domain",
        "В слое UI",
        "В БД (хранимые процедуры)"
      ],
      "correct": 1,
      "explanation": "Бизнес-правила и инварианты домена размещаются в слое Domain; внешние детали (БД, сеть) изолируются во внешних слоях.",
      "difficulty": "easy"
    },
    {
      "id": 203,
      "question": "Что такое Aggregate Root в DDD?",
      "options": [
        "Любая сущность с Id",
        "Корневая сущность, контролирующая инварианты и границы транзакций в агрегате",
        "ORM-модель EF Core",
        "Таблица БД с внешними ключами"
      ],
      "correct": 1,
      "explanation": "Aggregate Root определяет границы модификаций и инвариантов. Все изменения внутри агрегата происходят через корневую сущность, обеспечивая согласованность.",
      "difficulty": "medium"
    },
    {
      "id": 204,
      "question": "За что отвечает Application-слой в Clean Architecture?",
      "options": [
        "За хранение данных",
        "За реализацию use-case (команды/запросы), оркестрацию домена и портов",
        "За рендеринг UI",
        "За настройку веб-сервера"
      ],
      "correct": 1,
      "explanation": "Application-слой инкапсулирует сценарии использования, координирует доменную модель и взаимодействует с абстракциями инфраструктуры (порты).",
      "difficulty": "easy"
    },
    {
      "id": 205,
      "question": "Чем отличается Command от Query в CQRS?",
      "options": [
        "Command только читает, Query только пишет",
        "Command изменяет состояние и не возвращает данных (или минимальные), Query не изменяет состояние и возвращает данные",
        "Command и Query идентичны",
        "Command всегда асинхронен, Query — синхронен"
      ],
      "correct": 1,
      "explanation": "В CQRS команды меняют состояние и часто не возвращают сложные DTO, запросы предназначены для чтения и не должны изменять состояние.",
      "difficulty": "easy"
    },
    {
      "id": 206,
      "question": "Что хранится при Event Sourcing?",
      "options": [
        "Только текущее состояние",
        "Последовательность событий, из которых восстанавливается текущее состояние",
        "Только снимки (snapshots)",
        "Только логи запросов"
      ],
      "correct": 1,
      "explanation": "Event Sourcing хранит поток доменных событий. Состояние агрегата восстанавливается воспроизведением событий (иногда с периодическими снапшотами).",
      "difficulty": "hard"
    },
    {
      "id": 207,
      "question": "Что такое Bounded Context в DDD?",
      "options": [
        "Сущность с ограниченным размером",
        "Ясно очерченная граница модели и терминов, внутри которой действуют согласованные правила",
        "Слой инфраструктуры",
        "Класс доменной модели"
      ],
      "correct": 1,
      "explanation": "Bounded Context задаёт границы терминов и инвариантов. Разные контексты могут по-разному интерпретировать одни и те же термины, снижая связность.",
      "difficulty": "medium"
    },
    {
      "id": 208,
      "question": "Когда уместнее выбрать gRPC вместо REST в .NET микросервисах?",
      "options": [
        "Когда нужен простой доступ из браузера",
        "Для высокопроизводительной бинарной связи сервис-сервис, строгих контрактов и стриминга",
        "Когда требуется кэширование CDN",
        "Когда нужен HTML-рендеринг"
      ],
      "correct": 1,
      "explanation": "gRPC по HTTP/2 с Protobuf даёт компактность и скорость, подходит для межсервисного взаимодействия и стриминга; для публичных веб-API чаще выбирают REST/HTTP.",
      "difficulty": "medium"
    },
    {
      "id": 209,
      "question": "Какой подход к версионированию REST API считается корректным?",
      "options": [
        "Изменять контракты без уведомления",
        "Использовать версионирование (URI/заголовки) и сохранять обратную совместимость",
        "Удалять старые поля сразу после релиза",
        "Всегда использовать только v1"
      ],
      "correct": 1,
      "explanation": "Версионирование (например, /v1, заголовки) и бережная эволюция контрактов с обратной совместимостью — стандартная практика для веб-API.",
      "difficulty": "easy"
    },
    {
      "id": 210,
      "question": "Какой HTTP-метод по семантике наиболее подходит для идемпотентного обновления ресурса?",
      "options": [
        "POST",
        "PUT",
        "PATCH",
        "CONNECT"
      ],
      "correct": 1,
      "explanation": "PUT по спецификации идемпотентен: повторные одинаковые PUT-запросы приводят к одному и тому же состоянию ресурса.",
      "difficulty": "easy"
    },
    {
      "id": 211,
      "question": "Что такое Idempotency Key в Web API?",
      "options": [
        "Секретный ключ аутентификации",
        "Ключ запроса, позволяющий серверу распознать повтор и предотвратить дублирование побочных эффектов",
        "Ключ шифрования JWT",
        "Ключ для кеша CSS"
      ],
      "correct": 1,
      "explanation": "Idempotency Key позволяет безопасно повторять небезопасные операции (например, платежи), избегая дублирования при ретраях.",
      "difficulty": "medium"
    },
    {
      "id": 212,
      "question": "Какие заголовки используются для сквозной трассировки по стандарту W3C?",
      "options": [
        "X-Trace, X-Span",
        "traceparent и tracestate",
        "Request-Id и Correlation-Id",
        "X-Request, X-Correlation"
      ],
      "correct": 1,
      "explanation": "Стандарт W3C Trace Context определяет заголовки traceparent и tracestate для передачи контекста трассировки между сервисами.",
      "difficulty": "medium"
    },
    {
      "id": 213,
      "question": "Что включает наблюдаемость (observability) в современных .NET сервисах?",
      "options": [
        "Только логи",
        "Трейсы, метрики и логи (часто через OpenTelemetry)",
        "Только метрики",
        "Только профилировщик"
      ],
      "correct": 1,
      "explanation": "Наблюдаемость строится на триаде traces-metrics-logs, стандартно собираемых и переносимых через OpenTelemetry и совместимые бекенды.",
      "difficulty": "easy"
    },
    {
      "id": 214,
      "question": "Как прокинуть Correlation ID через ASP.NET Core?",
      "options": [
        "Игнорировать его",
        "Добавить middleware, читающее/создающее ID и записывающее его в лог-контекст и заголовки",
        "Сохранять в static поле",
        "Передавать в query string всегда"
      ],
      "correct": 1,
      "explanation": "Middleware может читать входящий Correlation/Trace ID, создавать при отсутствии, класть в лог-контекст и заголовки ответов и исходящих запросов.",
      "difficulty": "medium"
    },
    {
      "id": 215,
      "question": "Какая стратегия повторов (retry) обычно предпочтительна для временных ошибок?",
      "options": [
        "Бесконечные ретраи без пауз",
        "Экспоненциальная задержка с джиттером",
        "Линейная задержка без ограничений",
        "Мгновенные повторы без задержки"
      ],
      "correct": 1,
      "explanation": "Экспоненциальный backoff с джиттером снижает синхронизацию шипов нагрузки и уменьшает давление на зависимость.",
      "difficulty": "medium"
    },
    {
      "id": 216,
      "question": "Что означает состояние Half-Open у circuit breaker (Polly)?",
      "options": [
        "Полностью закрыт",
        "Ограниченно пропускает запросы для проверки восстановления зависимости",
        "Всегда открытый",
        "Игнорирует ошибки"
      ],
      "correct": 1,
      "explanation": "Half-Open позволяет небольшому числу запросов пройти; если успешны — breaker закрывается, иначе вновь открывается.",
      "difficulty": "medium"
    },
    {
      "id": 217,
      "question": "Что делает паттерн Bulkhead в устойчивых системах?",
      "options": [
        "Ускоряет GC",
        "Изолирует ресурсы/пулы, чтобы сбой одной подсистемы не валил всю систему",
        "Шифрует сообщения",
        "Компрессирует ответы"
      ],
      "correct": 1,
      "explanation": "Bulkhead (переборки) разделяет ресурсы по отсекам, ограничивая влияние проблем в одной части на остальные.",
      "difficulty": "hard"
    },
    {
      "id": 218,
      "question": "Как настроить таймауты исходящих HTTP-запросов в .NET с IHttpClientFactory?",
      "options": [
        "Использовать Thread.Sleep",
        "Задать Timeout у HttpClient и/или политику Polly TimeoutPolicy",
        "Отключить таймауты",
        "Использовать GC.Collect"
      ],
      "correct": 1,
      "explanation": "Таймауты на уровне HttpClient и дополнительно через Polly TimeoutPolicy позволяют ограничить время ожидания зависимостей.",
      "difficulty": "easy"
    },
    {
      "id": 219,
      "question": "Для чего используют Fallback-политику в Polly?",
      "options": [
        "Для записей в БД",
        "Для возврата альтернативного результата при ошибках после ретраев/таймаутов",
        "Для кеширования",
        "Для шифрования"
      ],
      "correct": 1,
      "explanation": "Fallback позволяет вернуть безопасный дефолт/кеш/заглушку, когда основной путь отказал после остальных политик.",
      "difficulty": "medium"
    },
    {
      "id": 220,
      "question": "Что такое hedging (репликация запросов) и когда применять?",
      "options": [
        "Дублирование логов",
        "Отправка параллельных запросов к нескольким репликам для снижения хвостовой латентности",
        "Увеличение таймаутов",
        "Сжатие ответов"
      ],
      "correct": 1,
      "explanation": "Hedging снижает хвостовые задержки, отправляя копии запросов на альтернативные инстансы; требует бережного контроля нагрузки и идемпотентности.",
      "difficulty": "hard"
    },
    {
      "id": 221,
      "question": "Как включить rate limiting в ASP.NET Core 7+?",
      "options": [
        "app.UseResponseCompression()",
        "services.AddRateLimiter(); app.UseRateLimiter();",
        "app.UseHsts()",
        "app.UseEndpoints()"
      ],
      "correct": 1,
      "explanation": "Нужно зарегистрировать службы rate limiter и добавить middleware UseRateLimiter с нужной конфигурацией ограничений.",
      "difficulty": "easy"
    },
    {
      "id": 222,
      "question": "Чем Response Caching отличается от клиентского Cache-Control?",
      "options": [
        "Ничем",
        "Response Caching — серверное кеширование в ASP.NET Core, Cache-Control — директивы для клиентов/промежуточных прокси",
        "Cache-Control шифрует ответ",
        "Response Caching работает только в браузере"
      ],
      "correct": 1,
      "explanation": "Response Caching — middleware/серверные механизмы; заголовки Cache-Control управляют поведением клиентов и прокси по стандарту HTTP.",
      "difficulty": "medium"
    },
    {
      "id": 223,
      "question": "Для чего используется ETag в HTTP?",
      "options": [
        "Для аутентификации",
        "Для условных запросов и экономии трафика через If-None-Match",
        "Для шифрования",
        "Для CORS"
      ],
      "correct": 1,
      "explanation": "ETag позволяет клиенту отправлять условные запросы; сервер возвращает 304 Not Modified, если ресурс не изменился.",
      "difficulty": "easy"
    },
    {
      "id": 224,
      "question": "Что делает идемпотентный консюмер в очереди сообщений?",
      "options": [
        "Всегда обрабатывает только новые сообщения",
        "Обрабатывает дубликаты без изменения итогового состояния",
        "Удаляет все дубликаты",
        "Отключает подтверждения"
      ],
      "correct": 1,
      "explanation": "Идемпотентный обработчик обеспечивает одинаковый конечный результат даже при повторной обработке идентичных сообщений.",
      "difficulty": "medium"
    },
    {
      "id": 225,
      "question": "Какой уровень доставки чаще всего гарантируют брокеры сообщений (Kafka/RabbitMQ)?",
      "options": [
        "Exactly once всегда",
        "At-least-once по умолчанию",
        "At-most-once невозможно",
        "Exactly once без настроек"
      ],
      "correct": 1,
      "explanation": "Типично брокеры обеспечивают как минимум доставку (at-least-once), поэтому потребители должны быть идемпотентны.",
      "difficulty": "hard"
    },
    {
      "id": 226,
      "question": "Что обеспечивает outbox-паттерн в микросервисах?",
      "options": [
        "Повышенную производительность сериализации",
        "Надёжную публикацию событий синхронно с записью бизнес-данных (atomicity)",
        "Шифрование данных",
        "Удалённую конфигурацию"
      ],
      "correct": 1,
      "explanation": "Outbox записывает событие в таблицу вместе с бизнес-транзакцией; фоновый процесс публикует его в шину, избегая рассинхронизации.",
      "difficulty": "hard"
    },
    {
      "id": 227,
      "question": "Чем отличается оркестрация от хореографии в saga-паттерне?",
      "options": [
        "Хореография использует централизованный координатор",
        "Оркестрация — централизованный координатор; хореография — взаимодействие через события без центра",
        "Нет отличий",
        "Оркестрация всегда синхронна"
      ],
      "correct": 1,
      "explanation": "Оркестратор управляет последовательностью шагов; при хореографии сервисы реагируют на события друг друга, избегая централизованной логики.",
      "difficulty": "hard"
    },
    {
      "id": 228,
      "question": "Почему 2PC (двухфазная фиксация) обычно не применяется между микросервисами?",
      "options": [
        "Слишком быстро",
        "Сильно повышает связанность и задержки, ухудшает отказоустойчивость",
        "Не поддерживается .NET",
        "Требует gRPC"
      ],
      "correct": 1,
      "explanation": "2PC требует координатора и блокировок, создаёт хрупкость и связанность; вместо этого используют саги/идемпотентность.",
      "difficulty": "hard"
    },
    {
      "id": 229,
      "question": "Из чего состоит JWT-токен?",
      "options": [
        "Заголовок и подпись",
        "Header, Payload, Signature (base64url через точки)",
        "Только полезная нагрузка",
        "XML-документ"
      ],
      "correct": 1,
      "explanation": "JWT — это три части: заголовок, полезная нагрузка (claims) и подпись, разделённые точками в base64url.",
      "difficulty": "easy"
    },
    {
      "id": 230,
      "question": "Чем OpenID Connect отличается от OAuth2?",
      "options": [
        "Это одно и то же",
        "OIDC добавляет слой идентификации поверх OAuth2 (ID-токены и профили)",
        "OAuth2 — для БД",
        "OIDC — только про авторизацию доступа к ресурсам"
      ],
      "correct": 1,
      "explanation": "OAuth2 решает делегирование доступа; OIDC расширяет его профилем идентификации пользователя через ID-токены.",
      "difficulty": "medium"
    },
    {
      "id": 231,
      "question": "Что такое scope в OAuth2/OIDC?",
      "options": [
        "Роль в приложении",
        "Область разрешений, определяющая, к чему клиент запрашивает доступ",
        "Пароль пользователя",
        "Секрет клиента"
      ],
      "correct": 1,
      "explanation": "Scopes описывают разрешения (например, api.read); сервер авторизации выдаёт токены, включающие согласованные области.",
      "difficulty": "easy"
    },
    {
      "id": 232,
      "question": "Какой тип в .NET представляет аутентифицированного пользователя и его claims?",
      "options": [
        "ClaimsIdentity",
        "ClaimsPrincipal",
        "IUser",
        "IIdentityUser"
      ],
      "correct": 1,
      "explanation": "ClaimsPrincipal содержит набор ClaimsIdentity и используется фреймворком для представления текущего пользователя.",
      "difficulty": "easy"
    },
    {
      "id": 233,
      "question": "Для чего используется ASP.NET Core Data Protection в микросервисах?",
      "options": [
        "Для кеширования",
        "Для защищённого шифрования/подписи cookies, токенов, антифрод-данных с общим ключевым хранилищем",
        "Для маршрутизации",
        "Для балансировки нагрузки"
      ],
      "correct": 1,
      "explanation": "Data Protection управляет ротацией ключей и обеспечивает согласованное шифрование/подпись между инстансами (с общим хранилищем).",
      "difficulty": "medium"
    },
    {
      "id": 234,
      "question": "Где хранить ключи ASP.NET Core Data Protection при нескольких инстансах?",
      "options": [
        "В памяти каждого инстанса",
        "В общем внешнем хранилище (например, файловая шина/Redis/Azure Blob)",
        "В cookies",
        "В query string"
      ],
      "correct": 1,
      "explanation": "Чтобы валидировать cookies на разных инстансах, ключи должны быть общими — через внешний ключевой стор.",
      "difficulty": "medium"
    },
    {
      "id": 235,
      "question": "Как защититься от CSRF в MVC/Web API, если используются cookies?",
      "options": [
        "Отключить HTTPS",
        "Антифорджери-токены и правильная политика SameSite/Origin проверки",
        "Хранить токен в localStorage",
        "Добавить заголовок Server"
      ],
      "correct": 1,
      "explanation": "CSRF-защита достигается антифорджери-токенами и проверками источника запроса; важно корректно настроить SameSite для cookies.",
      "difficulty": "hard"
    },
    {
      "id": 236,
      "question": "Какие режимы стриминга поддерживает gRPC?",
      "options": [
        "Только запрос-ответ",
        "Unary, server streaming, client streaming, bidirectional streaming",
        "Только WebSocket",
        "Только long polling"
      ],
      "correct": 1,
      "explanation": "gRPC поддерживает четыре базовых режима, включая двунаправленный поток для интерактивных сценариев.",
      "difficulty": "medium"
    },
    {
      "id": 237,
      "question": "Почему gRPC требует HTTP/2?",
      "options": [
        "Для поддержки SOAP",
        "Для мультиплексирования потоков, бинарных фреймов и эффективности",
        "Для кэширования браузером",
        "Для CORS"
      ],
      "correct": 1,
      "explanation": "HTTP/2 предоставляет мультиплексирование и эффективную бинарную фрейминг-модель, на которой базируется gRPC-протокол.",
      "difficulty": "easy"
    },
    {
      "id": 238,
      "question": "Как изменить схему Protobuf без поломки назад совместимых клиентов?",
      "options": [
        "Переиспользовать поля с теми же номерами",
        "Добавлять новые поля с новыми номерами, старые помечать reserved/не удалять номера",
        "Менять тип поля на несовместимый",
        "Сортировать поля по алфавиту"
      ],
      "correct": 1,
      "explanation": "Номера полей — контракт; нельзя менять их семантику. Новые поля добавляют с новыми номерами; удалённые объявляют reserved.",
      "difficulty": "hard"
    },
    {
      "id": 239,
      "question": "Какой подход к версионированию REST наиболее распространён?",
      "options": [
        "Параметр ?version=",
        "Версия в URL (например, /api/v1) или заголовках с контрактной поддержкой",
        "Только через куки",
        "Всегда один эндпоинт без версий"
      ],
      "correct": 1,
      "explanation": "Часто используют версию в пути (v1/v2) или заголовочные стратегии вместе с библиотеками ApiVersioning.",
      "difficulty": "medium"
    },
    {
      "id": 240,
      "question": "Какой инструмент часто применяют как API Gateway в .NET?",
      "options": [
        "Entity Framework Core",
        "YARP или Ocelot",
        "Dapper",
        "Serilog"
      ],
      "correct": 1,
      "explanation": "YARP (Reverse Proxy) и Ocelot — популярные решения в .NET для маршрутизации и кросс-срезочных задач API Gateway.",
      "difficulty": "easy"
    },
    {
      "id": 241,
      "question": "Как обычно реализуется Service Discovery в Kubernetes?",
      "options": [
        "Через реестр Windows",
        "Через ClusterIP/Headless Services и DNS Kubernetes",
        "Через локальные hosts-файлы",
        "Через WCF"
      ],
      "correct": 1,
      "explanation": "Kubernetes предоставляет DNS и сервисы (ClusterIP/Headless) для обнаружения подов/эндоинтов без внешних реестров.",
      "difficulty": "easy"
    },
    {
      "id": 242,
      "question": "В чём отличие readiness и liveness probe?",
      "options": [
        "Нет отличий",
        "Readiness сигнализирует готовность принимать трафик; liveness — жив ли процесс (иначе рестарт)",
        "Readiness перезапускает контейнер",
        "Liveness управляет балансировщиком"
      ],
      "correct": 1,
      "explanation": "Readiness исключает pod из баланса до готовности; liveness позволяет Kubernetes перезапускать зависшие/сломанные контейнеры.",
      "difficulty": "easy"
    },
    {
      "id": 243,
      "question": "Для чего нужен startupProbe в Kubernetes?",
      "options": [
        "Для логирования",
        "Для длительного старта: пока он не пройдёт, liveness/readiness не активны",
        "Для автоскейлинга",
        "Для кэширования"
      ],
      "correct": 1,
      "explanation": "startupProbe подходит для долгого холодного старта, предотвращая преждевременные рестарты по liveness.",
      "difficulty": "medium"
    },
    {
      "id": 244,
      "question": "Зачем задавать requests/limits ресурсов в Pod?",
      "options": [
        "Чтобы ускорить GC",
        "Для планирования и предотвращения конкуренции/троттлинга по CPU/памяти",
        "Для логирования",
        "Для шифрования"
      ],
      "correct": 1,
      "explanation": "Requests помогают планировщику размещать поды, limits предотвращают чрезмерное потребление и троттлят CPU при перегрузе.",
      "difficulty": "medium"
    },
    {
      "id": 245,
      "question": "Какой механизм масштабирует поды на основе метрик в Kubernetes?",
      "options": [
        "StatefulSet",
        "HorizontalPodAutoscaler",
        "DaemonSet",
        "Ingress"
      ],
      "correct": 1,
      "explanation": "HPA масштабирует количество подов по метрикам (CPU/память/кастомные), удерживая целевые значения нагрузки.",
      "difficulty": "easy"
    },
    {
      "id": 246,
      "question": "Как уменьшить размер .NET контейнеров и ускорить старт?",
      "options": [
        "Использовать полные SDK-образы",
        "Trim/AOT/ReadyToRun и базовые distroless/Alpine-образы",
        "Добавить больше логов",
        "Увеличить таймауты"
      ],
      "correct": 1,
      "explanation": "Публикация с trimming/AOT/ReadyToRun и лёгкие образы (distroless/Alpine) уменьшают размер и улучшают холодный старт.",
      "difficulty": "hard"
    },
    {
      "id": 247,
      "question": "Что даёт публикация .NET как single-file?",
      "options": [
        "Замедляет запуск",
        "Упаковку приложения в один бинарник для деплоя (с опцией self-contained)",
        "Отключение GC",
        "Всегда статическую линковку"
      ],
      "correct": 1,
      "explanation": "Single-file упрощает доставку артефакта; вместе с self-contained исключает зависимость от установленного рантайма.",
      "difficulty": "medium"
    },
    {
      "id": 248,
      "question": "Какие ключевые метрики полезны для ASP.NET Core сервиса?",
      "options": [
        "Размер логов",
        "Латентность, RPS, коды ответов, ошибки, использование CPU/памяти/GC, пул потоков",
        "Только размер БД",
        "Количество файлов"
      ],
      "correct": 1,
      "explanation": "Наблюдаемость API строят на метриках производительности и ошибок, включая системные показатели и пул потоков/GC.",
      "difficulty": "medium"
    },
    {
      "id": 249,
      "question": "Как диагностировать starvation пула потоков в .NET?",
      "options": [
        "По размеру логов",
        "По метрикам очереди задач, длительной задержке обработки, EventCounters, dotnet-counters/trace",
        "По объёму диска",
        "По размеру контейнера"
      ],
      "correct": 1,
      "explanation": "Сигналы — рост очереди пула, задержки обработок, события EventSource; инструменты: dotnet-counters, dotnet-trace, PerfView.",
      "difficulty": "hard"
    },
    {
      "id": 250,
      "question": "Как избежать lock contention в ASP.NET Core обработчиках?",
      "options": [
        "Оборачивать всё в lock",
        "Минимизировать критические секции, использовать неблокирующие структуры/алгоритмы, разделять contention (sharding)",
        "Увеличить Thread.Sleep",
        "Вызывать GC.Collect"
      ],
      "correct": 1,
      "explanation": "Следует сокращать общие блокировки, применять Concurrent*-коллекции, Interlocked, разделение по ключам и асинхронные примитивы.",
      "difficulty": "hard"
    },
    {
      "id": 251,
      "question": "Как влияет время жизни HttpMessageHandler при IHttpClientFactory?",
      "options": [
        "Никак",
        "Определяет переиспользование соединений/DNS; слишком долгий — застой DNS, слишком короткий — исчерпание сокетов",
        "Только на сериализацию",
        "Только на TLS"
      ],
      "correct": 1,
      "explanation": "HandlerLifetime влияет на кэш соединений и обновление DNS. Баланс важен для стабильности и производительности.",
      "difficulty": "hard"
    },
    {
      "id": 252,
      "question": "Как обеспечить балансировку gRPC-запросов между репликами?",
      "options": [
        "Через cookies",
        "Через балансировщик уровня 4/7 с поддержкой HTTP/2 и/или клиентскую балансировку",
        "Только вручную",
        "Через ETag"
      ],
      "correct": 1,
      "explanation": "Нужна поддержка HTTP/2 без даунгрейда и подходящая стратегия L4/L7 или клиентский LB/сервис-дискавери.",
      "difficulty": "hard"
    },
    {
      "id": 253,
      "question": "Как включить устойчивость EF Core к временным ошибкам SQL?",
      "options": [
        "Отключить транзакции",
        "UseSqlServer(...).EnableRetryOnFailure() или стратегии ExecutionStrategy",
        "Использовать Thread.Sleep",
        "Повторять вручную без ограничений"
      ],
      "correct": 1,
      "explanation": "ExecutionStrategy в провайдерах (SQL Server) добавляет ретраи транзиентных ошибок, учитывая idempotency операций.",
      "difficulty": "medium"
    },
    {
      "id": 254,
      "question": "Как снизить накладные расходы EF Core при частых одинаковых запросах?",
      "options": [
        "Включить lazy loading",
        "Использовать предскомпилированные запросы (CompileQuery) или кэширование выражений",
        "Увеличить буфер логов",
        "Отключить AsNoTracking"
      ],
      "correct": 1,
      "explanation": "Предскомпиляция LINQ-запросов уменьшает накладные расходы на построение/перевод выражений.",
      "difficulty": "hard"
    },
    {
      "id": 255,
      "question": "Как корректно обрабатывать конкуренцию в EF Core?",
      "options": [
        "Игнорировать исключения",
        "Использовать concurrency token (rowversion/штамп) и перехватывать DbUpdateConcurrencyException",
        "Всегда перезаписывать данные",
        "Отключить транзакции"
      ],
      "correct": 1,
      "explanation": "Concurrency токены и отлов DbUpdateConcurrencyException позволяют реализовать оптимистичный контроль и стратегию разрешения конфликтов.",
      "difficulty": "hard"
    },
    {
      "id": 256,
      "question": "Чем отличается AsNoTracking от AsNoTrackingWithIdentityResolution?",
      "options": [
        "Ничем",
        "Второй режим не отслеживает, но разрешает одинаковые сущности в один объект на граф для навигаций",
        "Первый быстрее",
        "Второй включает lazy loading"
      ],
      "correct": 1,
      "explanation": "AsNoTrackingWithIdentityResolution полезен для чтения графов без трекинга, но без дублирования одинаковых сущностей.",
      "difficulty": "medium"
    },
    {
      "id": 257,
      "question": "Как избегать N+1 в EF Core?",
      "options": [
        "Использовать lazy loading",
        "Использовать Include/ThenInclude или явные проекции Select, загрузку пакетами",
        "Увеличить таймаут",
        "Отключить кеш"
      ],
      "correct": 1,
      "explanation": "N+1 устраняется за счёт явной загрузки навигаций (Include) или проекций, сокращающих число SQL-запросов.",
      "difficulty": "medium"
    },
    {
      "id": 258,
      "question": "Подходит ли TransactionScope для распределённых транзакций между сервисами?",
      "options": [
        "Да, всегда",
        "Нет, он ориентирован на локальные/промежуточные источники; в микросервисах — саги/идемпотентность",
        "Только с Redis",
        "Только с Kafka"
      ],
      "correct": 1,
      "explanation": "TransactionScope не решает распределённые транзакции между сервисами; предпочтительны саги и outbox для согласованности.",
      "difficulty": "hard"
    },
    {
      "id": 259,
      "question": "Какой уровень изоляции транзакций минимизирует фантомы, но может снижать конкуренцию?",
      "options": [
        "Read Uncommitted",
        "Serializable",
        "Read Committed",
        "Repeatable Read"
      ],
      "correct": 1,
      "explanation": "Serializable наиболее строгий, предотвращает фантомы, но снижает конкурентность из-за блокировок/версий.",
      "difficulty": "hard"
    },
    {
      "id": 260,
      "question": "Как спроектировать пагинацию для больших наборов данных?",
      "options": [
        "Только offset/limit",
        "Использовать keyset/continuation tokens для стабильной и быстрой навигации",
        "Считать все записи",
        "Хранить страницу в сессии"
      ],
      "correct": 1,
      "explanation": "Keyset/continuation pagination лучше масштабируется, избегает дорогих OFFSET при больших объёмах.",
      "difficulty": "hard"
    },
    {
      "id": 261,
      "question": "Какой шаблон кеширования чаще всего используют в сервисах?",
      "options": [
        "Write-behind",
        "Cache-aside (запрос → кеш → источник; инвалидация/TTL)",
        "Write-through",
        "Только ручной кеш"
      ],
      "correct": 1,
      "explanation": "Cache-aside прост и популярен: приложение читает из кеша, при промахе — из источника, затем пополняет кеш.",
      "difficulty": "medium"
    },
    {
      "id": 262,
      "question": "Как предотвратить cache stampede (дудос по кешу) при истечении ключа?",
      "options": [
        "Удалить ключ",
        "Использовать распределённые блокировки/лейзи инициализацию/джиттер TTL",
        "Увеличить TTL до вечности",
        "Отключить кеш"
      ],
      "correct": 1,
      "explanation": "Комбинируют mutex/locking, single-flight, холодное обновление и рандомизацию TTL, чтобы избежать шторма запросов к источнику.",
      "difficulty": "hard"
    },
    {
      "id": 263,
      "question": "Что такое write-through и write-behind стратегии кеша?",
      "options": [
        "Оба читают только из кеша",
        "Write-through пишет синхронно в кеш и источник; write-behind — сначала в кеш, асинхронно в источник",
        "Оба всегда асинхронные",
        "Оба всегда синхронные"
      ],
      "correct": 1,
      "explanation": "Write-through снижает рассинхрон ценой задержки; write-behind даёт скорость, но требует надёжной очереди/идемпотентности.",
      "difficulty": "hard"
    },
    {
      "id": 264,
      "question": "Какой паттерн БД подходит для независимых микросервисов?",
      "options": [
        "Общая монолитная БД",
        "База данных на сервис (database-per-service)",
        "Одна таблица на сервис",
        "Только кэш без БД"
      ],
      "correct": 1,
      "explanation": "Database-per-service снижает связанность; обмен данными между сервисами через события/контракты, а не через общую схему.",
      "difficulty": "medium"
    },
    {
      "id": 265,
      "question": "Как реализовать распределённую блокировку в Redis?",
      "options": [
        "Через cookies",
        "Через ключи с TTL/SET NX (Redlock — с осторожностью)",
        "Через ETag",
        "Через HTTP заголовки"
      ],
      "correct": 1,
      "explanation": "SET NX PX и корректная продление/освобождение позволяют реализовать простую блокировку; Redlock — дискуссионен, применять осознанно.",
      "difficulty": "hard"
    },
    {
      "id": 266,
      "question": "Как сериализовать enum в JSON читабельно в System.Text.Json?",
      "options": [
        "По умолчанию числа",
        "Добавить JsonStringEnumConverter",
        "Использовать BinaryFormatter",
        "Конвертировать вручную через int"
      ],
      "correct": 1,
      "explanation": "JsonStringEnumConverter сериализует перечисления строками, улучшая читаемость контрактов и снижаю риск несовместимостей.",
      "difficulty": "easy"
    },
    {
      "id": 267,
      "question": "Как безопасно сериализовать граф с циклами в System.Text.Json?",
      "options": [
        "Невозможно",
        "Включить ReferenceHandler.Preserve или разорвать циклы проекцией DTO",
        "Использовать XmlSerializer",
        "Отключить исключения"
      ],
      "correct": 1,
      "explanation": "ReferenceHandler.Preserve добавляет $id/$ref; в публичных API чаще формируют ацикличные DTO-проекции.",
      "difficulty": "medium"
    },
    {
      "id": 268,
      "question": "Как избежать проблем с полиморфной сериализацией в System.Text.Json?",
      "options": [
        "Игнорировать типы",
        "Явно регистрировать известные подтипы/конвертеры или использовать type-discriminator",
        "Всегда использовать dynamic",
        "Отключить сериализацию"
      ],
      "correct": 1,
      "explanation": "System.Text.Json ограниченно поддерживает полиморфизм; требуется конфигурация конвертеров или дискриминатор поля для безопасной десериализации.",
      "difficulty": "hard"
    },
    {
      "id": 269,
      "question": "Как корректно работать с временем в распределённых системах?",
      "options": [
        "Использовать локальное время",
        "Использовать UTC в хранилищах/контрактах и конвертировать в локальное на краю",
        "Хранить только строки времени",
        "Полагаться на системные часы без синхронизации"
      ],
      "correct": 1,
      "explanation": "UTC минимизирует проблемы со сменой часовых поясов/летним временем; конвертации выполняются ближе к пользователю.",
      "difficulty": "easy"
    },
    {
      "id": 270,
      "question": "Какую стратегию генерации идентификаторов лучше использовать для распределённых систем?",
      "options": [
        "Инкрементальные int",
        "UUID (например, v4/v7) или распределённые генераторы (Snowflake)",
        "Автоинкремент в одной БД",
        "Случайные строки разной длины"
      ],
      "correct": 1,
      "explanation": "Глобально уникальные, хорошо распределённые идентификаторы (UUID/Snowflake) упрощают масштабирование и избегают конфликтов.",
      "difficulty": "medium"
    },
    {
      "id": 271,
      "question": "Зачем нужен OpenAPI/Swagger для микросервисов?",
      "options": [
        "Для логирования",
        "Для спецификации контрактов, генерации клиентов, документации и тестирования",
        "Для кеширования",
        "Для миграций БД"
      ],
      "correct": 1,
      "explanation": "OpenAPI описывает контракт; инструменты генерируют клиенты/валидацию, упрощают коммуникацию между командами.",
      "difficulty": "easy"
    },
    {
      "id": 272,
      "question": "Где лучше реализовать валидацию DTO в .NET микросервисе?",
      "options": [
        "Только в БД",
        "На границе (модели запроса) + бизнес-валидация в домене",
        "Только в UI",
        "Только в репозитории"
      ],
      "correct": 1,
      "explanation": "Схемная валидация входа — на уровне API/моделей; бизнес-инварианты — в домене, чтобы гарантировать корректность сценариев.",
      "difficulty": "medium"
    },
    {
      "id": 273,
      "question": "Как стандартизировать ответы об ошибках в Web API?",
      "options": [
        "Бросать строки",
        "Использовать RFC 7807 (ProblemDetails) и единый middleware обработки ошибок",
        "Всегда возвращать 200",
        "Логировать без ответа"
      ],
      "correct": 1,
      "explanation": "ProblemDetails обеспечивает согласованный формат ошибок; middleware централизует перевод исключений в HTTP-ответы.",
      "difficulty": "easy"
    },
    {
      "id": 274,
      "question": "Как добавить валидацию FluentValidation в ASP.NET Core?",
      "options": [
        "Она встроена по умолчанию",
        "Добавить пакет и зарегистрировать валидаторы; интегрировать с MVC/Minimal API",
        "Использовать BinaryFormatter",
        "Заменить DI контейнер"
      ],
      "correct": 1,
      "explanation": "FluentValidation подключается через пакет и сервисы; атрибуты/фильтры интегрируют его с пайплайном запросов.",
      "difficulty": "medium"
    },
    {
      "id": 275,
      "question": "Для чего полезны pipeline behaviors в MediatR?",
      "options": [
        "Для рендера HTML",
        "Для кросс-срезочных аспектов (валидация, логирование, ретраи, транзакции) вокруг хэндлеров",
        "Для DAL",
        "Для миграций"
      ],
      "correct": 1,
      "explanation": "Pipeline behaviors позволяют оборачивать команды/запросы единым конвейером, не дублируя код в хэндлерах.",
      "difficulty": "medium"
    },
    {
      "id": 276,
      "question": "Где в конвейере ASP.NET Core должен находиться обработчик исключений?",
      "options": [
        "В конце",
        "Как можно раньше (вверху), чтобы перехватывать исключения последующих middleware",
        "Перед статикой",
        "После маршрутизации"
      ],
      "correct": 1,
      "explanation": "UseExceptionHandler/UseDeveloperExceptionPage размещают в начале пайплайна, чтобы ловить ошибки следующих компонентов.",
      "difficulty": "easy"
    },
    {
      "id": 277,
      "question": "Какой порядок middleware критичен для корректной работы?",
      "options": [
        "Произвольный",
        "Аутентификация до авторизации; CORS до endpoints; маршрутизация до endpoints; исключения — вверху",
        "Авторизация до аутентификации",
        "StaticFiles после MVC"
      ],
      "correct": 1,
      "explanation": "Порядок middleware влияет на поведение: Auth → AuthZ, CORS до обработки, Map/UseEndpoints в конце ветки маршрутов и т.д.",
      "difficulty": "medium"
    },
    {
      "id": 278,
      "question": "Как обеспечить корректное завершение (graceful shutdown) .NET сервиса в контейнере?",
      "options": [
        "Игнорировать SIGTERM",
        "Обрабатывать остановку через IHostApplicationLifetime/BackgroundService.StopAsync, закрывать входящие, завершать активные операции",
        "Вызывать Environment.Exit(0) сразу",
        "Удалить логи"
      ],
      "correct": 1,
      "explanation": "Хост посылает уведомления о завершении; сервис должен перестать принимать трафик и корректно завершить текущие работы за отведённое время.",
      "difficulty": "medium"
    },
    {
      "id": 279,
      "question": "Как обработать сигналы завершения в Linux-контейнере для .NET?",
      "options": [
        "Это невозможно",
        "Полагаться на Generic Host, который ловит SIGTERM и инициирует StopAsync",
        "Использовать Thread.Abort",
        "Только через cron"
      ],
      "correct": 1,
      "explanation": "Generic Host перехватывает SIGTERM/SIGINT и инициирует graceful shutdown через DI-жизненный цикл.",
      "difficulty": "easy"
    },
    {
      "id": 280,
      "question": "Как включить HTTP/2 в Kestrel для gRPC?",
      "options": [
        "Никак",
        "Настроить Kestrel (Protocols = Http2) и TLS при необходимости",
        "Только через IIS",
        "Только в Docker"
      ],
      "correct": 1,
      "explanation": "Kestrel поддерживает HTTP/2; требуется настройка протокола и зачастую TLS для клиентов (особенно браузеров).",
      "difficulty": "medium"
    },
    {
      "id": 281,
      "question": "Поддерживает ли ASP.NET Core HTTP/3 и зачем он может быть полезен?",
      "options": [
        "Нет",
        "Да, поверх QUIC; уменьшает латентность и улучшает поведение при потере пакетов",
        "Только в .NET Framework",
        "Только для gRPC"
      ],
      "correct": 1,
      "explanation": "Современные версии ASP.NET Core поддерживают HTTP/3 (QUIC), что улучшает производительность в сетях с потерями/мобильных.",
      "difficulty": "hard"
    },
    {
      "id": 282,
      "question": "Рекомендуется ли хранить серверные сессии в памяти микросервиса?",
      "options": [
        "Да, всегда",
        "Нет, сервисы должны быть статлесс; для состояния использовать распределённые сторы/клиентское хранение",
        "Только в Kubernetes",
        "Только в монолите"
      ],
      "correct": 1,
      "explanation": "Статлесс-сервисы упрощают масштабирование; состояние — в Redis/БД/клиенте, а не в памяти инстанса.",
      "difficulty": "easy"
    },
    {
      "id": 283,
      "question": "Как масштабировать SignalR при нескольких инстансах?",
      "options": [
        "Никак",
        "Использовать backplane (Redis/Azure SignalR) для обмена сообщениями между инстансами",
        "Кэшировать в памяти",
        "Через cookies"
      ],
      "correct": 1,
      "explanation": "Backplane позволяет всем инстансам рассылать сообщения подписчикам независимо от того, к какому инстансу они подключены.",
      "difficulty": "medium"
    },
    {
      "id": 284,
      "question": "Что такое sticky sessions и когда они нужны?",
      "options": [
        "Балансировка по кругу",
        "Закрепление клиента за инстансом; иногда нужно для WebSocket/сеансов, но лучше избегать за счёт разделённого состояния",
        "Сжатие ответов",
        "Кэширование в браузере"
      ],
      "correct": 1,
      "explanation": "Sticky sessions привязывают клиента к инстансу; это ухудшает балансировку, поэтому предпочтительны статлесс-подходы.",
      "difficulty": "hard"
    },
    {
      "id": 285,
      "question": "Как обеспечить порядок событий при публикации в брокер из .NET?",
      "options": [
        "Игнорировать порядок",
        "Ключом партиционирования (partition key) и отправкой в одну партицию",
        "Сортировать в потребителе",
        "Отключить ретраи"
      ],
      "correct": 1,
      "explanation": "Порядок гарантируется в пределах партиции; выбор стабильного ключа (например, агрегата) сохраняет порядок событий по объекту.",
      "difficulty": "hard"
    },
    {
      "id": 286,
      "question": "Как бороться с рассинхроном времени между сервисами?",
      "options": [
        "Не нужно",
        "Синхронизировать через NTP; избегать зависимостей от локального времени в логике",
        "Использовать локальное время",
        "Хранить в cookies"
      ],
      "correct": 1,
      "explanation": "Синхронизация часов (NTP) и использование UTC/идемпотентных алгоритмов снижают влияние дрейфа времени.",
      "difficulty": "medium"
    },
    {
      "id": 287,
      "question": "Как использовать новый TimeProvider (.NET 8) в коде?",
      "options": [
        "Через DateTime.Now",
        "Инжектировать TimeProvider в зависимости для тестируемых часов (Now, UtcNow, Delay)",
        "Использовать Thread.Sleep",
        "Только в UI"
      ],
      "correct": 1,
      "explanation": "TimeProvider абстрагирует источники времени/таймеров; облегчает тестирование и управление временем в сценариях.",
      "difficulty": "medium"
    },
    {
      "id": 288,
      "question": "Как добавить версионирование API в ASP.NET Core?",
      "options": [
        "Ручные маршруты без атрибутов",
        "Через библиотеку Microsoft.AspNetCore.Mvc.Versioning и атрибуты/конвенции",
        "Через cookies",
        "Через CORS"
      ],
      "correct": 1,
      "explanation": "Пакет ApiVersioning предоставляет инфраструктуру версий через атрибуты, конвенции и маршрутизацию.",
      "difficulty": "easy"
    },
    {
      "id": 289,
      "question": "Как добавить фильтрацию/валидацию в Minimal APIs?",
      "options": [
        "Никак",
        "Через фильтры (endpoint filters), привязку параметров и явные вызовы валидаторов",
        "Только через MVC",
        "Через WebForms"
      ],
      "correct": 1,
      "explanation": "Minimal APIs поддерживают endpoint filters и интеграцию с валидацией/DI для кросс-срезочных задач.",
      "difficulty": "medium"
    },
    {
      "id": 290,
      "question": "Как гибко настроить rate limiting по ключу клиента?",
      "options": [
        "Один общий лимит",
        "Использовать PartitionedRateLimiter с ключом (IP, клиент, токен)",
        "Через GC",
        "Только через Nginx"
      ],
      "correct": 1,
      "explanation": "PartitionedRateLimiter позволяет создавать отдельные лимиты по произвольным ключам (идентификатор клиента, маршрут и т.д.).",
      "difficulty": "hard"
    },
    {
      "id": 291,
      "question": "Как добавить метаданные к endpoint в Minimal APIs?",
      "options": [
        "Никак",
        "Через WithMetadata/атрибуты и конвенции",
        "Только через XML",
        "Через web.config"
      ],
      "correct": 1,
      "explanation": "Метаданные добавляются к endpoint builder через WithMetadata, а также через атрибуты на делегатах/типах.",
      "difficulty": "easy"
    },
    {
      "id": 292,
      "question": "Как стандартизировать формат логов в микросервисах .NET?",
      "options": [
        "Писать произвольные строки",
        "Структурированные логи (Serilog/MEL) с согласованными свойствами (TraceId, SpanId, CorrelationId)",
        "Только текст без ключей",
        "Только консоль"
      ],
      "correct": 1,
      "explanation": "Структурированные логи упрощают анализ/корреляцию с трассировками и метриками в системах наблюдаемости.",
      "difficulty": "medium"
    },
    {
      "id": 293,
      "question": "Что такое CAP-теорема и её значение для микросервисов?",
      "options": [
        "Про GC",
        "Нельзя одновременно обеспечить консистентность, доступность и устойчивость к разделению сети (выбирают два из трёх)",
        "Про OAuth",
        "Про UI"
      ],
      "correct": 1,
      "explanation": "CAP помогает выбирать компромиссы (например, AP с eventual consistency) в распределённых системах при сетевых разделениях.",
      "difficulty": "hard"
    },
    {
      "id": 294,
      "question": "Как обеспечить обратную совместимость при изменении контрактов API?",
      "options": [
        "Переименовывать поля без предупреждения",
        "Добавлять новые поля опционально, не удалять/не менять семантику существующих; версионировать-breaking изменения",
        "Всегда возвращать 500",
        "Шифровать JSON"
      ],
      "correct": 1,
      "explanation": "Эволюция контрактов требует non-breaking подходов: добавлять новые опциональные поля, сохранять старые и вводить новые версии при breaking changes.",
      "difficulty": "medium"
    },
    {
      "id": 295,
      "question": "Как стандартизировать ошибки домена/валидации в ответах?",
      "options": [
        "Через строки",
        "Возвращать ProblemDetails/ValidationProblemDetails с кодами и деталями",
        "Через HTML",
        "Только через логи"
      ],
      "correct": 1,
      "explanation": "ProblemDetails (RFC 7807) обеспечивает стандартный формат ошибок; для валидации — ValidationProblemDetails.",
      "difficulty": "easy"
    },
    {
      "id": 296,
      "question": "Как применять Polly с IHttpClientFactory для типизированных клиентов?",
      "options": [
        "Никак",
        "Добавлять политики через AddPolicyHandler при регистрации Typed Client",
        "Через глобальную переменную",
        "Через web.config"
      ],
      "correct": 1,
      "explanation": "PolicyHandler позволяет навешивать политики (retry, timeout, circuit breaker) на именованные/типизированные HttpClient.",
      "difficulty": "medium"
    },
    {
      "id": 297,
      "question": "Какие преимущества даёт канальный API (System.Threading.Channels) для продюсер/консюмер?",
      "options": [
        "Блокирует потоки",
        "Высокая производительность, контроль backpressure, асинхронные читатели/писатели",
        "Только синхронность",
        "Только для UI"
      ],
      "correct": 1,
      "explanation": "Channels предоставляют безопасные очереди с асинхронными API и встроенным ограничением пропускной способности.",
      "difficulty": "hard"
    },
    {
      "id": 298,
      "question": "Где лучше размещать UseResponseCompression в пайплайне?",
      "options": [
        "В самом конце",
        "До middleware, формирующих ответ (до Map/Endpoints), чтобы успеть сжать выдачу",
        "Перед UseExceptionHandler",
        "После статических файлов"
      ],
      "correct": 1,
      "explanation": "Сжатие должно оборачивать генерацию ответа, чтобы перехватывать и компрессировать контент большинства эндпоинтов.",
      "difficulty": "medium"
    },
    {
      "id": 299,
      "question": "Какие заголовки безопасности стоит добавлять в ответы API?",
      "options": [
        "Server: Kestrel",
        "Content-Security-Policy (для фронта), X-Content-Type-Options, X-Frame-Options/Frame-Options, Referrer-Policy и др.",
        "Only-For-Debug",
        "X-Debug-Trace"
      ],
      "correct": 1,
      "explanation": "Набор заголовков снижает риски XSS/MIME-sniffing/Clickjacking; для API важнее корректные CORS и запрет лишней информации.",
      "difficulty": "hard"
    },
    {
      "id": 300,
      "question": "Как обеспечить стабильность клиентских контрактов при эволюции DTO?",
      "options": [
        "Переименовывать поля без версий",
        "Версионировать DTO/эндпоинты, использовать совместимость по добавлению полей и контракты через OpenAPI/тесты",
        "Отключить кеш",
        "Использовать BinaryFormatter"
      ],
      "correct": 1,
      "explanation": "Контракты следует тестировать (consumer-driven tests), эволюционировать без breaking, а breaking изменения вводить через новые версии.",
      "difficulty": "hard"
    }
  ]
}