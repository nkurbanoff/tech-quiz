{
  "version": "1.0.0",
  "lastUpdated": "2025-11-18",
  "category": "angular",
  "questions": [
    {
      "id": 1,
      "question": "Что такое директива в Angular?",
      "options": [
        "Компонент без шаблона",
        "Класс, который изменяет поведение элементов DOM",
        "Сервис для работы с HTTP",
        "Модуль для роутинга"
      ],
      "correct": 1,
      "explanation": "Директива — класс с декоратором @Directive, добавляющий поведение к элементам DOM. Бывают структурные (*ngIf, *ngFor) и атрибутные (ngClass, ngStyle).",
      "difficulty": "easy"
    },
    {
      "id": 2,
      "question": "Для чего используется RxJS в Angular?",
      "options": [
        "Для стилизации компонентов",
        "Для работы с асинхронными потоками данных",
        "Для тестирования приложения",
        "Для компиляции TypeScript"
      ],
      "correct": 1,
      "explanation": "RxJS обеспечивает декларативную работу с асинхронными потоками через Observables (HTTP, события, формы, роутинг).",
      "difficulty": "easy"
    },
    {
      "id": 3,
      "question": "Что такое Angular CLI?",
      "options": [
        "Средство для тестирования без сборки",
        "Инструмент командной строки для создания и управления проектами",
        "Runtime оптимизатор JavaScript",
        "Расширение для VS Code"
      ],
      "correct": 1,
      "explanation": "Angular CLI помогает генерировать код (components, services), выполнять сборку, тесты, линтинг и оптимизации (ng new, ng serve, ng build).",
      "difficulty": "easy"
    },
    {
      "id": 4,
      "question": "Что делает декоратор @Component?",
      "options": [
        "Определяет сервис и его область",
        "Связывает класс с метаданными шаблона, стилей и селектора",
        "Оптимизирует бандл при сборке",
        "Запускает тестовый раннер"
      ],
      "correct": 1,
      "explanation": "@Component связывает класс с селектором, шаблоном (template/templateUrl), стилями (styles/styleUrls) и изменяет его роль на компонент.",
      "difficulty": "easy"
    },
    {
      "id": 5,
      "question": "Что делает директива *ngFor?",
      "options": [
        "Повторяет HTTP-запрос",
        "Итерирует коллекцию и создает элементы по шаблону",
        "Оптимизирует Change Detection",
        "Выполняет парсинг JSON"
      ],
      "correct": 1,
      "explanation": "*ngFor — структурная директива, размножающая шаблон для каждой записи коллекции (let item of items).",
      "difficulty": "easy"
    },
    {
      "id": 6,
      "question": "Какой пакет отвечает за HTTP-клиент?",
      "options": [
        "@angular/common/http",
        "@angular/router",
        "@angular/platform-browser",
        "@angular/forms"
      ],
      "correct": 0,
      "explanation": "Модуль HttpClientModule из @angular/common/http предоставляет HttpClient для работы с HTTP-запросами.",
      "difficulty": "easy"
    },
    {
      "id": 7,
      "question": "Для чего используется ngOnInit?",
      "options": [
        "Для подписки на Observable до конструктора",
        "Хук жизненного цикла для инициализации после создания input-связей",
        "Для уничтожения компонента",
        "Для запуска сборки"
      ],
      "correct": 1,
      "explanation": "ngOnInit вызывается один раз после установки входных свойств и подходит для начальной загрузки данных.",
      "difficulty": "easy"
    },
    {
      "id": 8,
      "question": "Что такое сервис (service) в Angular?",
      "options": [
        "Класс для изменения DOM напрямую",
        "Переиспользуемый класс бизнес-логики или доступа к данным",
        "Только объект конфигурации роутера",
        "Специфичная сущность для шаблонов"
      ],
      "correct": 1,
      "explanation": "Сервис — класс без UI, инжектируемый через DI для бизнес-логики, API-вызовов, кэша и т.п.",
      "difficulty": "easy"
    },
    {
      "id": 9,
      "question": "Что делает pipe в Angular?",
      "options": [
        "Собирает бандл",
        "Трансформирует значение в шаблоне (| date, | async)",
        "Меняет стратегию Change Detection",
        "Отправляет HTTP-запрос"
      ],
      "correct": 1,
      "explanation": "Pipe — класс с декоратором @Pipe, реализует метод transform для преобразования значений в шаблоне.",
      "difficulty": "easy"
    },
    {
      "id": 10,
      "question": "Какой оператор RxJS используется для подписки?",
      "options": [
        "subscribe()",
        "map()",
        "pipe()",
        "switchMap()"
      ],
      "correct": 0,
      "explanation": "Подписка на Observable инициируется методом subscribe(), принимающим next/error/complete callbacks.",
      "difficulty": "easy"
    },
    {
      "id": 11,
      "question": "Что такое Zone.js в контексте Angular?",
      "options": [
        "Библиотека для типизации",
        "Механизм перехвата асинхронных операций для автоматического Change Detection",
        "Генератор компонентов",
        "Тулкит тестирования"
      ],
      "correct": 1,
      "explanation": "Zone.js патчит асинхронные API (setTimeout, Promises) и уведомляет Angular о завершении, инициируя проверку изменений.",
      "difficulty": "medium"
    },
    {
      "id": 12,
      "question": "Назначение ChangeDetectionStrategy.OnPush?",
      "options": [
        "Полностью отключает проверку",
        "Ограничивает проверку до изменений входных свойств/Observable emissions",
        "Запускает проверку в отдельном потоке",
        "Снижает размер бандла"
      ],
      "correct": 1,
      "explanation": "OnPush заставляет Angular проверять компонент при изменении Input ссылок, событиях внутри и async pipe emissions, уменьшая нагрузку.",
      "difficulty": "medium"
    },
    {
      "id": 13,
      "question": "Разница между Template-driven и Reactive Forms?",
      "options": [
        "Reactive всегда без валидации",
        "Template-driven управляются декларативно в шаблоне, Reactive — императивно через FormControl API",
        "Template-driven быстрее в runtime",
        "Reactive нельзя тестировать"
      ],
      "correct": 1,
      "explanation": "Template-driven: директивы ngModel. Reactive: объектная модель FormGroup/FormControl с явным управлением и удобным тестированием.",
      "difficulty": "medium"
    },
    {
      "id": 14,
      "question": "Для чего нужен оператор switchMap в RxJS?",
      "options": [
        "Параллельный merge всех потоков",
        "Отмена предыдущего потока при новом значении и переключение на новый Observable",
        "Блокировка ошибок",
        "Повторение значения n раз"
      ],
      "correct": 1,
      "explanation": "switchMap отменяет предыдущую внутреннюю подписку при приходе нового значения и подписывается на новый Observable.",
      "difficulty": "medium"
    },
    {
      "id": 15,
      "question": "Что такое Dependency Injection контейнер в Angular?",
      "options": [
        "Сервис сборки CSS",
        "Иерархическая система поставщиков, создающая экземпляры по токенам",
        "Инструмент логирования",
        "Средство маршрутизации"
      ],
      "correct": 1,
      "explanation": "DI контейнер хранит провайдеры (token -> factory/value) и разрешает зависимости при создании компонентов/сервисов.",
      "difficulty": "medium"
    },
    {
      "id": 16,
      "question": "Что делает оператор takeUntil?",
      "options": [
        "Повторяет поток бесконечно",
        "Завершает Observable при эмиссии управляющего Observable",
        "Буферизует значения",
        "Соединяет два потока в один массив"
      ],
      "correct": 1,
      "explanation": "takeUntil завершает основной поток при первом next управляющего Observable — удобно для отписки в ngOnDestroy.",
      "difficulty": "medium"
    },
    {
      "id": 17,
      "question": "Цель Ahead-of-Time (AoT) компиляции?",
      "options": [
        "Добавить исходники TypeScript в браузер",
        "Предварительно компилировать шаблоны в JS для ускорения и уменьшения размера",
        "Замедлить сборку ради лучшего дебага",
        "Удалить RxJS"
      ],
      "correct": 1,
      "explanation": "AoT компилирует шаблоны на этапе сборки, ускоряя старт приложения и позволяя лучшую оптимизацию tree-shaking.",
      "difficulty": "medium"
    },
    {
      "id": 18,
      "question": "Что такое Ivy?",
      "options": [
        "CSS фреймворк",
        "Angular рендерер и компилятор нового поколения с улучшенным tree-shaking",
        "Тестовый раннер",
        "Система State Management"
      ],
      "correct": 1,
      "explanation": "Ivy — архитектура компиляции/рендеринга (с Angular 9+) дающая меньшие бандлы, более точный tree-shaking и runtime API.",
      "difficulty": "medium"
    },
    {
      "id": 19,
      "question": "Content Projection реализуется через?",
      "options": [
        "@Injectable",
        "<ng-content></ng-content> в шаблоне компонента",
        "@Pipe",
        "@Directive без селектора"
      ],
      "correct": 1,
      "explanation": "Content projection: <ng-content> позволяет вставлять внешний контент в точку шаблона компонента.",
      "difficulty": "medium"
    },
    {
      "id": 20,
      "question": "Назначение ViewChild?",
      "options": [
        "Получить инстанс родительского модуля",
        "Получить ссылку на элемент DOM/директиву/дочерний компонент из шаблона",
        "Создать lazy-loaded модуль",
        "Запланировать change detection вручную"
      ],
      "correct": 1,
      "explanation": "@ViewChild позволяет получить доступ к элементу/директиве/компоненту после инициализации представления.",
      "difficulty": "medium"
    },
    {
      "id": 21,
      "question": "Чем отличается ngOnChanges от ngOnInit?",
      "options": [
        "ngOnInit вызывается чаще",
        "ngOnChanges вызывается при каждом изменении @Input до ngOnInit",
        "ngOnChanges доступен только в сервисах",
        "ngOnInit обрабатывает изменения Input автоматически"
      ],
      "correct": 1,
      "explanation": "ngOnChanges вызывается при каждом изменении входных свойств (до первого ngOnInit). ngOnInit — один раз после первичной установки Input.",
      "difficulty": "medium"
    },
    {
      "id": 22,
      "question": "Для чего нужен RouterModule?",
      "options": [
        "Сборка бандла",
        "Определение маршрутов, навигация, Guards, lazy loading",
        "Оптимизация производительности CSS",
        "Парсинг JSON"
      ],
      "correct": 1,
      "explanation": "RouterModule предоставляет директивы routerLink, роуты, Guards, lazy loading конфигурацию и сервис Router.",
      "difficulty": "medium"
    },
    {
      "id": 23,
      "question": "Назначение Resolve Guard?",
      "options": [
        "Блокирует все переходы",
        "Предзагружает данные до активации маршрута",
        "Обновляет заголовок страницы",
        "Отменяет изменения формы"
      ],
      "correct": 1,
      "explanation": "Resolve Guard возвращает Observable/Promise, данные которого доступны в ActivatedRoute.data после завершения перед навигацией.",
      "difficulty": "medium"
    },
    {
      "id": 24,
      "question": "Lazy loading модулей уменьшает?",
      "options": [
        "Качество кода",
        "Начальный размер бандла и время загрузки",
        "Возможность DI",
        "Скорость сборки AoT"
      ],
      "correct": 1,
      "explanation": "Lazy loading загружает код маршрутов по требованию, снижая initial bundle и ускоряя first paint.",
      "difficulty": "medium"
    },
    {
      "id": 25,
      "question": "Что делает async pipe?",
      "options": [
        "Создает Observable",
        "Подписывается на Observable/Promise и автоматически отписывается при уничтожении",
        "Удаляет зону",
        "Оптимизирует сборку CSS"
      ],
      "correct": 1,
      "explanation": "async pipe подписывается на поток, отображает последнее значение и автоматически отписывается — снижает утечки памяти.",
      "difficulty": "medium"
    },
    {
      "id": 26,
      "question": "Зачем нужен TrackBy в *ngFor?",
      "options": [
        "Отправка события в сервер",
        "Сокращает перерисовку списка, определяя идентификатор элемента",
        "Асинхронная загрузка модуля",
        "Фильтрация дублей"
      ],
      "correct": 1,
      "explanation": "trackBy возвращает уникальный ключ, позволяя Angular переиспользовать DOM и не пересоздавать элементы при обновлении.",
      "difficulty": "medium"
    },
    {
      "id": 27,
      "question": "Pure vs Impure Pipe различие?",
      "options": [
        "Impure вызывается реже",
        "Impure вызывается на каждый цикл, pure только при изменении ссылок/примитивов",
        "Pure видит внутреннее состояние компонентов",
        "Pure запрещен в AoT"
      ],
      "correct": 1,
      "explanation": "Pure pipe триггерится при изменении входных ссылок. Impure — при каждом CD цикле, может быть дорого.",
      "difficulty": "medium"
    },
    {
      "id": 28,
      "question": "Injector hierarchy влияет на?",
      "options": [
        "Стратегию роутинга",
        "Область жизни сервисов (root, компонентный уровень, lazy модуль)",
        "Размер CSS",
        "Работу pipe"
      ],
      "correct": 1,
      "explanation": "Иерархия инжекторов определяет уникальность инстанса: root singleton, компонентный scope, lazy module отдельный экземпляр.",
      "difficulty": "medium"
    },
    {
      "id": 29,
      "question": "Renderer2 используется для?",
      "options": [
        "Сборки TypeScript",
        "Абстракции манипуляций с DOM независимой от платформы",
        "Оптимизации HTTP",
        "Создания модулей"
      ],
      "correct": 1,
      "explanation": "Renderer2 обеспечивает безопасные операции с DOM и возможность работы в разных платформах (Server, NativeScript).",
      "difficulty": "medium"
    },
    {
      "id": 30,
      "question": "Differential Loading решает?",
      "options": [
        "Сжатие изображений",
        "Генерацию разных бандлов для современных и старых браузеров",
        "Оптимизацию CSS-переменных",
        "Тестирование производительности"
      ],
      "correct": 1,
      "explanation": "Differential Loading создает ES2015+ и ES5 бандлы, ускоряя загрузку в современных браузерах и сохраняя совместимость.",
      "difficulty": "medium"
    },
    {
      "id": 31,
      "question": "Когда использовать ngOnDestroy?",
      "options": [
        "Для создания компонента",
        "Для очистки ресурсов: отписки, таймеры, слушатели",
        "Для SSR рендеринга",
        "Для кеширования данных"
      ],
      "correct": 1,
      "explanation": "ngOnDestroy вызывается перед удалением компонента/директивы и позволяет освободить ресурсы и избежать утечек.",
      "difficulty": "medium"
    },
    {
      "id": 32,
      "question": "Как предотвратить XSS в шаблонах?",
      "options": [
        "Отключить sanitizer",
        "Использовать встроенную санитизацию Angular и избегать [innerHTML] без DomSanitizer",
        "Использовать eval",
        "Преобразовать всё в JSON"
      ],
      "correct": 1,
      "explanation": "Angular автоматически санитизирует опасные привязки. Для доверенного контента применяют DomSanitizer.bypassSecurityTrust... осознанно.",
      "difficulty": "medium"
    },
    {
      "id": 33,
      "question": "Router Guard CanActivate отвечает за?",
      "options": [
        "Формирование HTTP заголовков",
        "Разрешение или запрет навигации к маршруту",
        "Сжатие ответа",
        "Кеширование Observable"
      ],
      "correct": 1,
      "explanation": "CanActivate возвращает true/false/Observable/Promise для определения допуска пользователя к маршруту.",
      "difficulty": "medium"
    },
    {
      "id": 34,
      "question": "В чем преимущество Standalone Components?",
      "options": [
        "Удаляют TypeScript",
        "Упрощают архитектуру без обязательных NgModule, повышая tree-shaking",
        "Отключают DI",
        "Заменяют RxJS"
      ],
      "correct": 1,
      "explanation": "Standalone компоненты объявляют imports внутри @Component, сокращая необходимость в декларации NgModule и улучшая оптимизацию.",
      "difficulty": "medium"
    },
    {
      "id": 35,
      "question": "inject() функция в Angular служит для?",
      "options": [
        "Создания компонента",
        "Получения зависимости вне конструктора (напр. в фабриках, функциях)",
        "Генерации шаблона",
        "Компиляции SCSS"
      ],
      "correct": 1,
      "explanation": "inject(Token) доступна в runtime контексте DI (в провайдерах, фабриках), позволяя получить зависимость без конструктора.",
      "difficulty": "medium"
    },
    {
      "id": 36,
      "question": "Что делает HttpInterceptor?",
      "options": [
        "Кэширует компоненты",
        "Перехватывает HTTP запросы/ответы для модификации (auth, логирование)",
        "Отменяет DI",
        "Убирает zone.js"
      ],
      "correct": 1,
      "explanation": "Interceptor реализует метод intercept(req,next), позволяя цепочно модифицировать запросы/ответы.",
      "difficulty": "medium"
    },
    {
      "id": 37,
      "question": "Преимущество Signals (Angular >=16)?",
      "options": [
        "Уменьшают размер HTML",
        "Предоставляют детерминированную модель реактивности без зон и сложных Observable для локального состояния",
        "Заменяют CSS",
        "Удаляют необходимость DI"
      ],
      "correct": 1,
      "explanation": "Signals — pull-based реактивность: компонент знает зависимости, что упрощает оптимизации и работу без zone.",
      "difficulty": "medium"
    },
    {
      "id": 38,
      "question": "Hydration в Angular SSR решает?",
      "options": [
        "Удаление всех серверных данных",
        "Связывание существующего серверного HTML с клиентским приложением без полной перерисовки",
        "Заморозку роутера",
        "Замену RxJS"
      ],
      "correct": 1,
      "explanation": "Hydration позволяет использовать уже отрендеренный сервером HTML и привязывать обработчики событий, снижая работу клиента.",
      "difficulty": "medium"
    },
    {
      "id": 39,
      "question": "NgZone.runOutsideAngular используется для?",
      "options": [
        "Запуска Change Detection чаще",
        "Выполнения кода без триггера CD (например, прослушка scroll, heavy задачи)",
        "Удаления компонента",
        "Компиляции шаблона"
      ],
      "correct": 1,
      "explanation": "runOutsideAngular позволяет выполнить операцию без триггера CD, затем при необходимости вернуться в зону через run().",
      "difficulty": "medium"
    },
    {
      "id": 40,
      "question": "Назначение FormBuilder?",
      "options": [
        "Сборка CSS grid",
        "Упрощенное создание FormGroup/FormControl через фабричные методы",
        "Оптимизация HTTP",
        "Обработка роутинга"
      ],
      "correct": 1,
      "explanation": "FormBuilder предоставляет group/control/array методы для декларативного построения реактивных форм.",
      "difficulty": "medium"
    },
    {
      "id": 41,
      "question": "ReplaySubject отличается тем что?",
      "options": [
        "Не хранит значения",
        "Хранит заданное число последних эмиссий и реплеит новым подписчикам",
        "Работает только с Errors",
        "Всегда буферизует бесконечно"
      ],
      "correct": 1,
      "explanation": "ReplaySubject(n) кэширует последние n значений и при подписке выдает их сразу новому наблюдателю.",
      "difficulty": "medium"
    },
    {
      "id": 42,
      "question": "NgFor директива относится к типу?",
      "options": [
        "Атрибутной",
        "Структурной",
        "Pipe",
        "Сервисной"
      ],
      "correct": 1,
      "explanation": "*ngFor структурная директива: она изменяет структуру DOM добавлением/удалением узлов.",
      "difficulty": "medium"
    },
    {
      "id": 43,
      "question": "forwardRef используется для?",
      "options": [
        "Оптимизации pipe",
        "Ссылки на класс, объявляемый позже (циклические зависимости)",
        "Удаления модуля",
        "Асинхронного импорта шаблона"
      ],
      "correct": 1,
      "explanation": "forwardRef(() => Type) позволяет указать токен до фактического определения класса (решая круговые зависимости).",
      "difficulty": "medium"
    },
    {
      "id": 44,
      "question": "NgTemplateOutlet служит для?",
      "options": [
        "Генерации CSS",
        "Вставки указанного <ng-template> в текущий просмотр",
        "Логирования ошибок",
        "Удаления DI"
      ],
      "correct": 1,
      "explanation": "NgTemplateOutlet позволяет программно рендерить шаблоны, передавая контекст и изменяя композицию UI.",
      "difficulty": "medium"
    },
    {
      "id": 45,
      "question": "Стратегия оптимизации при большом списке компонентов?",
      "options": [
        "Использовать Impure pipes везде",
        "OnPush + trackBy + виртуализация списка",
        "Отключить AoT",
        "Глубокое клонирование данных"
      ],
      "correct": 1,
      "explanation": "Комбинация OnPush, правильного trackBy и виртуализации (cdk-virtual-scroll) снижает перерисовки и нагруженность CD.",
      "difficulty": "medium"
    },
    {
      "id": 46,
      "question": "Dynamic component creation делается через?",
      "options": [
        "HttpClient",
        "ViewContainerRef.createComponent(...)",
        "Renderer2.createRoot(...)",
        "NgModuleFactoryResolver для Signal"
      ],
      "correct": 1,
      "explanation": "ViewContainerRef.createComponent позволяет динамически создать компонент и вставить его в контейнер.",
      "difficulty": "medium"
    },
    {
      "id": 47,
      "question": "Разница между mergeMap и concatMap?",
      "options": [
        "concatMap параллелит все",
        "mergeMap параллелит, concatMap последовательно обрабатывает внутренние Observables",
        "mergeMap всегда отменяет предыдущие",
        "concatMap вызывает ошибку на втором значении"
      ],
      "correct": 1,
      "explanation": "mergeMap подписывается параллельно, concatMap ставит в очередь, выполняя по порядку (сохранение порядка).",
      "difficulty": "medium"
    },
    {
      "id": 48,
      "question": "NgRx используется для?",
      "options": [
        "SSR сборки",
        "Управления глобальным состоянием через Redux-подобный паттерн",
        "Оптимизации CSS",
        "Отрисовки Canvas"
      ],
      "correct": 1,
      "explanation": "NgRx реализует стор, actions, reducers, effects для предсказуемого управления состоянием и сайд-эффектами.",
      "difficulty": "medium"
    },
    {
      "id": 49,
      "question": "Effect в NgRx предназначен для?",
      "options": [
        "Чтения state без действий",
        "Обработки асинхронных сайд-эффектов и диспатча новых действий",
        "Переопределения DI",
        "Очистки store"
      ],
      "correct": 1,
      "explanation": "Effects слушают поток действий, выполняют async операции (HTTP) и диспатчат новые actions без мутаций.",
      "difficulty": "medium"
    },
    {
      "id": 50,
      "question": "Что такое Selector в NgRx?",
      "options": [
        "HTTP middleware",
        "Мемоизированная функция выборки части состояния",
        "Pipe трансформатор",
        "Интерцептор роутинга"
      ],
      "correct": 1,
      "explanation": "Selector комбинирует части state и мемоизирует результат, предотвращая лишние вычисления при неизменном входе.",
      "difficulty": "medium"
    },
    {
      "id": 51,
      "question": "SSR (Angular Universal) дает?",
      "options": [
        "Увеличение JS размера",
        "Предрендер страниц на сервере для SEO/перформанса",
        "Удаление DI",
        "Замену RxJS на Fetch"
      ],
      "correct": 1,
      "explanation": "SSR рендерит HTML на сервере, улучшая Time-to-First-Byte, SEO и восприятие скорости.",
      "difficulty": "medium"
    },
    {
      "id": 52,
      "question": "NG1000 ошибки относятся к?",
      "options": [
        "Системе логирования",
        "Angular компилятору (Ivy) сообщения диагностики",
        "CSS парсеру",
        "Node.js версии"
      ],
      "correct": 1,
      "explanation": "Коды NGxxxx — диагностические ошибки Angular Compiler/Ivy, помогают локализовать проблему в шаблонах/метаданных.",
      "difficulty": "medium"
    },
    {
      "id": 53,
      "question": "Standalone bootstrap делается через?",
      "options": [
        "platformBrowser().bootstrapModule(...)",
        "bootstrapApplication(RootComponent, options)",
        "Renderer2.init(...)",
        "runSignalApp(...)"
      ],
      "correct": 1,
      "explanation": "bootstrapApplication позволяет запускать приложение без корневого NgModule, указывая провайдеры напрямую.",
      "difficulty": "medium"
    },
    {
      "id": 54,
      "question": "Router navigate vs navigateByUrl различие?",
      "options": [
        "navigateByUrl не принимает массив сегментов",
        "navigate принимает массив сегментов и разрезолвит относительные маршруты",
        "navigateByUrl всегда сбрасывает state",
        "navigate нельзя использовать в Guards"
      ],
      "correct": 1,
      "explanation": "navigate(['path']) учитывает относительный контекст, navigateByUrl('/abs') работает со строкой абсолютного URL.",
      "difficulty": "medium"
    },
    {
      "id": 55,
      "question": "Почему важно отписываться от вручную созданных подписок?",
      "options": [
        "Для ускорения сборки",
        "Чтобы избежать утечек памяти и лишних CD триггеров",
        "Чтобы включить AoT",
        "Для SSR работы"
      ],
      "correct": 1,
      "explanation": "Ненужные подписки держат ссылки на компоненты, не позволяя GC и вызывая лишние обновления.",
      "difficulty": "medium"
    },
    {
      "id": 56,
      "question": "NgRx Entity облегчает?",
      "options": [
        "Генерацию модулей",
        "CRUD операции и нормализацию коллекций в store",
        "SSR",
        "Сборку стилей"
      ],
      "correct": 1,
      "explanation": "EntityAdapter обеспечивает методы add/update/remove и селекторы для управляемых коллекций сущностей.",
      "difficulty": "medium"
    },
    {
      "id": 57,
      "question": "Directive host binding задается через?",
      "options": [
        "@PipeBinding",
        "@HostBinding() и @HostListener()",
        "@InjectHost",
        "@ViewHost"
      ],
      "correct": 1,
      "explanation": "@HostBinding связывает свойство директивы с атрибутом/классом/стилем хоста, @HostListener слушает события хоста.",
      "difficulty": "medium"
    },
    {
      "id": 58,
      "question": "Optimistic UI обновление в Angular обычно реализуют через?",
      "options": [
        "Отложенную навигацию",
        "Немедленное обновление локального состояния до подтверждения сервера с последующим rollback при ошибке",
        "SSR перерендер",
        "Удаление компонента"
      ],
      "correct": 1,
      "explanation": "Optimistic UI повышает воспринимаемую скорость: локально меняем state, если сервер ошибку — откат.",
      "difficulty": "medium"
    },
    {
      "id": 59,
      "question": "Angular DevTools помогает?",
      "options": [
        "Писать SQL запросы",
        "Профилировать CD циклы, анализировать структуру и производительность",
        "Сжать изображения",
        "Деплоить на сервер"
      ],
      "correct": 1,
      "explanation": "DevTools показывает дерево компонентов, триггеры CD и позволяет диагностировать bottlenecks.",
      "difficulty": "medium"
    },
    {
      "id": 60,
      "question": "Что делает ng add?",
      "options": [
        "Удаляет пакеты",
        "Добавляет библиотеку и выполняет её schematic для настройки проекта",
        "Пересобирает node_modules",
        "Запускает тесты"
      ],
      "correct": 1,
      "explanation": "ng add <package> устанавливает пакет и запускает его schematics (настройка конфигов, модулей).",
      "difficulty": "medium"
    },
    {
      "id": 61,
      "question": "Что такое builder в Angular CLI?",
      "options": [
        "Переводчик i18n",
        "Расширяемая задача (build, test, e2e) реализуемая через target и пакет",
        "Module federation",
        "Runtime DI контейнер"
      ],
      "correct": 1,
      "explanation": "CLI builders определяют поведение команд (ng build/test) и могут быть кастомизированы сторонними пакетами.",
      "difficulty": "hard"
    },
    {
      "id": 62,
      "question": "Как работает Tree-Shaking в Angular с Ivy?",
      "options": [
        "Удаляет все сервисы",
        "Устраняет неиспользуемый код благодаря точечным импортам и статическому анализу метаданных",
        "Заменяет runtime",
        "Сокращает HTML"
      ],
      "correct": 1,
      "explanation": "Ivy генерирует компактные фабрики, позволяя bundler'ам удалить неиспользуемые компоненты/директивы/пайпы.",
      "difficulty": "hard"
    },
    {
      "id": 63,
      "question": "Назначение ControlValueAccessor?",
      "options": [
        "Оптимизация CD",
        "Интеграция кастомного компонента со Form API",
        "SSR hydrate",
        "Сжатие JS"
      ],
      "correct": 1,
      "explanation": "ControlValueAccessor адаптер соединяет компонент с ngModel/Reactive Forms (writeValue, registerOnChange...).",
      "difficulty": "hard"
    },
    {
      "id": 64,
      "question": "Как минимизировать память при большом стриме Observable?",
      "options": [
        "Использовать Subject без завершения",
        "Отписываться (takeUntil), применять операторы (debounceTime), избегать вложенной подписки",
        "Делать ручной GC",
        "Хранить все значения в массиве"
      ],
      "correct": 1,
      "explanation": "Контроль подписок, ограничение потока, отсутствие nested subscribe и использование pipe операторов снижает утечки.",
      "difficulty": "hard"
    },
    {
      "id": 65,
      "question": "difference между Subject и BehaviorSubject?",
      "options": [
        "BehaviorSubject не хранит значение",
        "BehaviorSubject хранит последнее и выдает его новым подписчикам",
        "Subject всегда реплеит два значения",
        "Subject требует начальное значение"
      ],
      "correct": 1,
      "explanation": "BehaviorSubject(initial) хранит последнее значение; Subject не выдает прошлых значений новым подписчикам.",
      "difficulty": "hard"
    },
    {
      "id": 66,
      "question": "Как реализовать кастомный Async Validator?",
      "options": [
        "Через pipe",
        "Функция возвращает Promise/Observable ValidationErrors|null",
        "Использовать Renderer2",
        "Через @Directive без селектора"
      ],
      "correct": 1,
      "explanation": "Async валидатор — функция (control) => Observable<ValidationErrors|null> подключается в asyncValidators массива.",
      "difficulty": "hard"
    },
    {
      "id": 67,
      "question": "NgZone отключение (zone-less) требует?",
      "options": [
        "Использовать signal store",
        "bootstrapApplication с { ngZone: 'noop' } и ручные Trigger CD (ChangeDetectorRef) или сигналами",
        "Удалить RxJS",
        "Применить Impure pipe"
      ],
      "correct": 1,
      "explanation": "При 'noop' зоне Angular не инициирует CD автоматически, нужен ручной вызов markForCheck/detectChanges или Signals.",
      "difficulty": "hard"
    },
    {
      "id": 68,
      "question": "Как протестировать компонент с зависимостью от HttpClient?",
      "options": [
        "Использовать реальный сервер",
        "Подключить HttpClientTestingModule и использовать HttpTestingController для моков",
        "Заменить на fetch",
        "Отключить DI"
      ],
      "correct": 1,
      "explanation": "HttpClientTestingModule предоставляет HttpTestingController.expectOne для контроля запросов и ответов в юнит тестах.",
      "difficulty": "hard"
    },
    {
      "id": 69,
      "question": "Глубокая оптимизация CD при сложных графах состояния?",
      "options": [
        "Использовать impure pipes",
        "OnPush + immutability + мемоизация селекторов + разделение больших компонентов",
        "Отключить AoT",
        "Создать один глобальный компонент"
      ],
      "correct": 1,
      "explanation": "Иммутабельные структуры + OnPush + разбиение дерева и мемоизированные селекторы уменьшают затраты CD.",
      "difficulty": "hard"
    },
    {
      "id": 70,
      "question": "Преимущество RendererFactory2?",
      "options": [
        "Создает тесты автоматически",
        "Настройка кастомного рендерера (например логирование операций DOM)",
        "Оптимизация HTTP",
        "Увеличение размера бандла"
      ],
      "correct": 1,
      "explanation": "RendererFactory2 позволяет внедрить собственную логику при создании Renderer2 для расширенных платформенных сценариев.",
      "difficulty": "hard"
    },
    {
      "id": 71,
      "question": "Как использовать Web Worker в Angular?",
      "options": [
        "Через импорта RxJS",
        "ng generate web-worker <component> затем вынести тяжелую логику в worker",
        "Создать pipe",
        "Добавить Guard"
      ],
      "correct": 1,
      "explanation": "CLI генерирует scaffold worker. Сообщения передаются через postMessage. Уменьшает main thread блокировки.",
      "difficulty": "hard"
    },
    {
      "id": 72,
      "question": "Custom PreloadingStrategy нужна для?",
      "options": [
        "Компиляции TS",
        "Тонкой настройки загрузки lazy модулей (условно, при сети/приоритетах)",
        "Замены DI",
        "Кеширования сигналов"
      ],
      "correct": 1,
      "explanation": "Реализуя PreloadingStrategy можно решать когда подгружать lazy-модуль (на основе метаданных маршрута).",
      "difficulty": "hard"
    },
    {
      "id": 73,
      "question": "Как минимизировать bundle size?",
      "options": [
        "Отключить production режим",
        "Использовать Standalone, lazy loading, удалять polyfills, оптимизировать imports, включить build optimizer",
        "Включить impure pipes",
        "Добавить большие библиотеки"
      ],
      "correct": 1,
      "explanation": "Продакшен сборка + build optimizer + правильное разделение кода и отсутствие лишних зависимостей снижают размер.",
      "difficulty": "hard"
    },
    {
      "id": 74,
      "question": "Difference между Defer блоком (@defer) и обычным шаблоном?",
      "options": [
        "@defer ускоряет always",
        "@defer откладывает рендер части UI до наступления триггеров (видимость, idle)",
        "@defer обязательный для всех компонентов",
        "Обычный шаблон не может рендериться"
      ],
      "correct": 1,
      "explanation": "@defer (Angular 17+) позволяет частично загружать UI позже, снижая initial work и improving performance.",
      "difficulty": "hard"
    },
    {
      "id": 75,
      "question": "Когда использовать markForCheck()?",
      "options": [
        "При OnPush когда внешняя реактивность изменила данные вне Angular зоны",
        "Всегда при любом событии",
        "Для удаления компонента",
        "При инициализации root модуля"
      ],
      "correct": 0,
      "explanation": "markForCheck помечает OnPush компонент для последующей проверки при следующем проходе CD.",
      "difficulty": "hard"
    },
    {
      "id": 76,
      "question": "detectChanges() отличие от markForCheck()?",
      "options": [
        "detectChanges запускает проверку немедленно локально, markForCheck откладывает до общего цикла",
        "Оба делают одно и то же",
        "markForCheck делает немедленный рекурсивный проход",
        "detectChanges запрещен в продакшене"
      ],
      "correct": 0,
      "explanation": "detectChanges немедленно запускает CD для текущего дерева, markForCheck лишь помечает для будущего цикла.",
      "difficulty": "hard"
    },
    {
      "id": 77,
      "question": "Как реализовать многократную Content Projection?",
      "options": [
        "Несколько @Pipe",
        "Использовать <ng-content select=\"...\"> для разных слотов",
        "Создать несколько модулей",
        "Сделать dynamic import"
      ],
      "correct": 1,
      "explanation": "Несколько <ng-content select=\".header\"> и т.п. позволяют проецировать разные части контента отдельно.",
      "difficulty": "hard"
    },
    {
      "id": 78,
      "question": "NgRx Store freeze (dev) предотвращает?",
      "options": [
        "Async запросы",
        "Мутацию state объектов напрямую",
        "Переход по маршруту",
        "Сигналы"
      ],
      "correct": 1,
      "explanation": "Store freeze выбрасывает ошибку при попытке изменить state напрямую, enforcing immutability.",
      "difficulty": "hard"
    },
    {
      "id": 79,
      "question": "Почему не стоит делать nested subscribe?",
      "options": [
        "Это быстрее",
        "Усложняет управление отписками, теряется композиция операторов",
        "Запрещено компилятором",
        "Ломает DI"
      ],
      "correct": 1,
      "explanation": "Композиция через pipe операторов (switchMap/mergeMap) заменяет вложенные subscribe, улучшая контроль потоков.",
      "difficulty": "hard"
    },
    {
      "id": 80,
      "question": "Webpack Module Federation интеграция нужна для?",
      "options": [
        "Сборки SCSS",
        "Динамической загрузки удаленных модулей/приложений (micro-frontend)",
        "Оптимизации CSS переменных",
        "Удаления Observables"
      ],
      "correct": 1,
      "explanation": "Module Federation позволяет шарить/загружать части приложений как удаленные модули, реализуя micro-frontend архитектуру.",
      "difficulty": "hard"
    },
    {
      "id": 81,
      "question": "Сложный компонент сильно нагружает Change Detection. Первое действие?",
      "options": [
        "Переход на Impure pipes",
        "Анализ шаблона/передача тяжелой логики вне шаблона и применение OnPush",
        "Отключить SSR",
        "Добавить больше watchers"
      ],
      "correct": 1,
      "explanation": "Перенос расчетов из шаблона, мемоизация и OnPush уменьшают нагрузку.",
      "difficulty": "hard"
    },
    {
      "id": 82,
      "question": "Как избежать дублирующих HTTP запросов при нескольк подписчиках?",
      "options": [
        "Использовать concatMap",
        "shareReplay(1) на Observable запроса",
        "Использовать nested subscribe",
        "Всегда делать новый HttpClient"
      ],
      "correct": 1,
      "explanation": "shareReplay кэширует результат и повторно выдает подписчикам без нового HTTP.",
      "difficulty": "hard"
    },
    {
      "id": 83,
      "question": "Custom Structural Directive базовый API?",
      "options": [
        "@Pipe + transform",
        "@Directive + TemplateRef + ViewContainerRef для управления вложениями",
        "@Component + styleUrls",
        "@Injectable + providedIn"
      ],
      "correct": 1,
      "explanation": "Структурная директива получает TemplateRef и управляет вставкой/удалением через ViewContainerRef.",
      "difficulty": "hard"
    },
    {
      "id": 84,
      "question": "Сложная логика маршрутизации + сохранение состояния формы при уходе?",
      "options": [
        "Использовать pipe async",
        "CanDeactivate Guard для подтверждения и возможного сохранения",
        "Удалить форму",
        "Отключить роутер"
      ],
      "correct": 1,
      "explanation": "CanDeactivate позволяет проверить состояние (грязная форма) и решить о навигации/сохранении данных.",
      "difficulty": "hard"
    },
    {
      "id": 85,
      "question": "Оптимизация i18n runtime?",
      "options": [
        "Вставить строки вручную",
        "Компиляция переводов на build этапе (i18n extraction + локализация) уменьшает runtime работу",
        "Выполнять все через JSON.parse",
        "Дублировать ключи"
      ],
      "correct": 1,
      "explanation": "Статическая локализация собирает сообщений и генерирует локализованные бандлы, исключая runtime lookup.",
      "difficulty": "hard"
    },
    {
      "id": 86,
      "question": "Как профилировать медленный компонент?",
      "options": [
        "Добавить console.log везде",
        "Использовать Angular DevTools + Performance профайлер браузера",
        "Отключить HTTP",
        "Удалить RxJS"
      ],
      "correct": 1,
      "explanation": "DevTools показывает CD триггеры, браузер Performance — время рендеринга и layout.",
      "difficulty": "hard"
    },
    {
      "id": 87,
      "question": "В чем риск передачи больших объектов через Input без иммутабельности?",
      "options": [
        "Никакого риска",
        "OnPush не обнаружит глубокие изменения, что приведет к несвоевременной перерисовке",
        "Router сломается",
        "HTTP отключится"
      ],
      "correct": 1,
      "explanation": "OnPush реагирует на смену ссылок; мутирование внутри не меняет ссылку — UI не обновится.",
      "difficulty": "hard"
    },
    {
      "id": 88,
      "question": "Complex State: почему использовать Facade слой?",
      "options": [
        "Увеличить связность",
        "Скрыть детали store, упростить тестирование и уменьшить знания компонента о реализации",
        "Удалить селекторы",
        "Обойти DI"
      ],
      "correct": 1,
      "explanation": "Facade изолирует компоненты от множества selectors/actions, упрощает миграции и тестирование.",
      "difficulty": "hard"
    },
    {
      "id": 89,
      "question": "Оператор exhaustMap применяется когда?",
      "options": [
        "Нужно параллелить все запросы",
        "Игнорировать новые эмиссии пока текущий внутренний Observable не завершится",
        "Отменять текущий",
        "Всегда повторять ошибки"
      ],
      "correct": 1,
      "explanation": "exhaustMap полезен для предотвращения спама (кнопка submit) игнорируя новые клики до завершения текущей операции.",
      "difficulty": "hard"
    },
    {
      "id": 90,
      "question": "setState в Signal Store предпочтительнее прямой мутации потому что?",
      "options": [
        "Ускоряет CSS",
        "Сохраняет неизменяемость и гарантирует корректные уведомления зависимостей",
        "Удаляет RxJS",
        "Делает SSR невозможным"
      ],
      "correct": 1,
      "explanation": "Иммутабельное обновление состояния гарантирует детерминированные сигналы и корректный tracking зависимостей.",
      "difficulty": "hard"
    },
    {
      "id": 91,
      "question": "Оптимизация высокой частоты событий (scroll/resize)?",
      "options": [
        "Ставить console.log",
        "Использовать throttleTime/debounceTime и runOutsideAngular",
        "Отключить роутер",
        "Всегда делать mergeMap"
      ],
      "correct": 1,
      "explanation": "Снижение частоты обработчиков и выполнение вне зоны уменьшает CD нагрузку.",
      "difficulty": "hard"
    },
    {
      "id": 92,
      "question": "Почему важна сериализация state при SSR?",
      "options": [
        "Для включения XSS",
        "Чтобы передать предварительно загруженные данные клиенту и избежать повторного запроса",
        "Ускорить компилятор",
        "Удалить CSS"
      ],
      "correct": 1,
      "explanation": "Сериализация state в window позволяет клиенту гидратировать приложение без повторных загрузок.",
      "difficulty": "hard"
    },
    {
      "id": 93,
      "question": "NgOptimizedImage дает?",
      "options": [
        "Удаляет HTML",
        "Автоматические подсказки загрузки, оптимизацию и lazy для изображений",
        "Замену роутера",
        "Миграцию RxJS"
      ],
      "correct": 1,
      "explanation": "NgOptimizedImage упрощает внедрение оптимизированных изображений (preload, lazy, правильные sizes/srcset).",
      "difficulty": "hard"
    },
    {
      "id": 94,
      "question": "Как минимизировать влияние больших третьих библиотек?",
      "options": [
        "Импортировать всё",
        "Использовать динамический import() и lazy маршруты",
        "Сделать полифил",
        "Добавить в global scope"
      ],
      "correct": 1,
      "explanation": "Code-splitting через dynamic import и lazy loading загружает библиотеку только при необходимости.",
      "difficulty": "hard"
    },
    {
      "id": 95,
      "question": "Abstract class vs interface в Angular DI?",
      "options": [
        "Интерфейс может быть токеном",
        "Abstract class может выступать в роли токена и иметь реализацию",
        "Оба не могут быть токеном",
        "Только интерфейс хранит метаданные"
      ],
      "correct": 1,
      "explanation": "Интерфейсы стираются в JS и не могут быть токенами; абстрактные классы сохраняются и могут использоваться в DI.",
      "difficulty": "hard"
    },
    {
      "id": 96,
      "question": "Применение scoped provider в компоненте?",
      "options": [
        "provider в компоненте создает shared singleton",
        "provider в компоненте создает новый инстанс для каждого экземпляра компонента",
        "provider ломает DI",
        "provider отключает Change Detection"
      ],
      "correct": 1,
      "explanation": "Определение providers в компоненте создает дочерний injector и изолирует экземпляры зависимостей.",
      "difficulty": "hard"
    },
    {
      "id": 97,
      "question": "Как отложить тяжёлый вычислительный pipe?",
      "options": [
        "Добавить в шаблон прямой вызов",
        "Перейти на мемоизацию и вызывать вне шаблона, передавая результат",
        "Использовать impure pipe",
        "Расширить DI"
      ],
      "correct": 1,
      "explanation": "Тяжёлые вычисления лучше вынести из шаблона, мемоизировать по входным параметрам и передавать готовое значение.",
      "difficulty": "hard"
    },
    {
      "id": 98,
      "question": "Security: bypassSecurityTrustHtml опасен потому что?",
      "options": [
        "Делает HTML безопасным автоматически",
        "Отменяет санитизацию и может допустить XSS если контент не проверен",
        "Удаляет DOM",
        "Останавливает CD"
      ],
      "correct": 1,
      "explanation": "bypassSecurityTrustHtml нужно применять только к гарантированно безопасному контенту иначе возможны XSS уязвимости.",
      "difficulty": "hard"
    },
    {
      "id": 99,
      "question": "State normalization зачем?",
      "options": [
        "Увеличить сложность",
        "Предотвратить дубли, ускорить выборку и обновление сущностей",
        "Удалить селекторы",
        "Заменить DI"
      ],
      "correct": 1,
      "explanation": "Нормализация (map id->entity) упрощает обновления и выборку, снижает дублирование и сложность вложенных структур.",
      "difficulty": "hard"
    },
    {
      "id": 100,
      "question": "Почему важно явно типизировать Observable потоки?",
      "options": [
        "Для отключения оптимизаций",
        "Предотвращает ошибки на этапе компиляции, улучшает читаемость и рефакторинг",
        "Увеличивает размер бандла",
        "Замедляет runtime"
      ],
      "correct": 1,
      "explanation": "Строгая типизация потоков (Observable<User>) гарантирует корректность операторов и облегчает поддержку кода.",
      "difficulty": "hard"
    },
    {
      "id": 101,
      "question": "Что делает декоратор @NgModule?",
      "options": [
        "Определяет корневой HTML-документ",
        "Описывает метаданные модуля: declarations, imports, providers, bootstrap",
        "Создаёт новый компонент во время выполнения",
        "Выполняет AoT компиляцию"
      ],
      "correct": 1,
      "explanation": "@NgModule связывает связанные компоненты, директивы и пайпы в логический модуль и описывает зависимости через imports, providers и bootstrap.",
      "difficulty": "easy"
    },
    {
      "id": 102,
      "question": "Для чего используется BrowserModule?",
      "options": [
        "Для работы с серверным рендерингом",
        "Для запуска приложения в браузере и экспорта общих директив (ngIf, ngFor)",
        "Только для работы с формами",
        "Только для роутинга"
      ],
      "correct": 1,
      "explanation": "BrowserModule импортируется в корневой модуль приложения и предоставляет базовую инфраструктуру платформы браузера и общие директивы.",
      "difficulty": "easy"
    },
    {
      "id": 103,
      "question": "Какую задачу решает CommonModule?",
      "options": [
        "Подключение HTTP-клиента",
        "Предоставляет общие директивы и пайпы (ngIf, ngFor) для feature-модулей",
        "Управление состоянием",
        "Организацию маршрутов"
      ],
      "correct": 1,
      "explanation": "CommonModule импортируется в feature-модули и предоставляет базовые директивы и пайпы, используемые в шаблонах.",
      "difficulty": "easy"
    },
    {
      "id": 104,
      "question": "Что такое декларации (declarations) в @NgModule?",
      "options": [
        "Список сервисов, доступных через DI",
        "Список компонентов, директив и пайпов, принадлежащих модулю",
        "Список импортируемых модулей",
        "Список маршрутов"
      ],
      "correct": 1,
      "explanation": "В declarations объявляются view-классы (components, directives, pipes), которые принадлежат модулю и могут использоваться в его шаблонах.",
      "difficulty": "easy"
    },
    {
      "id": 105,
      "question": "Для чего предназначено свойство providers в @NgModule?",
      "options": [
        "Для регистрации маршрутов",
        "Для регистрации сервисов и других провайдеров в DI-контейнере модуля",
        "Для объявления компонентов",
        "Для подключения стилей"
      ],
      "correct": 1,
      "explanation": "providers определяет токены и реализации, доступные через DI внутри модуля (или всего приложения при импорте в root).",
      "difficulty": "easy"
    },
    {
      "id": 106,
      "question": "Чем отличается declarations от imports в @NgModule?",
      "options": [
        "imports объявляет компоненты, а declarations — модули",
        "declarations объявляет view-классы текущего модуля, imports подключает другие модули",
        "Они полностью эквивалентны",
        "imports используется только в тестах"
      ],
      "correct": 1,
      "explanation": "declarations указывает, какие компоненты/директивы/пайпы принадлежат модулю, а imports подключает внешние модули и их экспортируемые декларации.",
      "difficulty": "easy"
    },
    {
      "id": 107,
      "question": "Зачем нужен HttpClientModule?",
      "options": [
        "Для работы с WebSocket",
        "Для использования HttpClient и интерцепторов",
        "Для настройки роутера",
        "Для подключения NgRx"
      ],
      "correct": 1,
      "explanation": "HttpClientModule регистрирует HttpClient и связанные провайдеры, позволяя выполнять HTTP-запросы и настраивать интерцепторы.",
      "difficulty": "easy"
    },
    {
      "id": 108,
      "question": "Что такое ReactiveFormsModule?",
      "options": [
        "Модуль для шаблонных форм",
        "Модуль, предоставляющий API реактивных форм (FormGroup, FormControl)",
        "Модуль для анимаций",
        "Модуль для SSR"
      ],
      "correct": 1,
      "explanation": "ReactiveFormsModule активирует директивы и классы для реактивного подхода к формам, позволяя управлять формой из кода.",
      "difficulty": "easy"
    },
    {
      "id": 109,
      "question": "Для чего используется FormsModule?",
      "options": [
        "Для работы с NgRx",
        "Для шаблонно-ориентированных форм с ngModel",
        "Для SSR",
        "Для настройки роутинга"
      ],
      "correct": 1,
      "explanation": "FormsModule включает директивы ngModel и связанные с ними возможности, реализуя template-driven подход к формам.",
      "difficulty": "easy"
    },
    {
      "id": 110,
      "question": "Что такое RouterOutlet?",
      "options": [
        "Сервис для навигации",
        "Директива-место в шаблоне, куда роутер вставляет компонент активного маршрута",
        "Pipe для подготовки URL",
        "Модуль для lazy loading"
      ],
      "correct": 1,
      "explanation": "<router-outlet> — директива, которая служит контейнером для отображения компонентов в зависимости от активного маршрута.",
      "difficulty": "easy"
    },
    {
      "id": 111,
      "question": "Какой декоратор используется для описания сервисов в Angular?",
      "options": [
        "@Component",
        "@Injectable",
        "@Directive",
        "@NgModule"
      ],
      "correct": 1,
      "explanation": "@Injectable помечает класс как доступный для DI и позволяет Angular генерировать метаданные для внедрения зависимостей.",
      "difficulty": "easy"
    },
    {
      "id": 112,
      "question": "Какой параметр providedIn у @Injectable делает сервис синглтоном на уровне приложения?",
      "options": [
        "'any'",
        "'root'",
        "'platform'",
        "'component'"
      ],
      "correct": 1,
      "explanation": "providedIn: 'root' регистрирует сервис в корневом инжекторе, что делает его синглтоном для всего приложения.",
      "difficulty": "easy"
    },
    {
      "id": 113,
      "question": "Что такое Dependency Injection в контексте Angular?",
      "options": [
        "Механизм ленивой загрузки модулей",
        "Механизм предоставления зависимостей объектам через контейнер, а не создания их напрямую",
        "Система логирования ошибок",
        "Инструмент сборки проекта"
      ],
      "correct": 1,
      "explanation": "DI позволяет компонентам и сервисам получать зависимости от контейнера по токену, улучшая тестируемость и слабую связанность.",
      "difficulty": "easy"
    },
    {
      "id": 114,
      "question": "Какой декоратор используется для привязки входного параметра компонента?",
      "options": [
        "@Output",
        "@Input",
        "@HostBinding",
        "@ViewChild"
      ],
      "correct": 1,
      "explanation": "@Input помечает свойство компонента как входное и позволяет родителю передавать ему данные через привязку.",
      "difficulty": "easy"
    },
    {
      "id": 115,
      "question": "Для чего используется декоратор @Output?",
      "options": [
        "Для объявления зависимостей",
        "Для объявления события, на которое может подписаться родительский компонент",
        "Для указания селектора компонента",
        "Для регистрации маршрута"
      ],
      "correct": 1,
      "explanation": "@Output вместе с EventEmitter позволяет компоненту эмитировать события, на которые может реагировать родитель.",
      "difficulty": "easy"
    },
    {
      "id": 116,
      "question": "Что такое data binding в Angular?",
      "options": [
        "Передача данных только из шаблона в компонент",
        "Механизм синхронизации данных между моделью и представлением",
        "Только привязка событий",
        "Только привязка атрибутов"
      ],
      "correct": 1,
      "explanation": "Data binding включает интерполяцию, привязку свойств, событий и двустороннюю привязку ([(ngModel)]), синхронизируя модель и шаблон.",
      "difficulty": "easy"
    },
    {
      "id": 117,
      "question": "Как в шаблоне объявить двустороннюю привязку с ngModel?",
      "options": [
        "[ngModel]",
        "(ngModel)",
        "[(ngModel)]",
        "{{ ngModel }}"
      ],
      "correct": 2,
      "explanation": "Синтаксис banana-in-a-box [(ngModel)] объединяет привязку значения и события изменения, образуя двустороннюю привязку.",
      "difficulty": "easy"
    },
    {
      "id": 118,
      "question": "Что делает директива *ngIf?",
      "options": [
        "Прячет элемент через display:none",
        "Добавляет или удаляет элемент из DOM в зависимости от условия",
        "Меняет стиль элемента",
        "Создаёт новый модуль"
      ],
      "correct": 1,
      "explanation": "*ngIf — структурная директива, которая физически добавляет или удаляет элемент из DOM в зависимости от булевого выражения.",
      "difficulty": "easy"
    },
    {
      "id": 119,
      "question": "Как в Angular объявить обработчик события click в шаблоне?",
      "options": [
        "[click]=\"onClick()\"",
        "(click)=\"onClick()\"",
        "{{ click:onClick() }}",
        "#click=\"onClick()\""
      ],
      "correct": 1,
      "explanation": "Синтаксис (event)=\"handler()\" используется для привязки событий DOM к методам компонента, например (click)=\"onClick()\".",
      "difficulty": "easy"
    },
    {
      "id": 120,
      "question": "Что такое шаблонный reference-переменная (template reference variable)?",
      "options": [
        "Локальная переменная в TypeScript",
        "Переменная, объявленная в шаблоне через #name для ссылки на элемент или директиву",
        "Импортированный модуль",
        "Сервис DI"
      ],
      "correct": 1,
      "explanation": "Template reference variable (#var) даёт доступ к DOM-элементу, компоненту или директиве напрямую из шаблона.",
      "difficulty": "easy"
    },
    {
      "id": 121,
      "question": "Для чего используется директива ngClass?",
      "options": [
        "Для привязки стилей inline",
        "Для динамического добавления/удаления CSS-классов в зависимости от условия",
        "Для управления анимациями",
        "Для объявления маршрутов"
      ],
      "correct": 1,
      "explanation": "ngClass позволяет задавать классы как строку, массив или объект {class: condition}, динамически изменяя оформление элемента.",
      "difficulty": "easy"
    },
    {
      "id": 122,
      "question": "Что делает директива ngStyle?",
      "options": [
        "Управляет анимациями",
        "Динамически задаёт inline-стили через объект или выражение",
        "Определяет селектор компонента",
        "Регистрирует сервис"
      ],
      "correct": 1,
      "explanation": "ngStyle позволяет привязывать объект стилей к элементу, изменяя CSS-свойства в зависимости от данных компонента.",
      "difficulty": "easy"
    },
    {
      "id": 123,
      "question": "Какой декоратор используется для доступа к дочерним элементам шаблона?",
      "options": [
        "@ViewChild",
        "@ContentChild",
        "@HostListener",
        "@Input"
      ],
      "correct": 0,
      "explanation": "@ViewChild и @ViewChildren позволяют получать ссылки на элементы и директивы во view-компонента после его инициализации.",
      "difficulty": "medium"
    },
    {
      "id": 124,
      "question": "Чем ViewChild отличается от ContentChild?",
      "options": [
        "ViewChild работает только в директивах",
        "ViewChild ищет во view-шаблоне компонента, ContentChild — в проецированном контенте",
        "Они полностью эквивалентны",
        "ContentChild ищет только по типу компонента"
      ],
      "correct": 1,
      "explanation": "ViewChild находит элементы в собственном шаблоне, а ContentChild — элементы, переданные через <ng-content> (content projection).",
      "difficulty": "medium"
    },
    {
      "id": 125,
      "question": "Что такое lifecycle hook в Angular?",
      "options": [
        "Любой метод компонента",
        "Специальный метод интерфейса жизненного цикла (ngOnInit, ngOnDestroy и т.п.), который Angular вызывает в определённые моменты",
        "Декоратор для DI",
        "Событие DOM"
      ],
      "correct": 1,
      "explanation": "Lifecycle hooks позволяют реагировать на создание, изменение и уничтожение компонента, реализуя соответствующие интерфейсы и методы.",
      "difficulty": "medium"
    },
    {
      "id": 126,
      "question": "В каком хуке жизненного цикла правильно работать с @ViewChild?",
      "options": [
        "В конструкторе",
        "В ngOnInit",
        "В ngAfterViewInit",
        "В ngOnChanges"
      ],
      "correct": 2,
      "explanation": "Ссылки ViewChild гарантированно проинициализированы только после вызова ngAfterViewInit, когда представление построено.",
      "difficulty": "medium"
    },
    {
      "id": 127,
      "question": "Что такое Angular Pipe?",
      "options": [
        "Сервис для логирования",
        "Класс с декоратором @Pipe, который трансформирует данные для отображения",
        "Модуль приложения",
        "Способ определения маршрута"
      ],
      "correct": 1,
      "explanation": "Pipe реализует метод transform(value, ...args) и позволяет форматировать данные непосредственно в шаблоне.",
      "difficulty": "easy"
    },
    {
      "id": 128,
      "question": "Для чего используется AsyncPipe в шаблоне?",
      "options": [
        "Для форматирования дат",
        "Для автоматической подписки на Observable/Promise и вывода последнего значения",
        "Для сортировки массивов",
        "Для логирования ошибок"
      ],
      "correct": 1,
      "explanation": "AsyncPipe подписывается на поток, отображает его значение и автоматически отписывается при уничтожении, предотвращая утечки.",
      "difficulty": "medium"
    },
    {
      "id": 129,
      "question": "Чем отличается pure pipe от impure pipe?",
      "options": [
        "Pure вызывается всегда, impure — только при изменении входов",
        "Pure вызывается только при изменении входных значений по ссылке, impure — при каждом цикле CD",
        "Impure нельзя использовать в шаблонах",
        "Pure запрещён в реактивных формах"
      ],
      "correct": 1,
      "explanation": "Pure pipe оптимизирован и вызывается только при изменении входных ссылок, impure вызывается на каждый проход CD, что дороже.",
      "difficulty": "medium"
    },
    {
      "id": 130,
      "question": "Что такое trackBy функция в *ngFor?",
      "options": [
        "Функция сортировки элементов",
        "Функция, возвращающая уникальный идентификатор элемента для оптимизации перерисовок",
        "Функция фильтрации элементов",
        "Функция валидации формы"
      ],
      "correct": 1,
      "explanation": "trackBy позволяет Angular отслеживать элементы по ключу (например id), уменьшая количество операций добавления/удаления DOM.",
      "difficulty": "medium"
    },
    {
      "id": 131,
      "question": "Что делает оператор map из RxJS?",
      "options": [
        "Фильтрует значения",
        "Преобразует каждое входное значение в новое",
        "Объединяет несколько Observable",
        "Выполняет HTTP-запрос"
      ],
      "correct": 1,
      "explanation": "map проецирует каждое значение потока в новое, сохраняя количество эмиссий и порядок.",
      "difficulty": "easy"
    },
    {
      "id": 132,
      "question": "Какой оператор RxJS используется для фильтрации значений по условию?",
      "options": [
        "map",
        "filter",
        "tap",
        "scan"
      ],
      "correct": 1,
      "explanation": "filter пропускает только значения, удовлетворяющие предикату, остальные отбрасываются.",
      "difficulty": "easy"
    },
    {
      "id": 133,
      "question": "Какой оператор RxJS удобно использовать для сайд-эффектов без изменения потока?",
      "options": [
        "tap",
        "map",
        "switchMap",
        "finalize"
      ],
      "correct": 0,
      "explanation": "tap позволяет выполнять произвольные действия (логирование, метрики), не модифицируя значения потока.",
      "difficulty": "easy"
    },
    {
      "id": 134,
      "question": "Какой оператор RxJS объединяет несколько Observable, выдавая значения в порядке завершения каждого?",
      "options": [
        "merge",
        "concat",
        "race",
        "combineLatest"
      ],
      "correct": 1,
      "explanation": "concat подписывается последовательно: следующий Observable начинается только после завершения предыдущего.",
      "difficulty": "medium"
    },
    {
      "id": 135,
      "question": "Какой оператор RxJS комбинирует последние значения нескольких Observable при любом изменении?",
      "options": [
        "combineLatest",
        "forkJoin",
        "merge",
        "concat"
      ],
      "correct": 0,
      "explanation": "combineLatest эмитит массив/кортеж последних значений всех источников каждый раз, когда один из них меняется.",
      "difficulty": "medium"
    },
    {
      "id": 136,
      "question": "Какой оператор RxJS ждёт завершения всех Observable и выдаёт одно значение с последними результатами?",
      "options": [
        "merge",
        "forkJoin",
        "combineLatest",
        "race"
      ],
      "correct": 1,
      "explanation": "forkJoin выполняет все Observable параллельно и эмитит один результат после завершения всех источников.",
      "difficulty": "medium"
    },
    {
      "id": 137,
      "question": "Когда стоит использовать debounceTime при работе с формами?",
      "options": [
        "При единичных кликах по кнопке",
        "При обработке ввода пользователя, чтобы не слать запрос на каждый символ",
        "При загрузке модуля",
        "При инициализации приложения"
      ],
      "correct": 1,
      "explanation": "debounceTime позволяет ждать паузу в наборе текста и тем самым уменьшать количество HTTP-запросов или вычислений.",
      "difficulty": "medium"
    },
    {
      "id": 138,
      "question": "Чем отличается Subject от Observable?",
      "options": [
        "Subject только читает значения",
        "Subject является как Observable, так и Observer и позволяет вручную эмитить значения",
        "Observable всегда горячий поток",
        "Отличий нет"
      ],
      "correct": 1,
      "explanation": "Subject реализует интерфейсы Observable и Observer, поэтому на него можно подписываться и эмитить значения вручную.",
      "difficulty": "medium"
    },
    {
      "id": 139,
      "question": "Что такое BehaviorSubject?",
      "options": [
        "Subject без начального значения",
        "Subject, который хранит последнее значение и немедленно отдаёт его новым подписчикам",
        "Subject, который никогда не завершает поток",
        "Subject, который работает только с ошибками"
      ],
      "correct": 1,
      "explanation": "BehaviorSubject требует начальное значение, хранит последнее и отдаёт его сразу при новой подписке.",
      "difficulty": "medium"
    },
    {
      "id": 140,
      "question": "В чём особенность ReplaySubject по сравнению с BehaviorSubject?",
      "options": [
        "ReplaySubject не хранит значения",
        "ReplaySubject может хранить несколько последних значений и воспроизводить их",
        "ReplaySubject работает только с синхронными потоками",
        "ReplaySubject не поддерживает ошибки"
      ],
      "correct": 1,
      "explanation": "ReplaySubject(n) кэширует n последних значений и воспроизводит их каждому новому подписчику.",
      "difficulty": "medium"
    },
    {
      "id": 141,
      "question": "Что делает оператор distinctUntilChanged?",
      "options": [
        "Фильтрует значения по типу",
        "Отбрасывает подряд идущие дубликаты значений",
        "Завершает поток при повторении значения",
        "Объединяет два потока"
      ],
      "correct": 1,
      "explanation": "distinctUntilChanged сравнивает текущее значение с предыдущим и пропускает дальше только изменения.",
      "difficulty": "medium"
    },
    {
      "id": 142,
      "question": "Для чего используется оператор share в RxJS?",
      "options": [
        "Для логирования",
        "Для превращения холодного Observable в горячий и повторного использования подписки",
        "Для сжатия значений",
        "Для сортировки значений"
      ],
      "correct": 1,
      "explanation": "share делит одну исходную подписку между несколькими подписчиками, чтобы не повторять побочные эффекты.",
      "difficulty": "hard"
    },
    {
      "id": 143,
      "question": "Какой оператор RxJS часто используют вместе с share для кеширования последнего значения?",
      "options": [
        "map",
        "shareReplay",
        "take",
        "delay"
      ],
      "correct": 1,
      "explanation": "shareReplay(1) комбинирует разделение подписки и кеширование последнего значения для новых подписчиков.",
      "difficulty": "hard"
    },
    {
      "id": 144,
      "question": "Какой оператор RxJS используется для обработки ошибок и возврата альтернативного потока?",
      "options": [
        "catchError",
        "retry",
        "finalize",
        "tap"
      ],
      "correct": 0,
      "explanation": "catchError перехватывает ошибку и позволяет вернуть новый Observable (fallback, пустой поток, логирование).",
      "difficulty": "hard"
    },
    {
      "id": 145,
      "question": "Какой оператор RxJS переиспользуют для повторной попытки запроса при ошибке?",
      "options": [
        "map",
        "retry",
        "mergeMap",
        "throttleTime"
      ],
      "correct": 1,
      "explanation": "retry(n) повторяет подписку на поток до n раз при ошибке, после чего ошибка пробрасывается дальше.",
      "difficulty": "hard"
    },
    {
      "id": 146,
      "question": "Для чего используют оператор finalize в RxJS?",
      "options": [
        "Для логирования только ошибок",
        "Для выполнения сайд-эффекта при завершении/ошибке/отписке от потока",
        "Для изменения типа значения",
        "Для фильтрации значений"
      ],
      "correct": 1,
      "explanation": "finalize вызывается единожды при завершении потока или отписке и удобен, например, для скрытия индикаторов загрузки.",
      "difficulty": "hard"
    },
    {
      "id": 147,
      "question": "Что такое cold Observable?",
      "options": [
        "Поток, который никогда не эмитит значения",
        "Поток, который запускает продьюсер отдельно для каждого подписчика",
        "Поток, который делит одно и то же значение между всеми подписчиками",
        "Поток, который уже завершился"
      ],
      "correct": 1,
      "explanation": "Cold Observable производит данные на основе подписчика: каждый подписчик получает свой независимый поток значений.",
      "difficulty": "hard"
    },
    {
      "id": 148,
      "question": "Что такое hot Observable?",
      "options": [
        "Поток, который запускается только при наличии одного подписчика",
        "Поток, значения которого разделяются между подписчиками и могут начаться до подписки",
        "Поток, который работает только с interval",
        "Поток, который всегда завершён"
      ],
      "correct": 1,
      "explanation": "Hot Observable (например Subject) эмитит значения независимо от количества подписчиков, разделяя источник.",
      "difficulty": "hard"
    },
    {
      "id": 149,
      "question": "Что такое ChangeDetectionStrategy.Default?",
      "options": [
        "Полное отключение CD",
        "Стратегия, при которой Angular проверяет компонент при любых возможных изменениях (events, async, таймеры)",
        "Стратегия только для OnPush компонентов",
        "Стратегия только для Standalone компонентов"
      ],
      "correct": 1,
      "explanation": "Default стратегия использует зону для автоматического запуска CD при большинстве асинхронных событий и изменении данных.",
      "difficulty": "medium"
    },
    {
      "id": 150,
      "question": "В чём преимущество ChangeDetectionStrategy.OnPush?",
      "options": [
        "Не требует иммутабельности",
        "Ограничивает проверку компонентом и его поддеревом только при явных триггерах, снижая нагрузку",
        "Полностью отключает CD",
        "Используется только в директивах"
      ],
      "correct": 1,
      "explanation": "OnPush уменьшает количество проверок, ожидая изменения входных ссылок, события внутри компонента или вызовы markForCheck.",
      "difficulty": "medium"
    },
    {
      "id": 151,
      "question": "Как включить OnPush для компонента?",
      "options": [
        "Установить флаг в main.ts",
        "Указать changeDetection: ChangeDetectionStrategy.OnPush в декораторе @Component",
        "Использовать директиву *ngOnPush",
        "Подключить Angular Universal"
      ],
      "correct": 1,
      "explanation": "Стратегия указывается на уровне компонента через поле changeDetection декоратора @Component.",
      "difficulty": "easy"
    },
    {
      "id": 152,
      "question": "Почему важно использовать иммутабельные структуры данных с OnPush?",
      "options": [
        "Чтобы ускорить HTTP-запросы",
        "Чтобы Angular мог определять изменения по смене ссылок, а не по глубокому сравнению",
        "Чтобы уменьшить размер бандла",
        "Чтобы отключить zone.js"
      ],
      "correct": 1,
      "explanation": "OnPush полагается на сравнение ссылок, поэтому иммутабельность и создание новых объектов при изменениях делает CD предсказуемым.",
      "difficulty": "medium"
    },
    {
      "id": 153,
      "question": "Что такое Angular Standalone Component?",
      "options": [
        "Компонент без TypeScript",
        "Компонент, который может существовать без объявления в NgModule и сам описывает свои imports",
        "Компонент только для тестов",
        "Компонент только для SSR"
      ],
      "correct": 1,
      "explanation": "Standalone компонент объявляется с флагом standalone: true и сам импортирует необходимые модули/директивы/пайпы.",
      "difficulty": "medium"
    },
    {
      "id": 154,
      "question": "Как запустить Angular приложение, основанное на Standalone компоненте?",
      "options": [
        "Через platformBrowserDynamic().bootstrapModule(AppModule)",
        "Через bootstrapApplication(AppComponent) в main.ts",
        "Через ngServer(AppComponent)",
        "Через Renderer2.bootstrap(AppComponent)"
      ],
      "correct": 1,
      "explanation": "bootstrapApplication принимает Standalone корневой компонент и опции для настройки провайдеров и платформы.",
      "difficulty": "medium"
    },
    {
      "id": 155,
      "question": "Что такое route guard в Angular Router?",
      "options": [
        "Компонент для отображения 404",
        "Сервис/функция, которая решает, можно ли активировать/деактивировать маршрут или загрузить модуль",
        "Способ регистрации модулей",
        "Инструмент для стилизации ссылок"
      ],
      "correct": 1,
      "explanation": "Route guard реализует один из интерфейсов (CanActivate, CanDeactivate, CanLoad и др.) и управляет доступом к маршруту.",
      "difficulty": "medium"
    },
    {
      "id": 156,
      "question": "Для чего используется CanDeactivate guard?",
      "options": [
        "Для ленивой загрузки модулей",
        "Для запрета/разрешения ухода со страницы, обычно при незаписанных данных формы",
        "Для предзагрузки данных",
        "Только для авторизации"
      ],
      "correct": 1,
      "explanation": "CanDeactivate позволяет проверить состояние компонента (например, грязная форма) и запросить подтверждение выхода.",
      "difficulty": "medium"
    },
    {
      "id": 157,
      "question": "Как реализовать ленивую загрузку модуля в маршрутах (classic NgModule подход)?",
      "options": [
        "loadChildren: () => import('...').then(m => m.ModuleName)",
        "component: LazyComponent",
        "redirectTo: 'lazy'",
        "useFactory: () => ModuleName"
      ],
      "correct": 0,
      "explanation": "loadChildren с динамическим import позволяет webpack/Angular разделить код и загрузить модуль по требованию.",
      "difficulty": "medium"
    },
    {
      "id": 158,
      "question": "Какой оператор RxJS лучше подойдёт для автокомплита с отменой предыдущих запросов?",
      "options": [
        "mergeMap",
        "concatMap",
        "switchMap",
        "exhaustMap"
      ],
      "correct": 2,
      "explanation": "switchMap отменяет предыдущий HTTP-запрос при вводе нового значения и использует только последний результат.",
      "difficulty": "medium"
    },
    {
      "id": 159,
      "question": "Какой оператор RxJS подходит для обработки клика по кнопке отправки формы, чтобы игнорировать повторные клики до завершения запроса?",
      "options": [
        "switchMap",
        "exhaustMap",
        "mergeMap",
        "scan"
      ],
      "correct": 1,
      "explanation": "exhaustMap игнорирует новые эмиссии (клики), пока текущий запрос не завершён, предотвращая дублирующие запросы.",
      "difficulty": "hard"
    },
    {
      "id": 160,
      "question": "Какая функция Angular Signals используется для создания сигнала?",
      "options": [
        "computed()",
        "signal()",
        "effect()",
        "inject()"
      ],
      "correct": 1,
      "explanation": "signal(initialValue) создаёт реактивное значение с get/set API и возможностью подписки через эффекты.",
      "difficulty": "medium"
    },
    {
      "id": 161,
      "question": "Для чего используется computed() в Angular Signals?",
      "options": [
        "Для создания событий DOM",
        "Для объявления производного сигнала, зависящего от других сигналов",
        "Для выполнения HTTP-запросов",
        "Для логирования состояния"
      ],
      "correct": 1,
      "explanation": "computed создаёт сигнал, значение которого вычисляется на основе других сигналов и кэшируется до изменения зависимостей.",
      "difficulty": "hard"
    },
    {
      "id": 162,
      "question": "Какой API Signals используют для выполнения сайд-эффектов при изменении сигналов?",
      "options": [
        "effect()",
        "runOutsideAngular()",
        "markForCheck()",
        "takeUntil()"
      ],
      "correct": 0,
      "explanation": "effect() регистрирует функцию, которая автоматически вызывается при изменении зависимых сигналов.",
      "difficulty": "hard"
    },
    {
      "id": 163,
      "question": "Какой способ передачи данных между неродственными компонентами наиболее рекомендуем в Angular?",
      "options": [
        "Через глобальные переменные window",
        "Через общие сервисы с Observables/Signals",
        "Через прямой доступ к DOM",
        "Через console.log"
      ],
      "correct": 1,
      "explanation": "Общий сервис, предоставляющий Observables/Signals, позволяет разделять состояние и общаться между компонентами без тесной связности.",
      "difficulty": "medium"
    },
    {
      "id": 164,
      "question": "Как в Angular Router определить маршрут по умолчанию?",
      "options": [
        "path: '*'",
        "path: '', redirectTo: 'home', pathMatch: 'full'",
        "path: '/', component: HomeComponent",
        "path: 'default', outlet: 'primary'"
      ],
      "correct": 1,
      "explanation": "Пустой путь с redirectTo и pathMatch: 'full' перенаправляет корневой URL на нужный маршрут.",
      "difficulty": "easy"
    },
    {
      "id": 165,
      "question": "Как объявить маршруты для дочернего модуля с RouterModule?",
      "options": [
        "RouterModule.forRoot(routes)",
        "RouterModule.forChild(routes)",
        "RouterModule.define(routes)",
        "RouterModule.lazy(routes)"
      ],
      "correct": 1,
      "explanation": "forChild используется во feature-модулях для регистрации дополнительных маршрутов поверх корневой конфигурации.",
      "difficulty": "medium"
    },
    {
      "id": 166,
      "question": "Как реализовать страницу 404 в Angular Router?",
      "options": [
        "Добавить маршрут с path: '*'",
        "Добавить маршрут с path: '**' в конце конфигурации",
        "Переопределить стандартный Router",
        "Использовать только CanActivate"
      ],
      "correct": 1,
      "explanation": "Маршрут с path: '**' ловит все неразрешённые URL и обычно отображает компонент 404.",
      "difficulty": "easy"
    },
    {
      "id": 167,
      "question": "Зачем использовать PreloadingStrategy в Angular Router?",
      "options": [
        "Для логирования переходов",
        "Для предзагрузки ленивых модулей по настраиваемым правилам",
        "Для изменения URL",
        "Для кеширования Observable"
      ],
      "correct": 1,
      "explanation": "PreloadingStrategy управляет тем, какие lazy-модули загружать заранее после первичной загрузки приложения.",
      "difficulty": "hard"
    },
    {
      "id": 168,
      "question": "Какой модуль Angular используют для анимаций?",
      "options": [
        "BrowserModule",
        "BrowserAnimationsModule",
        "FormsModule",
        "HttpClientModule"
      ],
      "correct": 1,
      "explanation": "BrowserAnimationsModule включает поддержку анимаций через Angular Animation API и интеграцию с CSS.",
      "difficulty": "easy"
    },
    {
      "id": 169,
      "question": "Что такое ViewEncapsulation в Angular?",
      "options": [
        "Механизм SSR",
        "Механизм инкапсуляции стилей компонента (Emulated, None, ShadowDom)",
        "Механизм DI",
        "Механизм маршрутизации"
      ],
      "correct": 1,
      "explanation": "ViewEncapsulation определяет, как стили компонента применяются к DOM: эмулированная инкапсуляция, глобально или через Shadow DOM.",
      "difficulty": "medium"
    },
    {
      "id": 170,
      "question": "Какая стратегия ViewEncapsulation включена по умолчанию в большинстве проектов?",
      "options": [
        "None",
        "Emulated",
        "ShadowDom",
        "Scoped"
      ],
      "correct": 1,
      "explanation": "Emulated эмулирует инкапсуляцию через генерацию уникальных атрибутов и ограничение действия стилей компонентом.",
      "difficulty": "medium"
    },
    {
      "id": 171,
      "question": "Когда имеет смысл использовать ViewEncapsulation.None?",
      "options": [
        "Когда нужно максимальное изолирование стилей",
        "Когда требуется намеренно распространять стили компонента глобально (например, дизайн-система)",
        "Когда используется SSR",
        "Когда включён OnPush"
      ],
      "correct": 1,
      "explanation": "ViewEncapsulation.None делает стили глобальными, что удобно для общих тем и библиотек компонентов, но требует дисциплины.",
      "difficulty": "hard"
    },
    {
      "id": 172,
      "question": "Как объявить HTTP интерцептор в Angular (classic provider)?",
      "options": [
        "В массиве declarations",
        "В массиве providers с provide: HTTP_INTERCEPTORS, useClass: ..., multi: true",
        "В массиве imports",
        "В массиве bootstrap"
      ],
      "correct": 1,
      "explanation": "HTTP_INTERCEPTORS — мульти-токен, поэтому интерцепторы регистрируются через multi: true в providers.",
      "difficulty": "hard"
    },
    {
      "id": 173,
      "question": "Что делает метод HttpClient.get<T>()?",
      "options": [
        "Отправляет POST-запрос",
        "Отправляет GET-запрос и типизирует тело ответа как T",
        "Отправляет DELETE-запрос",
        "Отправляет PUT-запрос"
      ],
      "correct": 1,
      "explanation": "HttpClient.get<T>() возвращает Observable<T>, где T описывает структуру ожидаемого JSON-ответа.",
      "difficulty": "easy"
    },
    {
      "id": 174,
      "question": "Как в HttpClient задать параметры запроса?",
      "options": [
        "Через заголовок 'Params'",
        "Через объект HttpParams в options: { params }",
        "Через тело запроса",
        "Через cookie"
      ],
      "correct": 1,
      "explanation": "HttpParams позволяет декларативно добавлять query-параметры: new HttpParams().set('q','term').",
      "difficulty": "medium"
    },
    {
      "id": 175,
      "question": "Для чего использовать HttpClientTestingModule в тестах?",
      "options": [
        "Для запуска e2e тестов",
        "Для мокирования HttpClient без реальных HTTP-запросов",
        "Для измерения производительности",
        "Для подключения роутера"
      ],
      "correct": 1,
      "explanation": "HttpClientTestingModule предоставляет HttpTestingController, позволяющий перехватывать запросы и возвращать тестовые ответы.",
      "difficulty": "hard"
    },
    {
      "id": 176,
      "question": "Какой интерфейс реализует класс компонента, если он должен очищать ресурсы при уничтожении?",
      "options": [
        "OnInit",
        "OnDestroy",
        "DoCheck",
        "AfterViewInit"
      ],
      "correct": 1,
      "explanation": "Реализация OnDestroy и метода ngOnDestroy позволяет освободить ресурсы (подписки, таймеры).",
      "difficulty": "easy"
    },
    {
      "id": 177,
      "question": "Для чего используется интерфейс OnChanges?",
      "options": [
        "Для обработки событий DOM",
        "Для реакции на изменения входных свойств @Input",
        "Для инициализации компонента",
        "Для уничтожения сервиса"
      ],
      "correct": 1,
      "explanation": "OnChanges даёт доступ к SimpleChanges при каждом обновлении @Input значений родителем.",
      "difficulty": "medium"
    },
    {
      "id": 178,
      "question": "Как проверить производительность Change Detection в реальном приложении?",
      "options": [
        "Только через unit-тесты",
        "Через Angular DevTools и Performance профайлер браузера",
        "Через console.log в каждом компоненте",
        "Через отключение HTTP"
      ],
      "correct": 1,
      "explanation": "Angular DevTools показывает количество CD-циклов и позволяет измерять влияние изменений на производительность.",
      "difficulty": "medium"
    },
    {
      "id": 179,
      "question": "Что такое AOT компиляция в Angular?",
      "options": [
        "Компиляция шаблонов на стороне сервера во время запроса",
        "Компиляция шаблонов и метаданных на этапе сборки, до запуска в браузере",
        "Компиляция CSS в рантайме",
        "Компиляция RxJS операторов"
      ],
      "correct": 1,
      "explanation": "AoT переносит парсинг и проверку шаблонов на build time, сокращая время старта и улучшая диагностику.",
      "difficulty": "medium"
    },
    {
      "id": 180,
      "question": "Какие преимущества даёт использование Angular CLI?",
      "options": [
        "Только создание HTML-файлов",
        "Стандартизированная структура проекта, генерация кода, оптимизированная сборка и команды для тестов/линтинга",
        "Только деплой на сервер",
        "Только создание CSS файлов"
      ],
      "correct": 1,
      "explanation": "CLI автоматизирует рутинные задачи, минимизирует ручную настройку и помогает соблюдать best practices структуры.",
      "difficulty": "easy"
    },
    {
      "id": 181,
      "question": "Какой командой Angular CLI создаёт новый компонент?",
      "options": [
        "ng make component my",
        "ng generate component my",
        "ng new component my",
        "ng add component my"
      ],
      "correct": 1,
      "explanation": "ng g c my-component (generate component) создаёт файлы компонента и регистрирует его в модуле.",
      "difficulty": "easy"
    },
    {
      "id": 182,
      "question": "Какой командой запустить dev-сервер Angular приложения по умолчанию?",
      "options": [
        "ng build",
        "ng serve",
        "ng test",
        "ng lint"
      ],
      "correct": 1,
      "explanation": "ng serve компилирует приложение в dev-режиме, запускает dev-server и следит за изменениями файлов.",
      "difficulty": "easy"
    },
    {
      "id": 183,
      "question": "Какой командой создать продакшен сборку приложения?",
      "options": [
        "ng build --prod",
        "ng serve --prod",
        "ng test --prod",
        "ng start --prod"
      ],
      "correct": 0,
      "explanation": "ng build --configuration production (или --prod) включает оптимизации: минификацию, tree-shaking, AOT и др.",
      "difficulty": "easy"
    },
    {
      "id": 184,
      "question": "Что такое environment файлы в Angular?",
      "options": [
        "Файлы с переводами",
        "Файлы с конфигурацией приложения для разных окружений (dev, prod)",
        "Файлы с CSS переменными",
        "Файлы с SQL запросами"
      ],
      "correct": 1,
      "explanation": "environment.ts и environment.prod.ts содержат значения конфигурации, которые подменяются при сборке нужным конфигом.",
      "difficulty": "medium"
    },
    {
      "id": 185,
      "question": "Зачем нужен Service Worker в Angular PWA?",
      "options": [
        "Для управления DI",
        "Для кеширования ресурсов, работы оффлайн и получения push-уведомлений",
        "Для маршрутизации",
        "Для SSR"
      ],
      "correct": 1,
      "explanation": "Service Worker перехватывает сетевые запросы, кэширует ресурсы и обеспечивает оффлайн-режим и другие PWA возможности.",
      "difficulty": "hard"
    },
    {
      "id": 186,
      "question": "Как подключить Angular Service Worker в проект?",
      "options": [
        "Установить пакет и вручную написать sw.js",
        "Использовать ng add @angular/pwa, который настраивает Service Worker и манифест",
        "Добавить script в index.html",
        "Включить флаг в tsconfig.json"
      ],
      "correct": 1,
      "explanation": "ng add @angular/pwa конфигурирует Angular Service Worker, добавляет manifest.webmanifest и необходимые настройки.",
      "difficulty": "hard"
    },
    {
      "id": 187,
      "question": "Что такое Content Projection и зачем она нужна?",
      "options": [
        "Механизм DI",
        "Механизм вставки произвольного внешнего контента в шаблон компонента через <ng-content>",
        "Механизм ленивой загрузки модулей",
        "Механизм SSR"
      ],
      "correct": 1,
      "explanation": "Content Projection позволяет создавать оборачивающие компоненты (layout, card), в которые потребитель вставляет собственный контент.",
      "difficulty": "medium"
    },
    {
      "id": 188,
      "question": "Как реализовать несколько слотов Content Projection?",
      "options": [
        "Через несколько @Input",
        "Через несколько <ng-content select=\"...\"> с разными CSS-селекторами",
        "Через @ViewChild",
        "Через несколько RouterOutlet"
      ],
      "correct": 1,
      "explanation": "select в <ng-content> позволяет распределять разные части переданного шаблона по слотам компонента.",
      "difficulty": "hard"
    },
    {
      "id": 189,
      "question": "Что такое Angular CDK?",
      "options": [
        "Набор UI-компонентов с темами",
        "Набор низкоуровневых инструментов (overlay, portal, a11y, drag-drop) для построения UI-компонентов",
        "Только система сетки",
        "Только система темизации"
      ],
      "correct": 1,
      "explanation": "Angular CDK предоставляет инфраструктуру и примитивы, поверх которых можно строить собственные библиотеки компонентов.",
      "difficulty": "medium"
    },
    {
      "id": 190,
      "question": "Какой модуль CDK отвечает за работу с оверлеями (popover, диалоги)?",
      "options": [
        "CdkPortalModule",
        "OverlayModule",
        "A11yModule",
        "ScrollingModule"
      ],
      "correct": 1,
      "explanation": "OverlayModule позволяет создавать плавающие панели поверх контента с гибким позиционированием.",
      "difficulty": "hard"
    },
    {
      "id": 191,
      "question": "Какие практики помогают поддерживать масштабируемую архитектуру Angular-приложения?",
      "options": [
        "Все компоненты в одном модуле",
        "Feature-модули, разделение по доменам, использование фасадов, строгие границы между слоями",
        "Глобальный state без модулей",
        "Максимальное использование any"
      ],
      "correct": 1,
      "explanation": "Разбиение по доменным feature-модулям, использование фасадов и чётких контрактов снижает связность и упрощает развитие.",
      "difficulty": "hard"
    },
    {
      "id": 192,
      "question": "Для чего использовать фасадный сервис (Facade) поверх NgRx Store?",
      "options": [
        "Чтобы напрямую мутировать state",
        "Чтобы инкапсулировать детали Store и упростить подписки/диспетчинг для компонентов",
        "Чтобы заменить Router",
        "Чтобы генерировать HTML"
      ],
      "correct": 1,
      "explanation": "Фасад скрывает от компонентов детали реализации Store, упрощает тестирование и повышает устойчивость к изменениям.",
      "difficulty": "hard"
    },
    {
      "id": 193,
      "question": "Какой оператор RxJS помогает строить сложные потоки без вложенных subscribe?",
      "options": [
        "switchMap/mergeMap/concatMap/exhaustMap",
        "forEach",
        "toPromise",
        "interval"
      ],
      "correct": 0,
      "explanation": "Операторы higher-order mapping позволяют плоско комбинировать потоки, избегая callback hell и nested subscribe.",
      "difficulty": "medium"
    },
    {
      "id": 194,
      "question": "Какие преимущества даёт использование Typed Forms (strictTemplates + типизированные формы) в Angular?",
      "options": [
        "Ускорение runtime",
        "Проверка типов контролов и значений формы на этапе компиляции, снижение ошибок",
        "Отключение шаблонов",
        "Повышение размера бандла"
      ],
      "correct": 1,
      "explanation": "Typed Forms позволяют IDE и компилятору подсказывать ключи и типы значений, уменьшая вероятность ошибок.",
      "difficulty": "hard"
    },
    {
      "id": 195,
      "question": "Когда имеет смысл использовать ControlValueAccessor?",
      "options": [
        "Только для встроенных input",
        "При создании кастомного элемента формы, который должен интегрироваться с Angular Forms API",
        "Только при использовании NgRx",
        "Только при SSR"
      ],
      "correct": 1,
      "explanation": "ControlValueAccessor позволяет Angular относиться к вашему компоненту как к стандартному form control, поддерживая ngModel/Reactive Forms.",
      "difficulty": "hard"
    },
    {
      "id": 196,
      "question": "Для чего использовать FormArray в реактивных формах?",
      "options": [
        "Для хранения только одного FormControl",
        "Для динамических списков однотипных контролов (например, массив телефонов)",
        "Только для вложенных FormGroup",
        "Для конфигурации роутера"
      ],
      "correct": 1,
      "explanation": "FormArray позволяет управлять коллекцией контролов, добавлять/удалять их динамически.",
      "difficulty": "medium"
    },
    {
      "id": 197,
      "question": "Как правильно показать ошибку валидации для FormControl в шаблоне?",
      "options": [
        "Проверять только pristine",
        "Проверять control.invalid && (control.dirty || control.touched)",
        "Проверять только touched",
        "Проверять только status === 'PENDING'"
      ],
      "correct": 1,
      "explanation": "Комбинация invalid и dirty/touched позволяет не показывать ошибки до первого взаимодействия пользователя с контролом.",
      "difficulty": "medium"
    },
    {
      "id": 198,
      "question": "Какой оператор RxJS используют для ограничения частоты событий (например, scroll)?",
      "options": [
        "debounceTime",
        "throttleTime",
        "retry",
        "scan"
      ],
      "correct": 1,
      "explanation": "throttleTime пропускает первое значение и затем игнорирует последующие до истечения заданного интервала.",
      "difficulty": "medium"
    },
    {
      "id": 199,
      "question": "Как защититься от XSS при вставке HTML в шаблон Angular?",
      "options": [
        "Использовать innerHTML без ограничений",
        "Использовать встроенную санитизацию Angular и DomSanitizer только для доверенного контента",
        "Всегда использовать bypassSecurityTrustHtml без проверки",
        "Отключить Angular sanitizer"
      ],
      "correct": 1,
      "explanation": "Angular по умолчанию санитизирует опасные привязки, а DomSanitizer следует применять только к проверенному контенту.",
      "difficulty": "hard"
    },
    {
      "id": 200,
      "question": "Почему важно не держать долгоживущие подписки на уровне Singleton-сервисов без отписки?",
      "options": [
        "Это ускоряет GC",
        "Это приводит к утечкам памяти и может удерживать ссылки на компоненты дольше, чем нужно",
        "Это отключает SSR",
        "Это ломает роутер"
      ],
      "correct": 1,
      "explanation": "Даже в сервисах важно управлять подписками (takeUntil, shareReplay, completed потоки), иначе возможны утечки и неожиданные сайд-эффекты.",
      "difficulty": "hard"
    },
    {
      "id": 201,
      "question": "Что такое Angular Material?",
      "options": [
        "CSS-фреймворк без компонентов",
        "Набор готовых UI-компонентов, реализующих Material Design и основанных на Angular",
        "Только система сетки",
        "Только набор иконок"
      ],
      "correct": 1,
      "explanation": "Angular Material предоставляет готовые компоненты (button, dialog, table, form-field и др.) с поддержкой темизации и a11y.",
      "difficulty": "easy"
    },
    {
      "id": 202,
      "question": "Как включить модуль кнопок Angular Material в Standalone компоненте?",
      "options": [
        "Через @NgModule.declarations",
        "Импортировать MatButtonModule в массив imports декоратора @Component",
        "Добавить скрипт в index.html",
        "Использовать только CSS-классы"
      ],
      "correct": 1,
      "explanation": "В Standalone компоненте библиотеки подключаются через поле imports в @Component, аналогично imports NgModule.",
      "difficulty": "easy"
    },
    {
      "id": 203,
      "question": "Зачем использовать Angular Flex-Layout или CSS Grid вместе с Angular?",
      "options": [
        "Для управления DI",
        "Для построения адаптивных layout'ов без жёсткой верстки в пикселях",
        "Для управления RxJS",
        "Для подключения Service Worker"
      ],
      "correct": 1,
      "explanation": "Flexbox и CSS Grid упрощают создание адаптивных интерфейсов, а Angular связывает состояние с представлением.",
      "difficulty": "easy"
    },
    {
      "id": 204,
      "question": "Что такое a11y и почему оно важно в Angular-приложении?",
      "options": [
        "Оптимизация CSS",
        "Доступность (accessibility): поддержка screen reader'ов, клавиатурной навигации и семантики",
        "Сокращение размера бандла",
        "Ускорение сборки"
      ],
      "correct": 1,
      "explanation": "A11y обеспечивает доступность интерфейса для людей с ограничениями, а Angular Material/CDK имеют встроенную поддержку a11y.",
      "difficulty": "medium"
    },
    {
      "id": 205,
      "question": "Как обеспечить клавиатурную навигацию в кастомном компоненте списка?",
      "options": [
        "Игнорировать фокус",
        "Использовать tabindex, ARIA-атрибуты и обработчики keydown/keyup",
        "Использовать только mouseover",
        "Запретить фокусировку элементов"
      ],
      "correct": 1,
      "explanation": "Правильная работа с tabindex, ARIA-ролями и событиями клавиатуры делает компонент доступным для клавиатурной навигации.",
      "difficulty": "medium"
    },
    {
      "id": 206,
      "question": "Что такое lazy loading компонентов через Router в Angular?",
      "options": [
        "Загрузка компонентов через script в index.html",
        "Загрузка модулей/компонентов только при переходе на соответствующий маршрут",
        "Загрузка только CSS",
        "Всегда загружать всё при старте"
      ],
      "correct": 1,
      "explanation": "Lazy loading уменьшает initial bundle и загружает код конкретного маршрута только при первой навигации на него.",
      "difficulty": "medium"
    },
    {
      "id": 207,
      "question": "Что такое оптимистичное обновление (Optimistic UI) при работе с REST API?",
      "options": [
        "Сначала ждать ответ сервера, потом менять UI",
        "Сначала обновлять UI локально, считать операцию успешной и при ошибке откатывать изменения",
        "Дублировать запросы",
        "Игнорировать ошибки сервера"
      ],
      "correct": 1,
      "explanation": "Optimistic UI повышает отзывчивость интерфейса, но требует аккуратной обработки ошибок и возможного rollback.",
      "difficulty": "hard"
    },
    {
      "id": 208,
      "question": "Как с помощью RxJS реализовать отмену HTTP-запроса при уничтожении компонента?",
      "options": [
        "Не отписываться, браузер сам отменит",
        "Использовать takeUntil(destroy$) и next/complete destroy$ в ngOnDestroy",
        "Использовать только map",
        "Использовать retry"
      ],
      "correct": 1,
      "explanation": "takeUntil на управляющем Subject позволяет автоматически отписаться от всех потоков при уничтожении компонента.",
      "difficulty": "medium"
    },
    {
      "id": 209,
      "question": "В чём разница между tap и finalize в RxJS при управлении индикатором загрузки?",
      "options": [
        "tap вызывается только при ошибке, finalize — при next",
        "tap вызывается на события next/error/complete, finalize — один раз при завершении/отписке",
        "Разницы нет",
        "finalize меняет значения потока"
      ],
      "correct": 1,
      "explanation": "tap можно использовать для включения индикатора, а finalize — для гарантированного выключения, независимо от результата.",
      "difficulty": "hard"
    },
    {
      "id": 210,
      "question": "Какой RxJS оператор лучше использовать для простого последовательного выполнения серии HTTP-запросов, зависящих от предыдущего результата?",
      "options": [
        "mergeMap",
        "concatMap",
        "switchMap",
        "shareReplay"
      ],
      "correct": 1,
      "explanation": "concatMap гарантирует, что каждый новый запрос будет выполнен только после завершения предыдущего и сохранит порядок.",
      "difficulty": "hard"
    },
    {
      "id": 211,
      "question": "Что такое SSR (Server-Side Rendering) в Angular?",
      "options": [
        "Рендеринг компонентов только на клиенте",
        "Предварительный рендеринг HTML на сервере перед отправкой в браузер",
        "Только рендеринг CSS",
        "Рендеринг только ошибок"
      ],
      "correct": 1,
      "explanation": "SSR с Angular Universal повышает SEO и уменьшает время до первого meaningful paint, рендеря HTML на сервере.",
      "difficulty": "medium"
    },
    {
      "id": 212,
      "question": "Что такое hydration в Angular SSR?",
      "options": [
        "Удаление серверного HTML",
        "Привязка клиентского приложения к уже сгенерированному сервером HTML без полной перерисовки",
        "Повторный SSR на клиенте",
        "Оптимизация CSS"
      ],
      "correct": 1,
      "explanation": "Hydration позволяет переиспользовать уже отрендеренный HTML и лишь навесить обработчики событий и состояние.",
      "difficulty": "hard"
    },
    {
      "id": 213,
      "question": "Как передать данные из route resolver в компонент?",
      "options": [
        "Через глобальную переменную",
        "Через ActivatedRoute.data и async pipe или подписку",
        "Через window.location",
        "Через environment"
      ],
      "correct": 1,
      "explanation": "Resolve guard записывает данные в data активированного маршрута, доступные через ActivatedRoute.data.",
      "difficulty": "medium"
    },
    {
      "id": 214,
      "question": "Зачем использовать параметр runGuardsAndResolvers в конфигурации маршрутов?",
      "options": [
        "Чтобы отключить Router",
        "Чтобы управлять повторным запуском guard'ов и resolvers при изменении параметров/запросов",
        "Чтобы ускорить сборку",
        "Чтобы включить SSR"
      ],
      "correct": 1,
      "explanation": "runGuardsAndResolvers задаёт, при каких изменениях URL (params, queryParams) повторно запускать guard'ы и resolvers.",
      "difficulty": "hard"
    },
    {
      "id": 215,
      "question": "Как в Angular Router получить доступ к параметру маршрута id?",
      "options": [
        "Через window.location.search",
        "Через this.route.paramMap или snapshot.paramMap.get('id')",
        "Через environment.id",
        "Через localStorage"
      ],
      "correct": 1,
      "explanation": "ActivatedRoute.paramMap позволяет реактивно считывать параметры, snapshot.paramMap — однократно.",
      "difficulty": "easy"
    },
    {
      "id": 216,
      "question": "Что такое Query Params в Angular Router?",
      "options": [
        "Часть пути после '#'",
        "Параметры после '?', используемые для фильтрации, сортировки и других опций",
        "Только параметры маршрута",
        "Только фрагменты URL"
      ],
      "correct": 1,
      "explanation": "Query params (например ?page=2) хранят опциональные параметры, не влияя на сам маршрут.",
      "difficulty": "easy"
    },
    {
      "id": 217,
      "question": "Как из компонента программно перейти на другой маршрут?",
      "options": [
        "Через window.location.href",
        "Через Router.navigate(['path']) или navigateByUrl('/path')",
        "Только через <a routerLink>",
        "Через изменение environment"
      ],
      "correct": 1,
      "explanation": "Сервис Router предоставляет методы navigate/navigateByUrl для программной навигации с поддержкой истории и guard'ов.",
      "difficulty": "easy"
    },
    {
      "id": 218,
      "question": "Что такое pure function reducer в NgRx?",
      "options": [
        "Функция, которая мутирует state",
        "Функция, которая принимает текущий state и action и возвращает новый state без побочных эффектов",
        "Функция, которая делает HTTP-запрос",
        "Функция, которая логирует ошибки"
      ],
      "correct": 1,
      "explanation": "Reducer должен быть чистой функцией: без сайд-эффектов, без мутации аргументов, определённый и тестируемый.",
      "difficulty": "medium"
    },
    {
      "id": 219,
      "question": "Какой паттерн обычно используют в NgRx для организации кода?",
      "options": [
        "MVC",
        "Actions + Reducers + Selectors + Effects",
        "Singleton",
        "Repository"
      ],
      "correct": 1,
      "explanation": "NgRx реализует Redux-подобный подход: действия описывают события, reducers — обновления, selectors — чтение, effects — сайд-эффекты.",
      "difficulty": "medium"
    },
    {
      "id": 220,
      "question": "Какой оператор RxJS часто используют внутри NgRx Effect для вызова HTTP и диспетча нового действия?",
      "options": [
        "switchMap",
        "take",
        "bufferTime",
        "repeat"
      ],
      "correct": 0,
      "explanation": "switchMap позволяет переключиться с потока actions на поток HTTP-ответов, отменяя предыдущие запросы при новых действиях.",
      "difficulty": "hard"
    },
    {
      "id": 221,
      "question": "Зачем использовать селекторы в NgRx вместо прямого чтения state?",
      "options": [
        "Чтобы увеличивать связность",
        "Чтобы инкапсулировать структуру state, мемоизировать выборки и переиспользовать логику",
        "Чтобы отключить DI",
        "Чтобы уменьшить размер бандла"
      ],
      "correct": 1,
      "explanation": "Селекторы скрывают структуру store, упрощают рефакторинг и уменьшают количество вычислений через мемоизацию.",
      "difficulty": "hard"
    },
    {
      "id": 222,
      "question": "Как избежать \"prop drilling\" (прокидывания большого количества @Input/@Output через цепочку компонентов)?",
      "options": [
        "Использовать глобальные переменные",
        "Использовать общий сервис/Store/Facade для состояния и событий",
        "Дублировать состояние в каждом компоненте",
        "Использовать только Output"
      ],
      "correct": 1,
      "explanation": "Общий слой состояния (сервис или Store) уменьшает необходимость многократно прокидывать пропсы через промежуточные компоненты.",
      "difficulty": "medium"
    },
    {
      "id": 223,
      "question": "Какой подход к структурированию Angular монорепо улучшает переиспользование и изоляцию?",
      "options": [
        "Всё в одном проекте без библиотек",
        "Использование Nx или Angular CLI workspaces с разделением на приложения и библиотеки",
        "Копирование кода между проектами",
        "Использование только одного модуля"
      ],
      "correct": 1,
      "explanation": "Monorepo c workspace и библиотеками (libs) позволяет переиспользовать код и лучше контролировать зависимости между доменами.",
      "difficulty": "hard"
    },
    {
      "id": 224,
      "question": "Что такое schematics в Angular CLI?",
      "options": [
        "Тестовый раннер",
        "Система шаблонов и трансформаций кода для генерации и модификации файлов",
        "Система логирования",
        "Система SSR"
      ],
      "correct": 1,
      "explanation": "Schematics описывают, как создавать/обновлять файлы проекта (генерация компонентов, миграции).",
      "difficulty": "hard"
    },
    {
      "id": 225,
      "question": "Для чего нужен оператор scan в RxJS?",
      "options": [
        "Для фильтрации значений",
        "Для аккумуляции значений потока во время выполнения (аналог reduce, но с промежуточными эмиссиями)",
        "Для повторной подписки",
        "Для логирования"
      ],
      "correct": 1,
      "explanation": "scan(acc, value) обновляет аккумулятор на каждом значении и эмитит промежуточный результат, удобно для локального state.",
      "difficulty": "hard"
    },
    {
      "id": 226,
      "question": "Когда стоит использовать defer блок (@defer) в Angular 17+?",
      "options": [
        "Всегда для любого контента",
        "Для отложенного рендера тяжёлых или второстепенных частей UI (например, графики, большие списки)",
        "Только для форм",
        "Только для RouterOutlet"
      ],
      "correct": 1,
      "explanation": "@defer позволяет перенести рендер не критичного для первого экрана UI на более поздний момент (idle, видимость, взаимодействие).",
      "difficulty": "hard"
    },
    {
      "id": 227,
      "question": "Что делает @placeholder внутри @defer блока?",
      "options": [
        "Отображает fallback UI после загрузки",
        "Отображает временный контент, пока отложенная часть ещё не отрендерена",
        "Отображает ошибку",
        "Подключает SSR"
      ],
      "correct": 1,
      "explanation": "@placeholder позволяет показать skeleton/loading контент до того, как основная часть UI в @defer будет загружена и отрисована.",
      "difficulty": "hard"
    },
    {
      "id": 228,
      "question": "Зачем использовать ESLint и форматтер (Prettier) в Angular проекте?",
      "options": [
        "Только для продакшена",
        "Для единообразного стиля кода, раннего выявления ошибок и автоматической правки простых проблем",
        "Чтобы увеличить размер бандла",
        "Чтобы отключить TypeScript"
      ],
      "correct": 1,
      "explanation": "Линтер и форматтер обеспечивают качество и единообразие кода, упрощают code review и уменьшают количество багов.",
      "difficulty": "easy"
    },
    {
      "id": 229,
      "question": "Какие преимущества даёт строгий режим TypeScript и Angular (strictTemplates, strict DI)?",
      "options": [
        "Уменьшение времени компиляции",
        "Раннее обнаружение ошибок типов в шаблонах и коде, улучшение автодополнения и рефакторинга",
        "Отсутствие необходимости тестов",
        "Увеличение размера бандла"
      ],
      "correct": 1,
      "explanation": "Строгий режим усиливает контракт между шаблоном и кодом, снижая риск runtime ошибок и улучшая DX.",
      "difficulty": "medium"
    },
    {
      "id": 230,
      "question": "Когда стоит вынести логику из компонента в сервис?",
      "options": [
        "Когда логика связана только с шаблоном",
        "Когда логика переиспользуется, сложна, не относится напрямую к отображению или нужна в нескольких компонентах",
        "Когда компонент маленький",
        "Когда нужен CSS"
      ],
      "correct": 1,
      "explanation": "Сервисы позволяют разделять ответственность, переиспользовать бизнес-логику и упрощать тестирование компонентов.",
      "difficulty": "medium"
    },
    {
      "id": 231,
      "question": "Какой подход к организации стилей компонента облегчает поддержку крупного проекта?",
      "options": [
        "Глобальный CSS без инкапсуляции",
        "Инкапсулированные стили компонентов, дизайн-система и токены (CSS-переменные, theme)",
        "Инлайновые стили только в шаблоне",
        "Использование !important везде"
      ],
      "correct": 1,
      "explanation": "Комбинация локальных стилей и общей дизайн-системы с токенами упрощает масштабирование и рефакторинг UI.",
      "difficulty": "medium"
    },
    {
      "id": 232,
      "question": "Почему нежелательно использовать any в типах Observable и компонентов?",
      "options": [
        "Замедляет runtime",
        "Скрывает ошибки типов, ухудшает автодополнение и делает рефакторинг рискованным",
        "Увеличивает размер бандла",
        "Отключает RxJS"
      ],
      "correct": 1,
      "explanation": "Тип any отключает проверку типов, что нивелирует преимущества TypeScript и может скрывать реальные ошибки.",
      "difficulty": "easy"
    },
    {
      "id": 233,
      "question": "Какой подход к именованию Observable переменных считается хорошей практикой?",
      "options": [
        "users",
        "users$ (суффикс $ для Observable)",
        "observableUsers",
        "subjectUsers"
      ],
      "correct": 1,
      "explanation": "Суффикс $ явно показывает, что переменная представляет собой Observable, улучшая читаемость кода.",
      "difficulty": "easy"
    },
    {
      "id": 234,
      "question": "Почему nested subscribe считается антипаттерном в RxJS?",
      "options": [
        "Потому что не работает",
        "Усложняет управление отписками и теряет преимущества операторов композиции",
        "Ускоряет выполнение",
        "Требует больше памяти"
      ],
      "correct": 1,
      "explanation": "Вложенные подписки затрудняют контроль потока и ошибок, вместо них рекомендуется использовать операторы преобразования.",
      "difficulty": "medium"
    },
    {
      "id": 235,
      "question": "Как правильно объединять несколько HTTP-запросов, результат которых нужен одновременно (например, настройки и профиль)?",
      "options": [
        "Через merge",
        "Через forkJoin([req1, req2])",
        "Через concat",
        "Через race"
      ],
      "correct": 1,
      "explanation": "forkJoin параллельно выполняет запросы и возвращает результат только после завершения всех, что удобно для загрузки зависимых данных.",
      "difficulty": "medium"
    },
    {
      "id": 236,
      "question": "Какой оператор RxJS использовать для сочетания событий ввода и текущего состояния фильтра?",
      "options": [
        "merge",
        "withLatestFrom",
        "retryWhen",
        "materialize"
      ],
      "correct": 1,
      "explanation": "withLatestFrom позволяет объединять поток событий с последними значениями другого потока (например, настроек фильтра).",
      "difficulty": "hard"
    },
    {
      "id": 237,
      "question": "Какие практики помогают сделать Angular-компонент повторно используемым?",
      "options": [
        "Жёстко зашитые маршруты",
        "Чёткие @Input/@Output, отсутствие жёстких зависимостей от глобального состояния, конфигурация через параметры",
        "Использование window.location",
        "Сильная связность с конкретным сервисом"
      ],
      "correct": 1,
      "explanation": "Параметризация поведения и слабая связанность с внешними деталями позволяют использовать компонент в разных контекстах.",
      "difficulty": "medium"
    },
    {
      "id": 238,
      "question": "Когда стоит выносить Angular компонент в отдельную библиотеку (lib)?",
      "options": [
        "Когда он используется только в одном месте",
        "Когда он переиспользуется в нескольких приложениях или доменах и должен иметь отдельный цикл версионирования",
        "Когда он маленький",
        "Когда нужен CSS"
      ],
      "correct": 1,
      "explanation": "Выделение в библиотеку оправдано для общих компонентов/утилит, используемых разными приложениями или модулями.",
      "difficulty": "hard"
    },
    {
      "id": 239,
      "question": "Какой способ тестирования компонентов Angular позволяет проверять поведение без поднятия реального браузера?",
      "options": [
        "e2e тесты",
        "Юнит-тесты с TestBed и Karma/Jest",
        "Ручное тестирование",
        "Снапшот-тесты CSS"
      ],
      "correct": 1,
      "explanation": "TestBed позволяет создавать тестовый модуль, монтировать компонент и проверять его поведение в изолированной среде.",
      "difficulty": "medium"
    },
    {
      "id": 240,
      "question": "Как в юнит-тестах замокать зависимость компонента от сервиса?",
      "options": [
        "Использовать реальный сервис",
        "Предоставить mock через providers: [{ provide: Service, useValue: mock }]",
        "Отключить DI",
        "Использовать только HttpClientTestingModule"
      ],
      "correct": 1,
      "explanation": "В TestBed можно переопределить провайдеры, подставив моковые реализации сервисов.",
      "difficulty": "medium"
    },
    {
      "id": 241,
      "question": "Какие показатели Lighthouse особенно важны для SPA на Angular?",
      "options": [
        "Только PWA",
        "Performance, Best Practices, Accessibility, SEO",
        "Только Security",
        "Только Size"
      ],
      "correct": 1,
      "explanation": "Lighthouse помогает оценить производительность, доступность, SEO и лучшие практики для SPA-приложений.",
      "difficulty": "medium"
    },
    {
      "id": 242,
      "question": "Почему важно разбивать большие компоненты на подкомпоненты?",
      "options": [
        "Чтобы увеличить количество файлов",
        "Чтобы уменьшить связность, упростить тестирование и переиспользование частей UI",
        "Чтобы отключить SSR",
        "Чтобы ускорить сборку"
      ],
      "correct": 1,
      "explanation": "Меньшие компоненты проще понимать, тестировать и использовать повторно, а также они снижают нагрузку Change Detection.",
      "difficulty": "easy"
    },
    {
      "id": 243,
      "question": "Какой формат данных чаще всего возвращает HttpClient при работе с REST API?",
      "options": [
        "XML",
        "JSON",
        "HTML",
        "Plain text"
      ],
      "correct": 1,
      "explanation": "По умолчанию HttpClient предполагает JSON и парсит ответ, возвращая объект указанного типа.",
      "difficulty": "easy"
    },
    {
      "id": 244,
      "question": "Как минимизировать влияние большого vendor-бандла на время загрузки Angular приложения?",
      "options": [
        "Отключить production build",
        "Использовать lazy loading, dynamic import, оптимизировать зависимости и включить code-splitting",
        "Всегда загружать всё сразу",
        "Не использовать polyfills"
      ],
      "correct": 1,
      "explanation": "Разделение кода и ленивые маршруты позволяют загружать лишь необходимый функционал при старте.",
      "difficulty": "medium"
    },
    {
      "id": 245,
      "question": "Зачем использовать trackBy при рендеринге большого списка элементов?",
      "options": [
        "Чтобы добавить новые стили",
        "Чтобы Angular мог переиспользовать DOM-элементы и не пересоздавать их при каждом изменении массива",
        "Чтобы включить SSR",
        "Чтобы увеличить частоту CD"
      ],
      "correct": 1,
      "explanation": "trackBy по id снижает количество операций вставки/удаления в DOM и повышает производительность списков.",
      "difficulty": "medium"
    },
    {
      "id": 246,
      "question": "Какой подход к управлению состоянием формы упрощает валидацию и тестирование?",
      "options": [
        "Использовать только template-driven формы",
        "Использовать Reactive Forms с явной моделью FormGroup/FormControl и валидаторами",
        "Хранить значения только в DOM",
        "Использовать window.formState"
      ],
      "correct": 1,
      "explanation": "Reactive Forms дают декларативную объектную модель формы, что упрощает сложную валидацию и unit-тестирование.",
      "difficulty": "medium"
    },
    {
      "id": 247,
      "question": "Как реализовать кастомный синхронный валидатор для FormControl?",
      "options": [
        "Через pipe",
        "Функция (control: AbstractControl) => ValidationErrors | null, подключённая в validators",
        "Через HttpInterceptor",
        "Через RouterGuard"
      ],
      "correct": 1,
      "explanation": "Синхронный валидатор возвращает объект ошибок либо null и регистрируется в validators FormControl/FormGroup.",
      "difficulty": "hard"
    },
    {
      "id": 248,
      "question": "Почему важно показывать пользователю конкретные сообщения валидации формы?",
      "options": [
        "Для увеличения количества кода",
        "Для улучшения UX, понятности ошибок и уменьшения числа неверных вводов",
        "Чтобы увеличить размер бандла",
        "Чтобы отключить HTTP"
      ],
      "correct": 1,
      "explanation": "Чёткие сообщения ошибок валидации повышают вероятность успешного завершения сценария пользователем и снижают фрустрацию.",
      "difficulty": "easy"
    },
    {
      "id": 249,
      "question": "Как в Angular реализовать загрузку файла через форму?",
      "options": [
        "Использовать только JSON",
        "Использовать <input type=\"file\">, обработать событие change и отправить FormData через HttpClient",
        "Хранить файл в localStorage",
        "Отправить файл через query params"
      ],
      "correct": 1,
      "explanation": "Файл читается из input, добавляется в FormData и отправляется как multipart/form-data через HttpClient.",
      "difficulty": "medium"
    },
    {
      "id": 250,
      "question": "Что такое debounceTime при обработке события ввода поиска?",
      "options": [
        "Полное игнорирование событий",
        "Ожидание паузы в вводе перед эмиссией значения, чтобы не слать запрос на каждый символ",
        "Ускорение HTTP",
        "Отложенная отписка"
      ],
      "correct": 1,
      "explanation": "debounceTime сглаживает поток частых событий, отправляя только последнее значение после периода тишины.",
      "difficulty": "easy"
    },
    {
      "id": 251,
      "question": "Почему важно обрабатывать ошибки HTTP-запросов в Angular?",
      "options": [
        "Чтобы замедлить приложение",
        "Чтобы показывать пользователю понятные сообщения, логировать проблемы и избегать немых падений",
        "Чтобы отключить роутер",
        "Чтобы увеличить размер бандла"
      ],
      "correct": 1,
      "explanation": "Корректная обработка ошибок (catchError, глобальный ErrorHandler) повышает устойчивость приложения и UX.",
      "difficulty": "medium"
    },
    {
      "id": 252,
      "question": "Как реализовать глобальную обработку ошибок в Angular?",
      "options": [
        "Использовать try/catch в каждом компоненте",
        "Реализовать собственный ErrorHandler и зарегистрировать его в providers",
        "Использовать только console.error",
        "Отключить zone.js"
      ],
      "correct": 1,
      "explanation": "Кастомный ErrorHandler перехватывает необработанные ошибки и может отправлять их в логирование или показывать глобальные уведомления.",
      "difficulty": "hard"
    },
    {
      "id": 253,
      "question": "Зачем использовать Angular RouterLink вместо обычного href?",
      "options": [
        "Чтобы отключить SPA",
        "Чтобы навигация происходила без перезагрузки страницы, учитывая маршрутизацию и guard'ы",
        "Чтобы увеличить размер HTML",
        "Чтобы отправлять POST-запросы"
      ],
      "correct": 1,
      "explanation": "routerLink интегрирован с Router и обеспечивает SPA-навигацию, управление историей и работу guard'ов.",
      "difficulty": "easy"
    },
    {
      "id": 254,
      "question": "Какие данные стоит хранить в LocalStorage в SPA?",
      "options": [
        "Секретные токены в открытом виде",
        "Нечувствительные настройки пользователя (язык, тема) и краткоживущие токены с учётом рисков",
        "Пароли",
        "SQL-запросы"
      ],
      "correct": 1,
      "explanation": "LocalStorage уязвим для XSS, поэтому в нём лучше не хранить чувствительные данные или принимать меры по их защите.",
      "difficulty": "hard"
    },
    {
      "id": 255,
      "question": "Что такое CORS и как он влияет на Angular клиент?",
      "options": [
        "Механизм кеширования",
        "Механизм безопасности браузера, ограничивающий запросы к другим доменам без соответствующих заголовков",
        "Механизм роутинга",
        "Механизм SSR"
      ],
      "correct": 1,
      "explanation": "CORS требует, чтобы сервер явно разрешал запросы с origin клиента, иначе браузер блокирует ответ.",
      "difficulty": "medium"
    },
    {
      "id": 256,
      "question": "Как в Angular приложении улучшить UX при долгих операциях?",
      "options": [
        "Игнорировать задержки",
        "Показывать индикаторы загрузки, skeleton'ы, прогресс-бары и оптимистичные обновления",
        "Отключить CD",
        "Увеличить таймаут HTTP"
      ],
      "correct": 1,
      "explanation": "Визуальная обратная связь и skeleton UI снижают ощущение задержек и улучшают восприятие производительности.",
      "difficulty": "easy"
    },
    {
      "id": 257,
      "question": "Какой паттерн часто используют для управления модальными окнами в Angular?",
      "options": [
        "Глобальные переменные",
        "Сервис модалок (ModalService) с Subject/Signals и компонент-контейнер, слушающий изменения",
        "Несколько RouterOutlet",
        "Полное отсутствие состояния"
      ],
      "correct": 1,
      "explanation": "Сервис модалок инкапсулирует логику показа/закрытия и позволяет вызывать диалоги из разных частей приложения.",
      "difficulty": "medium"
    },
    {
      "id": 258,
      "question": "Зачем использовать trackBy c виртуальным скроллом (cdk-virtual-scroll)?",
      "options": [
        "Для SSR",
        "Для минимизации операций с DOM и плавной прокрутки больших списков",
        "Для изменения URL",
        "Для отключения RxJS"
      ],
      "correct": 1,
      "explanation": "Виртуальный скролл рендерит только видимую часть списка, а trackBy помогает корректно переиспользовать элементы.",
      "difficulty": "hard"
    },
    {
      "id": 259,
      "question": "Какие данные следует выносить в environment или конфигурацию, а не захардкоживать в коде?",
      "options": [
        "Локальные переменные функций",
        "URL API, ключи интеграций, feature-флаги и другие настройки окружения",
        "Имена локальных переменных",
        "Типы интерфейсов"
      ],
      "correct": 1,
      "explanation": "Конфигурация должна быть отделена от кода, чтобы окружения (dev/stage/prod) могли отличаться без перекомпиляции логики.",
      "difficulty": "medium"
    },
    {
      "id": 260,
      "question": "Почему важно разделять \"smart\" и \"dumb\" компоненты?",
      "options": [
        "Чтобы увеличить количество файлов",
        "Чтобы логика работы с данными была сконцентрирована в умных компонентах/фасадах, а глупые занимались только отображением",
        "Чтобы отключить DI",
        "Чтобы увеличить связность"
      ],
      "correct": 1,
      "explanation": "Разделение упрощает переиспользование и тестирование отображения отдельно от бизнес-логики.",
      "difficulty": "medium"
    },
    {
      "id": 261,
      "question": "Какой подход к подписке на Observable в компоненте минимизирует риск утечек памяти?",
      "options": [
        "subscribe везде и не отписываться",
        "Использовать async pipe в шаблоне и операторы вроде takeUntil для ручных подписок",
        "Использовать только toPromise",
        "Использовать только Subject"
      ],
      "correct": 1,
      "explanation": "async pipe автоматически управляет отпиской, а для ручных подписок нужны паттерны вроде takeUntil или Subscription.add.",
      "difficulty": "medium"
    },
    {
      "id": 262,
      "question": "Какой подход к логированию в Angular-приложении считается здоровым?",
      "options": [
        "console.log везде",
        "Централизованный LoggingService, интеграция с внешними системами и уровни логирования",
        "Полное отсутствие логов",
        "Логировать только ошибки HTTP"
      ],
      "correct": 1,
      "explanation": "Централизованный сервис логирования позволяет включать/отключать уровни логов, отправлять их на сервер и не засорять код консолью.",
      "difficulty": "hard"
    },
    {
      "id": 263,
      "question": "Зачем использовать интерцептор для добавления auth-токена к каждому запросу?",
      "options": [
        "Чтобы дублировать код",
        "Чтобы централизованно дополнять все HTTP-запросы заголовком Authorization без правки каждого сервиса",
        "Чтобы отключить CORS",
        "Чтобы ускорить SSR"
      ],
      "correct": 1,
      "explanation": "Интерцептор позволяет в одном месте управлять заголовками авторизации и обработкой 401/403 ответов.",
      "difficulty": "medium"
    },
    {
      "id": 264,
      "question": "Какой оператор RxJS можно использовать для экспоненциального backoff при повторных попытках запроса?",
      "options": [
        "retry",
        "retryWhen с delay и scan",
        "takeUntil",
        "startWith"
      ],
      "correct": 1,
      "explanation": "retryWhen в комбинации с scan и delay позволяет реализовать настраиваемую стратегию повторных попыток.",
      "difficulty": "hard"
    },
    {
      "id": 265,
      "question": "Какую роль играет Strict Mode в Angular (ng new --strict)?",
      "options": [
        "Отключает проверки",
        "Включает более строгие проверки TypeScript и template type checking",
        "Увеличивает размер бандла",
        "Замедляет HTTP"
      ],
      "correct": 1,
      "explanation": "Strict mode помогает ловить ошибки типов раньше и поощряет более безопасные паттерны разработки.",
      "difficulty": "medium"
    },
    {
      "id": 266,
      "question": "Как использовать Web Worker в Angular для тяжёлых вычислений?",
      "options": [
        "Выполнить всё в главном потоке",
        "Создать worker через ng generate web-worker и вынести CPU-интенсивную логику в отдельный поток",
        "Использовать setTimeout",
        "Использовать только RxJS"
      ],
      "correct": 1,
      "explanation": "Web Worker разгружает главный поток, сохраняя отзывчивость UI при тяжёлых вычислениях.",
      "difficulty": "hard"
    },
    {
      "id": 267,
      "question": "Почему важно учитывать z-index и слои при работе с overlay-компонентами (диалоги, поповеры)?",
      "options": [
        "Чтобы ускорить сборку",
        "Чтобы предотвратить перекрытие или скрытие контента, обеспечить корректную иерархию поверх основного UI",
        "Чтобы уменьшить размер CSS",
        "Чтобы отключить SSR"
      ],
      "correct": 1,
      "explanation": "Неправильные z-index могут приводить к тому, что диалоги не видны или перекрывают критически важный UI.",
      "difficulty": "medium"
    },
    {
      "id": 268,
      "question": "Как в Angular лучше всего реализовать глобальные уведомления (toasts/snackbars)?",
      "options": [
        "Создавать компонент вручную в каждом месте",
        "Использовать сервис уведомлений и общий контейнер-компонент, подписывающийся на поток уведомлений",
        "Использовать alert()",
        "Использовать только console.log"
      ],
      "correct": 1,
      "explanation": "Сервис уведомлений централизует логику, а контейнер отображает очередь или список уведомлений.",
      "difficulty": "medium"
    },
    {
      "id": 269,
      "question": "Какие ключевые метрики фронтенд-производительности стоит отслеживать для Angular SPA?",
      "options": [
        "Только размер бандла",
        "First Contentful Paint, Time to Interactive, Largest Contentful Paint, CLS",
        "Только количество компонентов",
        "Только время сборки"
      ],
      "correct": 1,
      "explanation": "Web Vitals помогают оценить реальное восприятие скорости и стабильности UI пользователем.",
      "difficulty": "hard"
    },
    {
      "id": 270,
      "question": "Почему важно минимизировать количество прямых манипуляций с DOM в Angular?",
      "options": [
        "Чтобы ускорить сборку",
        "Чтобы не обходить систему Change Detection и не ломать кроссплатформенность",
        "Чтобы увеличить размер HTML",
        "Чтобы отключить CSS"
      ],
      "correct": 1,
      "explanation": "Прямой доступ к DOM усложняет поддержку и мешает SSR/NativeScript; лучше использовать шаблоны, Renderer2 или host bindings.",
      "difficulty": "medium"
    },
    {
      "id": 271,
      "question": "Какой паттерн помогает структурировать работу с формами, HTTP и state в пределах одного feature-модуля?",
      "options": [
        "Feature module + контейнерные/презентационные компоненты + сервисы/фасады",
        "Глобальный компонент",
        "Хранение всего кода в app.component",
        "Использование window.store"
      ],
      "correct": 0,
      "explanation": "Feature-модуль с чёткой иерархией компонентов и сервисов уменьшает связность и локализует изменения.",
      "difficulty": "hard"
    },
    {
      "id": 272,
      "question": "Как измерить, насколько часто Angular выполняет Change Detection для конкретного компонента?",
      "options": [
        "Посчитать вручную",
        "Использовать Angular DevTools и встроенные профайлеры браузера",
        "Использовать alert()",
        "Смотреть в консоль сборки"
      ],
      "correct": 1,
      "explanation": "Angular DevTools показывает количество CD-циклов для компонентов и помогает выявить горячие точки.",
      "difficulty": "hard"
    },
    {
      "id": 273,
      "question": "Почему важно использовать trackBy и иммутабельные операции с массивами при OnPush?",
      "options": [
        "Чтобы замедлить CD",
        "Чтобы Angular мог корректно определять изменения и минимизировать перерисовки списков",
        "Чтобы отключить SSR",
        "Чтобы увеличить размер бандла"
      ],
      "correct": 1,
      "explanation": "Иммутабельные операции создают новый массив, а trackBy помогает однозначно сопоставить элементы и переиспользовать DOM.",
      "difficulty": "hard"
    },
    {
      "id": 274,
      "question": "Какие преимущества даёт использование Signals вместо \"push\"-подхода с Observables для локального состояния компонента?",
      "options": [
        "Увеличение сложности",
        "Детерминированное отслеживание зависимостей, более предсказуемый CD и отсутствие необходимости в зонах",
        "Отключение типов",
        "Замена DI"
      ],
      "correct": 1,
      "explanation": "Signals дают явную декларацию зависимостей и упрощают оптимизацию рендеринга за счёт pull-based модели.",
      "difficulty": "hard"
    },
    {
      "id": 275,
      "question": "Когда использование state management библиотеки (NgRx, NGXS, Akita) оправдано в Angular проекте?",
      "options": [
        "В маленьком SPA с минимальным состоянием",
        "В средних и больших приложениях со сложным, разделяемым между множеством модулей состоянием",
        "Всегда, даже в компоненте кнопки",
        "Никогда"
      ],
      "correct": 1,
      "explanation": "State management библиотеки актуальны при сложных взаимосвязях данных, необходимости тайм-тревела, логировании действий и предсказуемости.",
      "difficulty": "hard"
    },
    {
      "id": 276,
      "question": "Как в Angular лучше всего обрабатывать глобальные 401/403 ответы сервера?",
      "options": [
        "В каждом компоненте отдельно",
        "Через HttpInterceptor, перенаправляющий на страницу логина/ошибки и очищающий токены",
        "Через console.log",
        "Через RouterGuard только"
      ],
      "correct": 1,
      "explanation": "Интерцептор централизует обработку авторизационных ошибок и уменьшает дублирование кода.",
      "difficulty": "hard"
    },
    {
      "id": 277,
      "question": "Почему важно разделять \"domain\" и \"UI\" уровни в архитектуре фронтенда?",
      "options": [
        "Чтобы написать больше кода",
        "Чтобы UI не зависел напрямую от деталей API/БД, облегчая тестирование и возможность заменить backend",
        "Чтобы отключить RxJS",
        "Чтобы увеличить размер бандла"
      ],
      "correct": 1,
      "explanation": "Разделение слоёв уменьшает связность, упрощает миграции и позволяет переиспользовать доменную логику в других интерфейсах.",
      "difficulty": "hard"
    },
    {
      "id": 278,
      "question": "Какой подход к структуре Angular проекта упрощает навигацию по коду новой команде?",
      "options": [
        "Группировка по типу (components, services) для всего приложения",
        "Группировка по фичам/домены (feature-first), где каждый домен содержит свои компоненты, сервисы и т.д.",
        "Все файлы в одной папке",
        "Файлы, названные по личным предпочтениям"
      ],
      "correct": 1,
      "explanation": "Feature-first структура помогает разработчику быстро найти весь код, относящийся к конкретной бизнес-функции.",
      "difficulty": "medium"
    },
    {
      "id": 279,
      "question": "Почему важно следить за размером Change Detection зоны компонента?",
      "options": [
        "Чтобы увеличить количество CD",
        "Чем больше дерево под компонентом, тем дороже обход при каждом CD цикле",
        "Чтобы отключить SSR",
        "Чтобы увеличить размер CSS"
      ],
      "correct": 1,
      "explanation": "Декомпозиция больших компонентов на поддеревья с OnPush снижает стоимость одного прохода CD.",
      "difficulty": "hard"
    },
    {
      "id": 280,
      "question": "Что такое \"cliff\" в производительности Angular-приложения?",
      "options": [
        "Резкое улучшение производительности",
        "Резкое падение производительности при превышении определённого порога сложности UI или данных",
        "Ошибки компиляции",
        "Сбой HTTP"
      ],
      "correct": 1,
      "explanation": "При росте количества компонентов/данных без оптимизаций CD приложение может внезапно стать заметно медленнее.",
      "difficulty": "hard"
    },
    {
      "id": 281,
      "question": "Какой подход помогает избежать \"бесконечного спиннера\" при ошибках загрузки данных?",
      "options": [
        "Никогда не обрабатывать ошибки",
        "Показывать отдельное состояние для ошибки с возможностью повторной попытки",
        "Отключить HTTP",
        "Всегда скрывать ошибки"
      ],
      "correct": 1,
      "explanation": "Явные error-state и retry-кнопки улучшают UX и позволяют пользователю восстановиться после сбоя.",
      "difficulty": "medium"
    },
    {
      "id": 282,
      "question": "Какой оператор RxJS помогает объединить значение из формы и ещё одного источника (например, текущего пользователя) перед отправкой запроса?",
      "options": [
        "merge",
        "withLatestFrom",
        "throttleTime",
        "retry"
      ],
      "correct": 1,
      "explanation": "withLatestFrom позволяет дополнить событие формы актуальным значением другого потока.",
      "difficulty": "hard"
    },
    {
      "id": 283,
      "question": "Почему важно не блокировать main thread длительными циклами и синхронными вычислениями?",
      "options": [
        "Чтобы увеличить потребление CPU",
        "Потому что UI перестаёт отвечать, а Angular не может выполнять CD и обрабатывать события",
        "Чтобы увеличить размер бандла",
        "Чтобы отключить HTTP"
      ],
      "correct": 1,
      "explanation": "Блокировка главного потока делает SPA неотзывчивым; для тяжёлых задач используют Web Workers или разделение на чанки.",
      "difficulty": "medium"
    },
    {
      "id": 284,
      "question": "Когда применяют runOutsideAngular при подписке на события scroll/resize?",
      "options": [
        "Когда нужно чаще запускать CD",
        "Когда нужно обрабатывать частые события без лишнего CD, а изменения в UI триггерить вручную по необходимости",
        "Когда нужно отключить HTTP",
        "Когда нужно выполнить SSR"
      ],
      "correct": 1,
      "explanation": "runOutsideAngular снижает нагрузку CD при частых событиях, а при необходимости можно вручную обновить UI.",
      "difficulty": "hard"
    },
    {
      "id": 285,
      "question": "Какие практики помогают готовить Angular-приложение к micro-frontend архитектуре?",
      "options": [
        "Глобальное состояние без границ",
        "Ясные границы контекстов, независимые модули, минимальные глобальные зависимости и использование Module Federation при необходимости",
        "Все компоненты в одном модуле",
        "Хранение конфигурации в компонентах"
      ],
      "correct": 1,
      "explanation": "Хорошо выделенные домены и слабые связи упрощают разделение приложения на независимые micro-frontends.",
      "difficulty": "hard"
    },
    {
      "id": 286,
      "question": "Что такое Module Federation в контексте Angular/Webpack?",
      "options": [
        "Система DI",
        "Механизм динамической загрузки удалённых модулей/приложений (remote) в runtime",
        "Система миграций",
        "Система логирования"
      ],
      "correct": 1,
      "explanation": "Module Federation позволяет нескольким сборкам делиться модулями и загружать их по сети во время выполнения.",
      "difficulty": "hard"
    },
    {
      "id": 287,
      "question": "Почему важно придерживаться единого code style и архитектурных договорённостей в команде Angular-разработки?",
      "options": [
        "Чтобы усложнить вход новым разработчикам",
        "Чтобы упростить чтение кода, снизить количество ошибок и ускорить code review",
        "Чтобы увеличить размер репозитория",
        "Чтобы отключить линтер"
      ],
      "correct": 1,
      "explanation": "Общие правила уменьшают когнитивную нагрузку, помогают автоматизировать проверки и делают проект предсказуемым.",
      "difficulty": "easy"
    },
    {
      "id": 288,
      "question": "Какие преимущества даёт выделение интерфейсов/типов DTO для данных, приходящих с API, отдельно от доменных моделей UI?",
      "options": [
        "Увеличение boilerplate",
        "Явное отделение транспортного слоя, возможность адаптации и эволюции API без ломки UI",
        "Увеличение размера бандла",
        "Отключение типов"
      ],
      "correct": 1,
      "explanation": "Разделение DTO и доменных моделей упрощает миграции API и повышает читаемость бизнес-логики.",
      "difficulty": "hard"
    },
    {
      "id": 289,
      "question": "Почему стоит избегать хранения больших объёмов состояния в компоненте верхнего уровня (AppComponent)?",
      "options": [
        "Чтобы увеличить связность",
        "Потому что это затрудняет повторное использование, тестирование и приводит к перегрузке одного компонента",
        "Чтобы увеличить размер HTML",
        "Чтобы отключить SSR"
      ],
      "correct": 1,
      "explanation": "Сосредоточение логики в AppComponent превращает его в \"god object\" и усложняет эволюцию и разделение обязанностей.",
      "difficulty": "medium"
    },
    {
      "id": 290,
      "question": "В чём преимущество использования feature-модулей с собственными routing-модулями?",
      "options": [
        "Усложнение структуры",
        "Локализация маршрутов и логики в рамках домена, улучшение читаемости и изоляции",
        "Отсутствие необходимости в Router",
        "Увеличение размера бандла"
      ],
      "correct": 1,
      "explanation": "Feature routing-модули позволяют каждому домену управлять своими маршрутами, не раздувая корневую конфигурацию.",
      "difficulty": "medium"
    },
    {
      "id": 291,
      "question": "Какой шаблон проектирования лежит в основе DI в Angular?",
      "options": [
        "Singleton",
        "Inversion of Control (IoC) с контейнером зависимостей",
        "Factory Method",
        "Decorator"
      ],
      "correct": 1,
      "explanation": "DI/IoC контейнер берёт на себя создание зависимостей и их доставку, инвертируя контроль по сравнению с ручным new.",
      "difficulty": "hard"
    },
    {
      "id": 292,
      "question": "Почему важно избегать business-логики в шаблоне Angular?",
      "options": [
        "Чтобы уменьшить количество файлов",
        "Потому что выражения в шаблоне могут выполняться многократно при CD, а логика сложнее тестируется и читается",
        "Чтобы отключить DI",
        "Чтобы увеличить размер HTML"
      ],
      "correct": 1,
      "explanation": "Сложную логику лучше выносить в методы/сервисы и по возможности мемоизировать, оставляя шаблон декларативным.",
      "difficulty": "medium"
    },
    {
      "id": 293,
      "question": "Какой оператор RxJS стоит использовать, чтобы завершить поток после получения первого значения?",
      "options": [
        "skip(1)",
        "take(1)",
        "retry(1)",
        "buffer(1)"
      ],
      "correct": 1,
      "explanation": "take(1) подписывается на поток, пропускает первое значение и затем завершает Observable.",
      "difficulty": "easy"
    },
    {
      "id": 294,
      "question": "Когда уместно использовать BehaviorSubject для локального состояния сервиса?",
      "options": [
        "Когда состояние не должно иметь начального значения",
        "Когда нужно хранить и раздать последнее известное значение всем текущим и будущим подписчикам",
        "Когда нужно только логировать",
        "Когда нужен только один подписчик"
      ],
      "correct": 1,
      "explanation": "BehaviorSubject удобен как простой стор: он всегда содержит текущее значение и немедленно отдаёт его подписчикам.",
      "difficulty": "medium"
    },
    {
      "id": 295,
      "question": "Какой оператор RxJS стоит использовать для пропуска первых N значений потока?",
      "options": [
        "take(N)",
        "skip(N)",
        "debounceTime(N)",
        "bufferCount(N)"
      ],
      "correct": 1,
      "explanation": "skip(N) игнорирует первые N значений и начинает эмитить только последующие.",
      "difficulty": "easy"
    },
    {
      "id": 296,
      "question": "Какой оператор RxJS позволяет накопить значения в массив фиксированной длины и эмитить их пакетами?",
      "options": [
        "bufferTime",
        "bufferCount",
        "windowTime",
        "pairwise"
      ],
      "correct": 1,
      "explanation": "bufferCount(N) собирает N значений в массив и эмитит его, затем начинает накапливать следующий пакет.",
      "difficulty": "hard"
    },
    {
      "id": 297,
      "question": "Когда уместно использовать guard CanLoad?",
      "options": [
        "Для защиты отдельных компонентов",
        "Для предотвращения даже загрузки кода ленивого модуля, если доступ запрещён",
        "Для обработки ошибок HTTP",
        "Для логирования переходов"
      ],
      "correct": 1,
      "explanation": "CanLoad блокирует загрузку lazy-модуля, если пользователь не авторизован или не имеет прав, экономя трафик и повышая безопасность.",
      "difficulty": "hard"
    },
    {
      "id": 298,
      "question": "Какой способ передачи данных в компонент наиболее предпочтителен, если эти данные приходят из родителя?",
      "options": [
        "Через глобальные переменные",
        "Через @Input свойства",
        "Через localStorage",
        "Через window.location"
      ],
      "correct": 1,
      "explanation": "@Input обеспечивает явный и типобезопасный контракт между родителем и дочерним компонентом.",
      "difficulty": "easy"
    },
    {
      "id": 299,
      "question": "Что из перечисленного является хорошей практикой при работе с Angular шаблонами?",
      "options": [
        "Выполнять тяжёлые вычисления прямо в выражениях шаблона",
        "Использовать простые выражения, выносить логику в методы/пайпы и избегать побочных эффектов",
        "Использовать eval() в шаблоне",
        "Читать/писать в localStorage из интерполяции"
      ],
      "correct": 1,
      "explanation": "Шаблон должен быть декларативным; тяжёлую или побочную логику стоит вынести в код компонента или сервисы.",
      "difficulty": "medium"
    },
    {
      "id": 300,
      "question": "Почему важно покрывать Angular-компоненты и сервисы юнит-тестами?",
      "options": [
        "Чтобы замедлить разработку",
        "Чтобы уменьшить регрессии, документировать поведение и безопасно рефакторить код",
        "Чтобы увеличить размер репозитория",
        "Чтобы отключить линтер"
      ],
      "correct": 1,
      "explanation": "Юнит-тесты позволяют уверенно вносить изменения, быстро находить регрессии и служат живой документацией поведения.",
      "difficulty": "medium"
    }
  ]
}